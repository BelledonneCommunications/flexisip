// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
#if __clang__ || __GNUC__ >= 4
	#pragma GCC diagnostic push
	#pragma GCC diagnostic ignored "-Wfloat-equal"
	#pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
#ifndef __ANDROID__
	#pragma GCC diagnostic ignored "-Wsuggest-override"
#endif
#endif
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "rpid.hh"

namespace Xsd
{
  namespace Rpid
  {
    // Timestamp_t
    // 


    // DeviceID_t
    // 


    // Note_t
    // 

    const Note_t::LangOptional& Note_t::
    getLang () const
    {
      return this->lang_;
    }

    Note_t::LangOptional& Note_t::
    getLang ()
    {
      return this->lang_;
    }

    void Note_t::
    setLang (const LangType& x)
    {
      this->lang_.set (x);
    }

    void Note_t::
    setLang (const LangOptional& x)
    {
      this->lang_ = x;
    }

    void Note_t::
    setLang (::std::unique_ptr< LangType > x)
    {
      this->lang_.set (std::move (x));
    }


    // Empty
    // 
  }
}

namespace Xsd
{
  namespace Rpid
  {
    // ActiveIdle
    // 

    ActiveIdle::
    ActiveIdle (Value v)
    : ::Xsd::XmlSchema::String (_xsd_ActiveIdle_literals_[v])
    {
    }

    ActiveIdle::
    ActiveIdle (const char* v)
    : ::Xsd::XmlSchema::String (v)
    {
    }

    ActiveIdle::
    ActiveIdle (const ::std::string& v)
    : ::Xsd::XmlSchema::String (v)
    {
    }

    ActiveIdle::
    ActiveIdle (const ::Xsd::XmlSchema::String& v)
    : ::Xsd::XmlSchema::String (v)
    {
    }

    ActiveIdle::
    ActiveIdle (const ActiveIdle& v,
                ::Xsd::XmlSchema::Flags f,
                ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::String (v, f, c)
    {
    }

    ActiveIdle& ActiveIdle::
    operator= (Value v)
    {
      static_cast< ::Xsd::XmlSchema::String& > (*this) = 
      ::Xsd::XmlSchema::String (_xsd_ActiveIdle_literals_[v]);

      return *this;
    }


    // Activities
    // 

    const Activities::NoteSequence& Activities::
    getNote () const
    {
      return this->note_;
    }

    Activities::NoteSequence& Activities::
    getNote ()
    {
      return this->note_;
    }

    void Activities::
    setNote (const NoteSequence& s)
    {
      this->note_ = s;
    }

    const Activities::UnknownOptional& Activities::
    getUnknown () const
    {
      return this->unknown_;
    }

    Activities::UnknownOptional& Activities::
    getUnknown ()
    {
      return this->unknown_;
    }

    void Activities::
    setUnknown (const UnknownType& x)
    {
      this->unknown_.set (x);
    }

    void Activities::
    setUnknown (const UnknownOptional& x)
    {
      this->unknown_ = x;
    }

    void Activities::
    setUnknown (::std::unique_ptr< UnknownType > x)
    {
      this->unknown_.set (std::move (x));
    }

    const Activities::AppointmentSequence& Activities::
    getAppointment () const
    {
      return this->appointment_;
    }

    Activities::AppointmentSequence& Activities::
    getAppointment ()
    {
      return this->appointment_;
    }

    void Activities::
    setAppointment (const AppointmentSequence& s)
    {
      this->appointment_ = s;
    }

    const Activities::AwaySequence& Activities::
    getAway () const
    {
      return this->away_;
    }

    Activities::AwaySequence& Activities::
    getAway ()
    {
      return this->away_;
    }

    void Activities::
    setAway (const AwaySequence& s)
    {
      this->away_ = s;
    }

    const Activities::BreakfastSequence& Activities::
    getBreakfast () const
    {
      return this->breakfast_;
    }

    Activities::BreakfastSequence& Activities::
    getBreakfast ()
    {
      return this->breakfast_;
    }

    void Activities::
    setBreakfast (const BreakfastSequence& s)
    {
      this->breakfast_ = s;
    }

    const Activities::BusySequence& Activities::
    getBusy () const
    {
      return this->busy_;
    }

    Activities::BusySequence& Activities::
    getBusy ()
    {
      return this->busy_;
    }

    void Activities::
    setBusy (const BusySequence& s)
    {
      this->busy_ = s;
    }

    const Activities::DinnerSequence& Activities::
    getDinner () const
    {
      return this->dinner_;
    }

    Activities::DinnerSequence& Activities::
    getDinner ()
    {
      return this->dinner_;
    }

    void Activities::
    setDinner (const DinnerSequence& s)
    {
      this->dinner_ = s;
    }

    const Activities::HolidaySequence& Activities::
    getHoliday () const
    {
      return this->holiday_;
    }

    Activities::HolidaySequence& Activities::
    getHoliday ()
    {
      return this->holiday_;
    }

    void Activities::
    setHoliday (const HolidaySequence& s)
    {
      this->holiday_ = s;
    }

    const Activities::InTransitSequence& Activities::
    getInTransit () const
    {
      return this->in_transit_;
    }

    Activities::InTransitSequence& Activities::
    getInTransit ()
    {
      return this->in_transit_;
    }

    void Activities::
    setInTransit (const InTransitSequence& s)
    {
      this->in_transit_ = s;
    }

    const Activities::LookingForWorkSequence& Activities::
    getLookingForWork () const
    {
      return this->looking_for_work_;
    }

    Activities::LookingForWorkSequence& Activities::
    getLookingForWork ()
    {
      return this->looking_for_work_;
    }

    void Activities::
    setLookingForWork (const LookingForWorkSequence& s)
    {
      this->looking_for_work_ = s;
    }

    const Activities::MealSequence& Activities::
    getMeal () const
    {
      return this->meal_;
    }

    Activities::MealSequence& Activities::
    getMeal ()
    {
      return this->meal_;
    }

    void Activities::
    setMeal (const MealSequence& s)
    {
      this->meal_ = s;
    }

    const Activities::MeetingSequence& Activities::
    getMeeting () const
    {
      return this->meeting_;
    }

    Activities::MeetingSequence& Activities::
    getMeeting ()
    {
      return this->meeting_;
    }

    void Activities::
    setMeeting (const MeetingSequence& s)
    {
      this->meeting_ = s;
    }

    const Activities::OnThePhoneSequence& Activities::
    getOnThePhone () const
    {
      return this->on_the_phone_;
    }

    Activities::OnThePhoneSequence& Activities::
    getOnThePhone ()
    {
      return this->on_the_phone_;
    }

    void Activities::
    setOnThePhone (const OnThePhoneSequence& s)
    {
      this->on_the_phone_ = s;
    }

    const Activities::PerformanceSequence& Activities::
    getPerformance () const
    {
      return this->performance_;
    }

    Activities::PerformanceSequence& Activities::
    getPerformance ()
    {
      return this->performance_;
    }

    void Activities::
    setPerformance (const PerformanceSequence& s)
    {
      this->performance_ = s;
    }

    const Activities::PermanentAbsenceSequence& Activities::
    getPermanentAbsence () const
    {
      return this->permanent_absence_;
    }

    Activities::PermanentAbsenceSequence& Activities::
    getPermanentAbsence ()
    {
      return this->permanent_absence_;
    }

    void Activities::
    setPermanentAbsence (const PermanentAbsenceSequence& s)
    {
      this->permanent_absence_ = s;
    }

    const Activities::PlayingSequence& Activities::
    getPlaying () const
    {
      return this->playing_;
    }

    Activities::PlayingSequence& Activities::
    getPlaying ()
    {
      return this->playing_;
    }

    void Activities::
    setPlaying (const PlayingSequence& s)
    {
      this->playing_ = s;
    }

    const Activities::PresentationSequence& Activities::
    getPresentation () const
    {
      return this->presentation_;
    }

    Activities::PresentationSequence& Activities::
    getPresentation ()
    {
      return this->presentation_;
    }

    void Activities::
    setPresentation (const PresentationSequence& s)
    {
      this->presentation_ = s;
    }

    const Activities::ShoppingSequence& Activities::
    getShopping () const
    {
      return this->shopping_;
    }

    Activities::ShoppingSequence& Activities::
    getShopping ()
    {
      return this->shopping_;
    }

    void Activities::
    setShopping (const ShoppingSequence& s)
    {
      this->shopping_ = s;
    }

    const Activities::SleepingSequence& Activities::
    getSleeping () const
    {
      return this->sleeping_;
    }

    Activities::SleepingSequence& Activities::
    getSleeping ()
    {
      return this->sleeping_;
    }

    void Activities::
    setSleeping (const SleepingSequence& s)
    {
      this->sleeping_ = s;
    }

    const Activities::SpectatorSequence& Activities::
    getSpectator () const
    {
      return this->spectator_;
    }

    Activities::SpectatorSequence& Activities::
    getSpectator ()
    {
      return this->spectator_;
    }

    void Activities::
    setSpectator (const SpectatorSequence& s)
    {
      this->spectator_ = s;
    }

    const Activities::SteeringSequence& Activities::
    getSteering () const
    {
      return this->steering_;
    }

    Activities::SteeringSequence& Activities::
    getSteering ()
    {
      return this->steering_;
    }

    void Activities::
    setSteering (const SteeringSequence& s)
    {
      this->steering_ = s;
    }

    const Activities::TravelSequence& Activities::
    getTravel () const
    {
      return this->travel_;
    }

    Activities::TravelSequence& Activities::
    getTravel ()
    {
      return this->travel_;
    }

    void Activities::
    setTravel (const TravelSequence& s)
    {
      this->travel_ = s;
    }

    const Activities::TvSequence& Activities::
    getTv () const
    {
      return this->tv_;
    }

    Activities::TvSequence& Activities::
    getTv ()
    {
      return this->tv_;
    }

    void Activities::
    setTv (const TvSequence& s)
    {
      this->tv_ = s;
    }

    const Activities::VacationSequence& Activities::
    getVacation () const
    {
      return this->vacation_;
    }

    Activities::VacationSequence& Activities::
    getVacation ()
    {
      return this->vacation_;
    }

    void Activities::
    setVacation (const VacationSequence& s)
    {
      this->vacation_ = s;
    }

    const Activities::WorkingSequence& Activities::
    getWorking () const
    {
      return this->working_;
    }

    Activities::WorkingSequence& Activities::
    getWorking ()
    {
      return this->working_;
    }

    void Activities::
    setWorking (const WorkingSequence& s)
    {
      this->working_ = s;
    }

    const Activities::WorshipSequence& Activities::
    getWorship () const
    {
      return this->worship_;
    }

    Activities::WorshipSequence& Activities::
    getWorship ()
    {
      return this->worship_;
    }

    void Activities::
    setWorship (const WorshipSequence& s)
    {
      this->worship_ = s;
    }

    const Activities::OtherSequence& Activities::
    getOther () const
    {
      return this->other_;
    }

    Activities::OtherSequence& Activities::
    getOther ()
    {
      return this->other_;
    }

    void Activities::
    setOther (const OtherSequence& s)
    {
      this->other_ = s;
    }

    const Activities::AnySequence& Activities::
    getAny () const
    {
      return this->any_;
    }

    Activities::AnySequence& Activities::
    getAny ()
    {
      return this->any_;
    }

    void Activities::
    setAny (const AnySequence& s)
    {
      this->any_ = s;
    }

    const Activities::FromOptional& Activities::
    getFrom () const
    {
      return this->from_;
    }

    Activities::FromOptional& Activities::
    getFrom ()
    {
      return this->from_;
    }

    void Activities::
    setFrom (const FromType& x)
    {
      this->from_.set (x);
    }

    void Activities::
    setFrom (const FromOptional& x)
    {
      this->from_ = x;
    }

    void Activities::
    setFrom (::std::unique_ptr< FromType > x)
    {
      this->from_.set (std::move (x));
    }

    const Activities::UntilOptional& Activities::
    getUntil () const
    {
      return this->until_;
    }

    Activities::UntilOptional& Activities::
    getUntil ()
    {
      return this->until_;
    }

    void Activities::
    setUntil (const UntilType& x)
    {
      this->until_.set (x);
    }

    void Activities::
    setUntil (const UntilOptional& x)
    {
      this->until_ = x;
    }

    void Activities::
    setUntil (::std::unique_ptr< UntilType > x)
    {
      this->until_.set (std::move (x));
    }

    const Activities::IdOptional& Activities::
    getId () const
    {
      return this->id_;
    }

    Activities::IdOptional& Activities::
    getId ()
    {
      return this->id_;
    }

    void Activities::
    setId (const IdType& x)
    {
      this->id_.set (x);
    }

    void Activities::
    setId (const IdOptional& x)
    {
      this->id_ = x;
    }

    void Activities::
    setId (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const Activities::AnyAttributeSet& Activities::
    getAnyAttribute () const
    {
      return this->any_attribute_;
    }

    Activities::AnyAttributeSet& Activities::
    getAnyAttribute ()
    {
      return this->any_attribute_;
    }

    void Activities::
    setAnyAttribute (const AnyAttributeSet& s)
    {
      this->any_attribute_ = s;
    }

    const ::xercesc::DOMDocument& Activities::
    getDomDocument () const
    {
      return *this->dom_document_;
    }

    ::xercesc::DOMDocument& Activities::
    getDomDocument ()
    {
      return *this->dom_document_;
    }


    // Mood
    // 

    const Mood::NoteSequence& Mood::
    getNote () const
    {
      return this->note_;
    }

    Mood::NoteSequence& Mood::
    getNote ()
    {
      return this->note_;
    }

    void Mood::
    setNote (const NoteSequence& s)
    {
      this->note_ = s;
    }

    const Mood::UnknownOptional& Mood::
    getUnknown () const
    {
      return this->unknown_;
    }

    Mood::UnknownOptional& Mood::
    getUnknown ()
    {
      return this->unknown_;
    }

    void Mood::
    setUnknown (const UnknownType& x)
    {
      this->unknown_.set (x);
    }

    void Mood::
    setUnknown (const UnknownOptional& x)
    {
      this->unknown_ = x;
    }

    void Mood::
    setUnknown (::std::unique_ptr< UnknownType > x)
    {
      this->unknown_.set (std::move (x));
    }

    const Mood::AfraidSequence& Mood::
    getAfraid () const
    {
      return this->afraid_;
    }

    Mood::AfraidSequence& Mood::
    getAfraid ()
    {
      return this->afraid_;
    }

    void Mood::
    setAfraid (const AfraidSequence& s)
    {
      this->afraid_ = s;
    }

    const Mood::AmazedSequence& Mood::
    getAmazed () const
    {
      return this->amazed_;
    }

    Mood::AmazedSequence& Mood::
    getAmazed ()
    {
      return this->amazed_;
    }

    void Mood::
    setAmazed (const AmazedSequence& s)
    {
      this->amazed_ = s;
    }

    const Mood::AngrySequence& Mood::
    getAngry () const
    {
      return this->angry_;
    }

    Mood::AngrySequence& Mood::
    getAngry ()
    {
      return this->angry_;
    }

    void Mood::
    setAngry (const AngrySequence& s)
    {
      this->angry_ = s;
    }

    const Mood::AnnoyedSequence& Mood::
    getAnnoyed () const
    {
      return this->annoyed_;
    }

    Mood::AnnoyedSequence& Mood::
    getAnnoyed ()
    {
      return this->annoyed_;
    }

    void Mood::
    setAnnoyed (const AnnoyedSequence& s)
    {
      this->annoyed_ = s;
    }

    const Mood::AnxiousSequence& Mood::
    getAnxious () const
    {
      return this->anxious_;
    }

    Mood::AnxiousSequence& Mood::
    getAnxious ()
    {
      return this->anxious_;
    }

    void Mood::
    setAnxious (const AnxiousSequence& s)
    {
      this->anxious_ = s;
    }

    const Mood::AshamedSequence& Mood::
    getAshamed () const
    {
      return this->ashamed_;
    }

    Mood::AshamedSequence& Mood::
    getAshamed ()
    {
      return this->ashamed_;
    }

    void Mood::
    setAshamed (const AshamedSequence& s)
    {
      this->ashamed_ = s;
    }

    const Mood::BoredSequence& Mood::
    getBored () const
    {
      return this->bored_;
    }

    Mood::BoredSequence& Mood::
    getBored ()
    {
      return this->bored_;
    }

    void Mood::
    setBored (const BoredSequence& s)
    {
      this->bored_ = s;
    }

    const Mood::BraveSequence& Mood::
    getBrave () const
    {
      return this->brave_;
    }

    Mood::BraveSequence& Mood::
    getBrave ()
    {
      return this->brave_;
    }

    void Mood::
    setBrave (const BraveSequence& s)
    {
      this->brave_ = s;
    }

    const Mood::CalmSequence& Mood::
    getCalm () const
    {
      return this->calm_;
    }

    Mood::CalmSequence& Mood::
    getCalm ()
    {
      return this->calm_;
    }

    void Mood::
    setCalm (const CalmSequence& s)
    {
      this->calm_ = s;
    }

    const Mood::ColdSequence& Mood::
    getCold () const
    {
      return this->cold_;
    }

    Mood::ColdSequence& Mood::
    getCold ()
    {
      return this->cold_;
    }

    void Mood::
    setCold (const ColdSequence& s)
    {
      this->cold_ = s;
    }

    const Mood::ConfusedSequence& Mood::
    getConfused () const
    {
      return this->confused_;
    }

    Mood::ConfusedSequence& Mood::
    getConfused ()
    {
      return this->confused_;
    }

    void Mood::
    setConfused (const ConfusedSequence& s)
    {
      this->confused_ = s;
    }

    const Mood::ContentedSequence& Mood::
    getContented () const
    {
      return this->contented_;
    }

    Mood::ContentedSequence& Mood::
    getContented ()
    {
      return this->contented_;
    }

    void Mood::
    setContented (const ContentedSequence& s)
    {
      this->contented_ = s;
    }

    const Mood::CrankySequence& Mood::
    getCranky () const
    {
      return this->cranky_;
    }

    Mood::CrankySequence& Mood::
    getCranky ()
    {
      return this->cranky_;
    }

    void Mood::
    setCranky (const CrankySequence& s)
    {
      this->cranky_ = s;
    }

    const Mood::CuriousSequence& Mood::
    getCurious () const
    {
      return this->curious_;
    }

    Mood::CuriousSequence& Mood::
    getCurious ()
    {
      return this->curious_;
    }

    void Mood::
    setCurious (const CuriousSequence& s)
    {
      this->curious_ = s;
    }

    const Mood::DepressedSequence& Mood::
    getDepressed () const
    {
      return this->depressed_;
    }

    Mood::DepressedSequence& Mood::
    getDepressed ()
    {
      return this->depressed_;
    }

    void Mood::
    setDepressed (const DepressedSequence& s)
    {
      this->depressed_ = s;
    }

    const Mood::DisappointedSequence& Mood::
    getDisappointed () const
    {
      return this->disappointed_;
    }

    Mood::DisappointedSequence& Mood::
    getDisappointed ()
    {
      return this->disappointed_;
    }

    void Mood::
    setDisappointed (const DisappointedSequence& s)
    {
      this->disappointed_ = s;
    }

    const Mood::DisgustedSequence& Mood::
    getDisgusted () const
    {
      return this->disgusted_;
    }

    Mood::DisgustedSequence& Mood::
    getDisgusted ()
    {
      return this->disgusted_;
    }

    void Mood::
    setDisgusted (const DisgustedSequence& s)
    {
      this->disgusted_ = s;
    }

    const Mood::DistractedSequence& Mood::
    getDistracted () const
    {
      return this->distracted_;
    }

    Mood::DistractedSequence& Mood::
    getDistracted ()
    {
      return this->distracted_;
    }

    void Mood::
    setDistracted (const DistractedSequence& s)
    {
      this->distracted_ = s;
    }

    const Mood::EmbarrassedSequence& Mood::
    getEmbarrassed () const
    {
      return this->embarrassed_;
    }

    Mood::EmbarrassedSequence& Mood::
    getEmbarrassed ()
    {
      return this->embarrassed_;
    }

    void Mood::
    setEmbarrassed (const EmbarrassedSequence& s)
    {
      this->embarrassed_ = s;
    }

    const Mood::ExcitedSequence& Mood::
    getExcited () const
    {
      return this->excited_;
    }

    Mood::ExcitedSequence& Mood::
    getExcited ()
    {
      return this->excited_;
    }

    void Mood::
    setExcited (const ExcitedSequence& s)
    {
      this->excited_ = s;
    }

    const Mood::FlirtatiousSequence& Mood::
    getFlirtatious () const
    {
      return this->flirtatious_;
    }

    Mood::FlirtatiousSequence& Mood::
    getFlirtatious ()
    {
      return this->flirtatious_;
    }

    void Mood::
    setFlirtatious (const FlirtatiousSequence& s)
    {
      this->flirtatious_ = s;
    }

    const Mood::FrustratedSequence& Mood::
    getFrustrated () const
    {
      return this->frustrated_;
    }

    Mood::FrustratedSequence& Mood::
    getFrustrated ()
    {
      return this->frustrated_;
    }

    void Mood::
    setFrustrated (const FrustratedSequence& s)
    {
      this->frustrated_ = s;
    }

    const Mood::GrumpySequence& Mood::
    getGrumpy () const
    {
      return this->grumpy_;
    }

    Mood::GrumpySequence& Mood::
    getGrumpy ()
    {
      return this->grumpy_;
    }

    void Mood::
    setGrumpy (const GrumpySequence& s)
    {
      this->grumpy_ = s;
    }

    const Mood::GuiltySequence& Mood::
    getGuilty () const
    {
      return this->guilty_;
    }

    Mood::GuiltySequence& Mood::
    getGuilty ()
    {
      return this->guilty_;
    }

    void Mood::
    setGuilty (const GuiltySequence& s)
    {
      this->guilty_ = s;
    }

    const Mood::HappySequence& Mood::
    getHappy () const
    {
      return this->happy_;
    }

    Mood::HappySequence& Mood::
    getHappy ()
    {
      return this->happy_;
    }

    void Mood::
    setHappy (const HappySequence& s)
    {
      this->happy_ = s;
    }

    const Mood::HotSequence& Mood::
    getHot () const
    {
      return this->hot_;
    }

    Mood::HotSequence& Mood::
    getHot ()
    {
      return this->hot_;
    }

    void Mood::
    setHot (const HotSequence& s)
    {
      this->hot_ = s;
    }

    const Mood::HumbledSequence& Mood::
    getHumbled () const
    {
      return this->humbled_;
    }

    Mood::HumbledSequence& Mood::
    getHumbled ()
    {
      return this->humbled_;
    }

    void Mood::
    setHumbled (const HumbledSequence& s)
    {
      this->humbled_ = s;
    }

    const Mood::HumiliatedSequence& Mood::
    getHumiliated () const
    {
      return this->humiliated_;
    }

    Mood::HumiliatedSequence& Mood::
    getHumiliated ()
    {
      return this->humiliated_;
    }

    void Mood::
    setHumiliated (const HumiliatedSequence& s)
    {
      this->humiliated_ = s;
    }

    const Mood::HungrySequence& Mood::
    getHungry () const
    {
      return this->hungry_;
    }

    Mood::HungrySequence& Mood::
    getHungry ()
    {
      return this->hungry_;
    }

    void Mood::
    setHungry (const HungrySequence& s)
    {
      this->hungry_ = s;
    }

    const Mood::HurtSequence& Mood::
    getHurt () const
    {
      return this->hurt_;
    }

    Mood::HurtSequence& Mood::
    getHurt ()
    {
      return this->hurt_;
    }

    void Mood::
    setHurt (const HurtSequence& s)
    {
      this->hurt_ = s;
    }

    const Mood::ImpressedSequence& Mood::
    getImpressed () const
    {
      return this->impressed_;
    }

    Mood::ImpressedSequence& Mood::
    getImpressed ()
    {
      return this->impressed_;
    }

    void Mood::
    setImpressed (const ImpressedSequence& s)
    {
      this->impressed_ = s;
    }

    const Mood::In_aweSequence& Mood::
    getIn_awe () const
    {
      return this->in_awe_;
    }

    Mood::In_aweSequence& Mood::
    getIn_awe ()
    {
      return this->in_awe_;
    }

    void Mood::
    setIn_awe (const In_aweSequence& s)
    {
      this->in_awe_ = s;
    }

    const Mood::In_loveSequence& Mood::
    getIn_love () const
    {
      return this->in_love_;
    }

    Mood::In_loveSequence& Mood::
    getIn_love ()
    {
      return this->in_love_;
    }

    void Mood::
    setIn_love (const In_loveSequence& s)
    {
      this->in_love_ = s;
    }

    const Mood::IndignantSequence& Mood::
    getIndignant () const
    {
      return this->indignant_;
    }

    Mood::IndignantSequence& Mood::
    getIndignant ()
    {
      return this->indignant_;
    }

    void Mood::
    setIndignant (const IndignantSequence& s)
    {
      this->indignant_ = s;
    }

    const Mood::InterestedSequence& Mood::
    getInterested () const
    {
      return this->interested_;
    }

    Mood::InterestedSequence& Mood::
    getInterested ()
    {
      return this->interested_;
    }

    void Mood::
    setInterested (const InterestedSequence& s)
    {
      this->interested_ = s;
    }

    const Mood::InvincibleSequence& Mood::
    getInvincible () const
    {
      return this->invincible_;
    }

    Mood::InvincibleSequence& Mood::
    getInvincible ()
    {
      return this->invincible_;
    }

    void Mood::
    setInvincible (const InvincibleSequence& s)
    {
      this->invincible_ = s;
    }

    const Mood::JealousSequence& Mood::
    getJealous () const
    {
      return this->jealous_;
    }

    Mood::JealousSequence& Mood::
    getJealous ()
    {
      return this->jealous_;
    }

    void Mood::
    setJealous (const JealousSequence& s)
    {
      this->jealous_ = s;
    }

    const Mood::LonelySequence& Mood::
    getLonely () const
    {
      return this->lonely_;
    }

    Mood::LonelySequence& Mood::
    getLonely ()
    {
      return this->lonely_;
    }

    void Mood::
    setLonely (const LonelySequence& s)
    {
      this->lonely_ = s;
    }

    const Mood::MeanSequence& Mood::
    getMean () const
    {
      return this->mean_;
    }

    Mood::MeanSequence& Mood::
    getMean ()
    {
      return this->mean_;
    }

    void Mood::
    setMean (const MeanSequence& s)
    {
      this->mean_ = s;
    }

    const Mood::MoodySequence& Mood::
    getMoody () const
    {
      return this->moody_;
    }

    Mood::MoodySequence& Mood::
    getMoody ()
    {
      return this->moody_;
    }

    void Mood::
    setMoody (const MoodySequence& s)
    {
      this->moody_ = s;
    }

    const Mood::NervousSequence& Mood::
    getNervous () const
    {
      return this->nervous_;
    }

    Mood::NervousSequence& Mood::
    getNervous ()
    {
      return this->nervous_;
    }

    void Mood::
    setNervous (const NervousSequence& s)
    {
      this->nervous_ = s;
    }

    const Mood::NeutralSequence& Mood::
    getNeutral () const
    {
      return this->neutral_;
    }

    Mood::NeutralSequence& Mood::
    getNeutral ()
    {
      return this->neutral_;
    }

    void Mood::
    setNeutral (const NeutralSequence& s)
    {
      this->neutral_ = s;
    }

    const Mood::OffendedSequence& Mood::
    getOffended () const
    {
      return this->offended_;
    }

    Mood::OffendedSequence& Mood::
    getOffended ()
    {
      return this->offended_;
    }

    void Mood::
    setOffended (const OffendedSequence& s)
    {
      this->offended_ = s;
    }

    const Mood::PlayfulSequence& Mood::
    getPlayful () const
    {
      return this->playful_;
    }

    Mood::PlayfulSequence& Mood::
    getPlayful ()
    {
      return this->playful_;
    }

    void Mood::
    setPlayful (const PlayfulSequence& s)
    {
      this->playful_ = s;
    }

    const Mood::ProudSequence& Mood::
    getProud () const
    {
      return this->proud_;
    }

    Mood::ProudSequence& Mood::
    getProud ()
    {
      return this->proud_;
    }

    void Mood::
    setProud (const ProudSequence& s)
    {
      this->proud_ = s;
    }

    const Mood::RelievedSequence& Mood::
    getRelieved () const
    {
      return this->relieved_;
    }

    Mood::RelievedSequence& Mood::
    getRelieved ()
    {
      return this->relieved_;
    }

    void Mood::
    setRelieved (const RelievedSequence& s)
    {
      this->relieved_ = s;
    }

    const Mood::RemorsefulSequence& Mood::
    getRemorseful () const
    {
      return this->remorseful_;
    }

    Mood::RemorsefulSequence& Mood::
    getRemorseful ()
    {
      return this->remorseful_;
    }

    void Mood::
    setRemorseful (const RemorsefulSequence& s)
    {
      this->remorseful_ = s;
    }

    const Mood::RestlessSequence& Mood::
    getRestless () const
    {
      return this->restless_;
    }

    Mood::RestlessSequence& Mood::
    getRestless ()
    {
      return this->restless_;
    }

    void Mood::
    setRestless (const RestlessSequence& s)
    {
      this->restless_ = s;
    }

    const Mood::SadSequence& Mood::
    getSad () const
    {
      return this->sad_;
    }

    Mood::SadSequence& Mood::
    getSad ()
    {
      return this->sad_;
    }

    void Mood::
    setSad (const SadSequence& s)
    {
      this->sad_ = s;
    }

    const Mood::SarcasticSequence& Mood::
    getSarcastic () const
    {
      return this->sarcastic_;
    }

    Mood::SarcasticSequence& Mood::
    getSarcastic ()
    {
      return this->sarcastic_;
    }

    void Mood::
    setSarcastic (const SarcasticSequence& s)
    {
      this->sarcastic_ = s;
    }

    const Mood::SeriousSequence& Mood::
    getSerious () const
    {
      return this->serious_;
    }

    Mood::SeriousSequence& Mood::
    getSerious ()
    {
      return this->serious_;
    }

    void Mood::
    setSerious (const SeriousSequence& s)
    {
      this->serious_ = s;
    }

    const Mood::ShockedSequence& Mood::
    getShocked () const
    {
      return this->shocked_;
    }

    Mood::ShockedSequence& Mood::
    getShocked ()
    {
      return this->shocked_;
    }

    void Mood::
    setShocked (const ShockedSequence& s)
    {
      this->shocked_ = s;
    }

    const Mood::ShySequence& Mood::
    getShy () const
    {
      return this->shy_;
    }

    Mood::ShySequence& Mood::
    getShy ()
    {
      return this->shy_;
    }

    void Mood::
    setShy (const ShySequence& s)
    {
      this->shy_ = s;
    }

    const Mood::SickSequence& Mood::
    getSick () const
    {
      return this->sick_;
    }

    Mood::SickSequence& Mood::
    getSick ()
    {
      return this->sick_;
    }

    void Mood::
    setSick (const SickSequence& s)
    {
      this->sick_ = s;
    }

    const Mood::SleepySequence& Mood::
    getSleepy () const
    {
      return this->sleepy_;
    }

    Mood::SleepySequence& Mood::
    getSleepy ()
    {
      return this->sleepy_;
    }

    void Mood::
    setSleepy (const SleepySequence& s)
    {
      this->sleepy_ = s;
    }

    const Mood::StressedSequence& Mood::
    getStressed () const
    {
      return this->stressed_;
    }

    Mood::StressedSequence& Mood::
    getStressed ()
    {
      return this->stressed_;
    }

    void Mood::
    setStressed (const StressedSequence& s)
    {
      this->stressed_ = s;
    }

    const Mood::SurprisedSequence& Mood::
    getSurprised () const
    {
      return this->surprised_;
    }

    Mood::SurprisedSequence& Mood::
    getSurprised ()
    {
      return this->surprised_;
    }

    void Mood::
    setSurprised (const SurprisedSequence& s)
    {
      this->surprised_ = s;
    }

    const Mood::ThirstySequence& Mood::
    getThirsty () const
    {
      return this->thirsty_;
    }

    Mood::ThirstySequence& Mood::
    getThirsty ()
    {
      return this->thirsty_;
    }

    void Mood::
    setThirsty (const ThirstySequence& s)
    {
      this->thirsty_ = s;
    }

    const Mood::WorriedSequence& Mood::
    getWorried () const
    {
      return this->worried_;
    }

    Mood::WorriedSequence& Mood::
    getWorried ()
    {
      return this->worried_;
    }

    void Mood::
    setWorried (const WorriedSequence& s)
    {
      this->worried_ = s;
    }

    const Mood::OtherSequence& Mood::
    getOther () const
    {
      return this->other_;
    }

    Mood::OtherSequence& Mood::
    getOther ()
    {
      return this->other_;
    }

    void Mood::
    setOther (const OtherSequence& s)
    {
      this->other_ = s;
    }

    const Mood::AnySequence& Mood::
    getAny () const
    {
      return this->any_;
    }

    Mood::AnySequence& Mood::
    getAny ()
    {
      return this->any_;
    }

    void Mood::
    setAny (const AnySequence& s)
    {
      this->any_ = s;
    }

    const Mood::FromOptional& Mood::
    getFrom () const
    {
      return this->from_;
    }

    Mood::FromOptional& Mood::
    getFrom ()
    {
      return this->from_;
    }

    void Mood::
    setFrom (const FromType& x)
    {
      this->from_.set (x);
    }

    void Mood::
    setFrom (const FromOptional& x)
    {
      this->from_ = x;
    }

    void Mood::
    setFrom (::std::unique_ptr< FromType > x)
    {
      this->from_.set (std::move (x));
    }

    const Mood::UntilOptional& Mood::
    getUntil () const
    {
      return this->until_;
    }

    Mood::UntilOptional& Mood::
    getUntil ()
    {
      return this->until_;
    }

    void Mood::
    setUntil (const UntilType& x)
    {
      this->until_.set (x);
    }

    void Mood::
    setUntil (const UntilOptional& x)
    {
      this->until_ = x;
    }

    void Mood::
    setUntil (::std::unique_ptr< UntilType > x)
    {
      this->until_.set (std::move (x));
    }

    const Mood::IdOptional& Mood::
    getId () const
    {
      return this->id_;
    }

    Mood::IdOptional& Mood::
    getId ()
    {
      return this->id_;
    }

    void Mood::
    setId (const IdType& x)
    {
      this->id_.set (x);
    }

    void Mood::
    setId (const IdOptional& x)
    {
      this->id_ = x;
    }

    void Mood::
    setId (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const Mood::AnyAttributeSet& Mood::
    getAnyAttribute () const
    {
      return this->any_attribute_;
    }

    Mood::AnyAttributeSet& Mood::
    getAnyAttribute ()
    {
      return this->any_attribute_;
    }

    void Mood::
    setAnyAttribute (const AnyAttributeSet& s)
    {
      this->any_attribute_ = s;
    }

    const ::xercesc::DOMDocument& Mood::
    getDomDocument () const
    {
      return *this->dom_document_;
    }

    ::xercesc::DOMDocument& Mood::
    getDomDocument ()
    {
      return *this->dom_document_;
    }


    // PlaceIs
    // 

    const PlaceIs::NoteSequence& PlaceIs::
    getNote () const
    {
      return this->note_;
    }

    PlaceIs::NoteSequence& PlaceIs::
    getNote ()
    {
      return this->note_;
    }

    void PlaceIs::
    setNote (const NoteSequence& s)
    {
      this->note_ = s;
    }

    const PlaceIs::AudioOptional& PlaceIs::
    getAudio () const
    {
      return this->audio_;
    }

    PlaceIs::AudioOptional& PlaceIs::
    getAudio ()
    {
      return this->audio_;
    }

    void PlaceIs::
    setAudio (const AudioType& x)
    {
      this->audio_.set (x);
    }

    void PlaceIs::
    setAudio (const AudioOptional& x)
    {
      this->audio_ = x;
    }

    void PlaceIs::
    setAudio (::std::unique_ptr< AudioType > x)
    {
      this->audio_.set (std::move (x));
    }

    const PlaceIs::VideoOptional& PlaceIs::
    getVideo () const
    {
      return this->video_;
    }

    PlaceIs::VideoOptional& PlaceIs::
    getVideo ()
    {
      return this->video_;
    }

    void PlaceIs::
    setVideo (const VideoType& x)
    {
      this->video_.set (x);
    }

    void PlaceIs::
    setVideo (const VideoOptional& x)
    {
      this->video_ = x;
    }

    void PlaceIs::
    setVideo (::std::unique_ptr< VideoType > x)
    {
      this->video_.set (std::move (x));
    }

    const PlaceIs::TextOptional& PlaceIs::
    getText () const
    {
      return this->text_;
    }

    PlaceIs::TextOptional& PlaceIs::
    getText ()
    {
      return this->text_;
    }

    void PlaceIs::
    setText (const TextType& x)
    {
      this->text_.set (x);
    }

    void PlaceIs::
    setText (const TextOptional& x)
    {
      this->text_ = x;
    }

    void PlaceIs::
    setText (::std::unique_ptr< TextType > x)
    {
      this->text_.set (std::move (x));
    }

    const PlaceIs::FromOptional& PlaceIs::
    getFrom () const
    {
      return this->from_;
    }

    PlaceIs::FromOptional& PlaceIs::
    getFrom ()
    {
      return this->from_;
    }

    void PlaceIs::
    setFrom (const FromType& x)
    {
      this->from_.set (x);
    }

    void PlaceIs::
    setFrom (const FromOptional& x)
    {
      this->from_ = x;
    }

    void PlaceIs::
    setFrom (::std::unique_ptr< FromType > x)
    {
      this->from_.set (std::move (x));
    }

    const PlaceIs::UntilOptional& PlaceIs::
    getUntil () const
    {
      return this->until_;
    }

    PlaceIs::UntilOptional& PlaceIs::
    getUntil ()
    {
      return this->until_;
    }

    void PlaceIs::
    setUntil (const UntilType& x)
    {
      this->until_.set (x);
    }

    void PlaceIs::
    setUntil (const UntilOptional& x)
    {
      this->until_ = x;
    }

    void PlaceIs::
    setUntil (::std::unique_ptr< UntilType > x)
    {
      this->until_.set (std::move (x));
    }

    const PlaceIs::IdOptional& PlaceIs::
    getId () const
    {
      return this->id_;
    }

    PlaceIs::IdOptional& PlaceIs::
    getId ()
    {
      return this->id_;
    }

    void PlaceIs::
    setId (const IdType& x)
    {
      this->id_.set (x);
    }

    void PlaceIs::
    setId (const IdOptional& x)
    {
      this->id_ = x;
    }

    void PlaceIs::
    setId (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const PlaceIs::AnyAttributeSet& PlaceIs::
    getAnyAttribute () const
    {
      return this->any_attribute_;
    }

    PlaceIs::AnyAttributeSet& PlaceIs::
    getAnyAttribute ()
    {
      return this->any_attribute_;
    }

    void PlaceIs::
    setAnyAttribute (const AnyAttributeSet& s)
    {
      this->any_attribute_ = s;
    }

    const ::xercesc::DOMDocument& PlaceIs::
    getDomDocument () const
    {
      return *this->dom_document_;
    }

    ::xercesc::DOMDocument& PlaceIs::
    getDomDocument ()
    {
      return *this->dom_document_;
    }


    // PlaceType
    // 

    const PlaceType::NoteSequence& PlaceType::
    getNote () const
    {
      return this->note_;
    }

    PlaceType::NoteSequence& PlaceType::
    getNote ()
    {
      return this->note_;
    }

    void PlaceType::
    setNote (const NoteSequence& s)
    {
      this->note_ = s;
    }

    const PlaceType::OtherOptional& PlaceType::
    getOther () const
    {
      return this->other_;
    }

    PlaceType::OtherOptional& PlaceType::
    getOther ()
    {
      return this->other_;
    }

    void PlaceType::
    setOther (const OtherType& x)
    {
      this->other_.set (x);
    }

    void PlaceType::
    setOther (const OtherOptional& x)
    {
      this->other_ = x;
    }

    void PlaceType::
    setOther (::std::unique_ptr< OtherType > x)
    {
      this->other_.set (std::move (x));
    }

    const PlaceType::AnySequence& PlaceType::
    getAny () const
    {
      return this->any_;
    }

    PlaceType::AnySequence& PlaceType::
    getAny ()
    {
      return this->any_;
    }

    void PlaceType::
    setAny (const AnySequence& s)
    {
      this->any_ = s;
    }

    const PlaceType::FromOptional& PlaceType::
    getFrom () const
    {
      return this->from_;
    }

    PlaceType::FromOptional& PlaceType::
    getFrom ()
    {
      return this->from_;
    }

    void PlaceType::
    setFrom (const FromType& x)
    {
      this->from_.set (x);
    }

    void PlaceType::
    setFrom (const FromOptional& x)
    {
      this->from_ = x;
    }

    void PlaceType::
    setFrom (::std::unique_ptr< FromType > x)
    {
      this->from_.set (std::move (x));
    }

    const PlaceType::UntilOptional& PlaceType::
    getUntil () const
    {
      return this->until_;
    }

    PlaceType::UntilOptional& PlaceType::
    getUntil ()
    {
      return this->until_;
    }

    void PlaceType::
    setUntil (const UntilType& x)
    {
      this->until_.set (x);
    }

    void PlaceType::
    setUntil (const UntilOptional& x)
    {
      this->until_ = x;
    }

    void PlaceType::
    setUntil (::std::unique_ptr< UntilType > x)
    {
      this->until_.set (std::move (x));
    }

    const PlaceType::IdOptional& PlaceType::
    getId () const
    {
      return this->id_;
    }

    PlaceType::IdOptional& PlaceType::
    getId ()
    {
      return this->id_;
    }

    void PlaceType::
    setId (const IdType& x)
    {
      this->id_.set (x);
    }

    void PlaceType::
    setId (const IdOptional& x)
    {
      this->id_ = x;
    }

    void PlaceType::
    setId (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const PlaceType::AnyAttributeSet& PlaceType::
    getAnyAttribute () const
    {
      return this->any_attribute_;
    }

    PlaceType::AnyAttributeSet& PlaceType::
    getAnyAttribute ()
    {
      return this->any_attribute_;
    }

    void PlaceType::
    setAnyAttribute (const AnyAttributeSet& s)
    {
      this->any_attribute_ = s;
    }

    const ::xercesc::DOMDocument& PlaceType::
    getDomDocument () const
    {
      return *this->dom_document_;
    }

    ::xercesc::DOMDocument& PlaceType::
    getDomDocument ()
    {
      return *this->dom_document_;
    }


    // Privacy
    // 

    const Privacy::NoteSequence& Privacy::
    getNote () const
    {
      return this->note_;
    }

    Privacy::NoteSequence& Privacy::
    getNote ()
    {
      return this->note_;
    }

    void Privacy::
    setNote (const NoteSequence& s)
    {
      this->note_ = s;
    }

    const Privacy::UnknownOptional& Privacy::
    getUnknown () const
    {
      return this->unknown_;
    }

    Privacy::UnknownOptional& Privacy::
    getUnknown ()
    {
      return this->unknown_;
    }

    void Privacy::
    setUnknown (const UnknownType& x)
    {
      this->unknown_.set (x);
    }

    void Privacy::
    setUnknown (const UnknownOptional& x)
    {
      this->unknown_ = x;
    }

    void Privacy::
    setUnknown (::std::unique_ptr< UnknownType > x)
    {
      this->unknown_.set (std::move (x));
    }

    const Privacy::AudioOptional& Privacy::
    getAudio () const
    {
      return this->audio_;
    }

    Privacy::AudioOptional& Privacy::
    getAudio ()
    {
      return this->audio_;
    }

    void Privacy::
    setAudio (const AudioType& x)
    {
      this->audio_.set (x);
    }

    void Privacy::
    setAudio (const AudioOptional& x)
    {
      this->audio_ = x;
    }

    void Privacy::
    setAudio (::std::unique_ptr< AudioType > x)
    {
      this->audio_.set (std::move (x));
    }

    const Privacy::TextOptional& Privacy::
    getText () const
    {
      return this->text_;
    }

    Privacy::TextOptional& Privacy::
    getText ()
    {
      return this->text_;
    }

    void Privacy::
    setText (const TextType& x)
    {
      this->text_.set (x);
    }

    void Privacy::
    setText (const TextOptional& x)
    {
      this->text_ = x;
    }

    void Privacy::
    setText (::std::unique_ptr< TextType > x)
    {
      this->text_.set (std::move (x));
    }

    const Privacy::VideoOptional& Privacy::
    getVideo () const
    {
      return this->video_;
    }

    Privacy::VideoOptional& Privacy::
    getVideo ()
    {
      return this->video_;
    }

    void Privacy::
    setVideo (const VideoType& x)
    {
      this->video_.set (x);
    }

    void Privacy::
    setVideo (const VideoOptional& x)
    {
      this->video_ = x;
    }

    void Privacy::
    setVideo (::std::unique_ptr< VideoType > x)
    {
      this->video_.set (std::move (x));
    }

    const Privacy::AnySequence& Privacy::
    getAny () const
    {
      return this->any_;
    }

    Privacy::AnySequence& Privacy::
    getAny ()
    {
      return this->any_;
    }

    void Privacy::
    setAny (const AnySequence& s)
    {
      this->any_ = s;
    }

    const Privacy::FromOptional& Privacy::
    getFrom () const
    {
      return this->from_;
    }

    Privacy::FromOptional& Privacy::
    getFrom ()
    {
      return this->from_;
    }

    void Privacy::
    setFrom (const FromType& x)
    {
      this->from_.set (x);
    }

    void Privacy::
    setFrom (const FromOptional& x)
    {
      this->from_ = x;
    }

    void Privacy::
    setFrom (::std::unique_ptr< FromType > x)
    {
      this->from_.set (std::move (x));
    }

    const Privacy::UntilOptional& Privacy::
    getUntil () const
    {
      return this->until_;
    }

    Privacy::UntilOptional& Privacy::
    getUntil ()
    {
      return this->until_;
    }

    void Privacy::
    setUntil (const UntilType& x)
    {
      this->until_.set (x);
    }

    void Privacy::
    setUntil (const UntilOptional& x)
    {
      this->until_ = x;
    }

    void Privacy::
    setUntil (::std::unique_ptr< UntilType > x)
    {
      this->until_.set (std::move (x));
    }

    const Privacy::IdOptional& Privacy::
    getId () const
    {
      return this->id_;
    }

    Privacy::IdOptional& Privacy::
    getId ()
    {
      return this->id_;
    }

    void Privacy::
    setId (const IdType& x)
    {
      this->id_.set (x);
    }

    void Privacy::
    setId (const IdOptional& x)
    {
      this->id_ = x;
    }

    void Privacy::
    setId (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const Privacy::AnyAttributeSet& Privacy::
    getAnyAttribute () const
    {
      return this->any_attribute_;
    }

    Privacy::AnyAttributeSet& Privacy::
    getAnyAttribute ()
    {
      return this->any_attribute_;
    }

    void Privacy::
    setAnyAttribute (const AnyAttributeSet& s)
    {
      this->any_attribute_ = s;
    }

    const ::xercesc::DOMDocument& Privacy::
    getDomDocument () const
    {
      return *this->dom_document_;
    }

    ::xercesc::DOMDocument& Privacy::
    getDomDocument ()
    {
      return *this->dom_document_;
    }


    // Relationship
    // 

    const Relationship::NoteSequence& Relationship::
    getNote () const
    {
      return this->note_;
    }

    Relationship::NoteSequence& Relationship::
    getNote ()
    {
      return this->note_;
    }

    void Relationship::
    setNote (const NoteSequence& s)
    {
      this->note_ = s;
    }

    const Relationship::AssistantOptional& Relationship::
    getAssistant () const
    {
      return this->assistant_;
    }

    Relationship::AssistantOptional& Relationship::
    getAssistant ()
    {
      return this->assistant_;
    }

    void Relationship::
    setAssistant (const AssistantType& x)
    {
      this->assistant_.set (x);
    }

    void Relationship::
    setAssistant (const AssistantOptional& x)
    {
      this->assistant_ = x;
    }

    void Relationship::
    setAssistant (::std::unique_ptr< AssistantType > x)
    {
      this->assistant_.set (std::move (x));
    }

    const Relationship::AssociateOptional& Relationship::
    getAssociate () const
    {
      return this->associate_;
    }

    Relationship::AssociateOptional& Relationship::
    getAssociate ()
    {
      return this->associate_;
    }

    void Relationship::
    setAssociate (const AssociateType& x)
    {
      this->associate_.set (x);
    }

    void Relationship::
    setAssociate (const AssociateOptional& x)
    {
      this->associate_ = x;
    }

    void Relationship::
    setAssociate (::std::unique_ptr< AssociateType > x)
    {
      this->associate_.set (std::move (x));
    }

    const Relationship::FamilyOptional& Relationship::
    getFamily () const
    {
      return this->family_;
    }

    Relationship::FamilyOptional& Relationship::
    getFamily ()
    {
      return this->family_;
    }

    void Relationship::
    setFamily (const FamilyType& x)
    {
      this->family_.set (x);
    }

    void Relationship::
    setFamily (const FamilyOptional& x)
    {
      this->family_ = x;
    }

    void Relationship::
    setFamily (::std::unique_ptr< FamilyType > x)
    {
      this->family_.set (std::move (x));
    }

    const Relationship::FriendOptional& Relationship::
    getFriend () const
    {
      return this->friend__;
    }

    Relationship::FriendOptional& Relationship::
    getFriend ()
    {
      return this->friend__;
    }

    void Relationship::
    setFriend (const FriendType& x)
    {
      this->friend__.set (x);
    }

    void Relationship::
    setFriend (const FriendOptional& x)
    {
      this->friend__ = x;
    }

    void Relationship::
    setFriend (::std::unique_ptr< FriendType > x)
    {
      this->friend__.set (std::move (x));
    }

    const Relationship::OtherOptional& Relationship::
    getOther () const
    {
      return this->other_;
    }

    Relationship::OtherOptional& Relationship::
    getOther ()
    {
      return this->other_;
    }

    void Relationship::
    setOther (const OtherType& x)
    {
      this->other_.set (x);
    }

    void Relationship::
    setOther (const OtherOptional& x)
    {
      this->other_ = x;
    }

    void Relationship::
    setOther (::std::unique_ptr< OtherType > x)
    {
      this->other_.set (std::move (x));
    }

    const Relationship::SelfOptional& Relationship::
    getSelf () const
    {
      return this->self_;
    }

    Relationship::SelfOptional& Relationship::
    getSelf ()
    {
      return this->self_;
    }

    void Relationship::
    setSelf (const SelfType& x)
    {
      this->self_.set (x);
    }

    void Relationship::
    setSelf (const SelfOptional& x)
    {
      this->self_ = x;
    }

    void Relationship::
    setSelf (::std::unique_ptr< SelfType > x)
    {
      this->self_.set (std::move (x));
    }

    const Relationship::SupervisorOptional& Relationship::
    getSupervisor () const
    {
      return this->supervisor_;
    }

    Relationship::SupervisorOptional& Relationship::
    getSupervisor ()
    {
      return this->supervisor_;
    }

    void Relationship::
    setSupervisor (const SupervisorType& x)
    {
      this->supervisor_.set (x);
    }

    void Relationship::
    setSupervisor (const SupervisorOptional& x)
    {
      this->supervisor_ = x;
    }

    void Relationship::
    setSupervisor (::std::unique_ptr< SupervisorType > x)
    {
      this->supervisor_.set (std::move (x));
    }

    const Relationship::UnknownOptional& Relationship::
    getUnknown () const
    {
      return this->unknown_;
    }

    Relationship::UnknownOptional& Relationship::
    getUnknown ()
    {
      return this->unknown_;
    }

    void Relationship::
    setUnknown (const UnknownType& x)
    {
      this->unknown_.set (x);
    }

    void Relationship::
    setUnknown (const UnknownOptional& x)
    {
      this->unknown_ = x;
    }

    void Relationship::
    setUnknown (::std::unique_ptr< UnknownType > x)
    {
      this->unknown_.set (std::move (x));
    }

    const Relationship::AnySequence& Relationship::
    getAny () const
    {
      return this->any_;
    }

    Relationship::AnySequence& Relationship::
    getAny ()
    {
      return this->any_;
    }

    void Relationship::
    setAny (const AnySequence& s)
    {
      this->any_ = s;
    }

    const ::xercesc::DOMDocument& Relationship::
    getDomDocument () const
    {
      return *this->dom_document_;
    }

    ::xercesc::DOMDocument& Relationship::
    getDomDocument ()
    {
      return *this->dom_document_;
    }


    // ServiceClass
    // 

    const ServiceClass::NoteSequence& ServiceClass::
    getNote () const
    {
      return this->note_;
    }

    ServiceClass::NoteSequence& ServiceClass::
    getNote ()
    {
      return this->note_;
    }

    void ServiceClass::
    setNote (const NoteSequence& s)
    {
      this->note_ = s;
    }

    const ServiceClass::CourierOptional& ServiceClass::
    getCourier () const
    {
      return this->courier_;
    }

    ServiceClass::CourierOptional& ServiceClass::
    getCourier ()
    {
      return this->courier_;
    }

    void ServiceClass::
    setCourier (const CourierType& x)
    {
      this->courier_.set (x);
    }

    void ServiceClass::
    setCourier (const CourierOptional& x)
    {
      this->courier_ = x;
    }

    void ServiceClass::
    setCourier (::std::unique_ptr< CourierType > x)
    {
      this->courier_.set (std::move (x));
    }

    const ServiceClass::ElectronicOptional& ServiceClass::
    getElectronic () const
    {
      return this->electronic_;
    }

    ServiceClass::ElectronicOptional& ServiceClass::
    getElectronic ()
    {
      return this->electronic_;
    }

    void ServiceClass::
    setElectronic (const ElectronicType& x)
    {
      this->electronic_.set (x);
    }

    void ServiceClass::
    setElectronic (const ElectronicOptional& x)
    {
      this->electronic_ = x;
    }

    void ServiceClass::
    setElectronic (::std::unique_ptr< ElectronicType > x)
    {
      this->electronic_.set (std::move (x));
    }

    const ServiceClass::FreightOptional& ServiceClass::
    getFreight () const
    {
      return this->freight_;
    }

    ServiceClass::FreightOptional& ServiceClass::
    getFreight ()
    {
      return this->freight_;
    }

    void ServiceClass::
    setFreight (const FreightType& x)
    {
      this->freight_.set (x);
    }

    void ServiceClass::
    setFreight (const FreightOptional& x)
    {
      this->freight_ = x;
    }

    void ServiceClass::
    setFreight (::std::unique_ptr< FreightType > x)
    {
      this->freight_.set (std::move (x));
    }

    const ServiceClass::InPersonOptional& ServiceClass::
    getInPerson () const
    {
      return this->in_person_;
    }

    ServiceClass::InPersonOptional& ServiceClass::
    getInPerson ()
    {
      return this->in_person_;
    }

    void ServiceClass::
    setInPerson (const InPersonType& x)
    {
      this->in_person_.set (x);
    }

    void ServiceClass::
    setInPerson (const InPersonOptional& x)
    {
      this->in_person_ = x;
    }

    void ServiceClass::
    setInPerson (::std::unique_ptr< InPersonType > x)
    {
      this->in_person_.set (std::move (x));
    }

    const ServiceClass::PostalOptional& ServiceClass::
    getPostal () const
    {
      return this->postal_;
    }

    ServiceClass::PostalOptional& ServiceClass::
    getPostal ()
    {
      return this->postal_;
    }

    void ServiceClass::
    setPostal (const PostalType& x)
    {
      this->postal_.set (x);
    }

    void ServiceClass::
    setPostal (const PostalOptional& x)
    {
      this->postal_ = x;
    }

    void ServiceClass::
    setPostal (::std::unique_ptr< PostalType > x)
    {
      this->postal_.set (std::move (x));
    }

    const ServiceClass::UnknownOptional& ServiceClass::
    getUnknown () const
    {
      return this->unknown_;
    }

    ServiceClass::UnknownOptional& ServiceClass::
    getUnknown ()
    {
      return this->unknown_;
    }

    void ServiceClass::
    setUnknown (const UnknownType& x)
    {
      this->unknown_.set (x);
    }

    void ServiceClass::
    setUnknown (const UnknownOptional& x)
    {
      this->unknown_ = x;
    }

    void ServiceClass::
    setUnknown (::std::unique_ptr< UnknownType > x)
    {
      this->unknown_.set (std::move (x));
    }

    const ServiceClass::AnySequence& ServiceClass::
    getAny () const
    {
      return this->any_;
    }

    ServiceClass::AnySequence& ServiceClass::
    getAny ()
    {
      return this->any_;
    }

    void ServiceClass::
    setAny (const AnySequence& s)
    {
      this->any_ = s;
    }

    const ::xercesc::DOMDocument& ServiceClass::
    getDomDocument () const
    {
      return *this->dom_document_;
    }

    ::xercesc::DOMDocument& ServiceClass::
    getDomDocument ()
    {
      return *this->dom_document_;
    }


    // Sphere
    // 

    const Sphere::HomeOptional& Sphere::
    getHome () const
    {
      return this->home_;
    }

    Sphere::HomeOptional& Sphere::
    getHome ()
    {
      return this->home_;
    }

    void Sphere::
    setHome (const HomeType& x)
    {
      this->home_.set (x);
    }

    void Sphere::
    setHome (const HomeOptional& x)
    {
      this->home_ = x;
    }

    void Sphere::
    setHome (::std::unique_ptr< HomeType > x)
    {
      this->home_.set (std::move (x));
    }

    const Sphere::WorkOptional& Sphere::
    getWork () const
    {
      return this->work_;
    }

    Sphere::WorkOptional& Sphere::
    getWork ()
    {
      return this->work_;
    }

    void Sphere::
    setWork (const WorkType& x)
    {
      this->work_.set (x);
    }

    void Sphere::
    setWork (const WorkOptional& x)
    {
      this->work_ = x;
    }

    void Sphere::
    setWork (::std::unique_ptr< WorkType > x)
    {
      this->work_.set (std::move (x));
    }

    const Sphere::UnknownOptional& Sphere::
    getUnknown () const
    {
      return this->unknown_;
    }

    Sphere::UnknownOptional& Sphere::
    getUnknown ()
    {
      return this->unknown_;
    }

    void Sphere::
    setUnknown (const UnknownType& x)
    {
      this->unknown_.set (x);
    }

    void Sphere::
    setUnknown (const UnknownOptional& x)
    {
      this->unknown_ = x;
    }

    void Sphere::
    setUnknown (::std::unique_ptr< UnknownType > x)
    {
      this->unknown_.set (std::move (x));
    }

    const Sphere::AnySequence& Sphere::
    getAny () const
    {
      return this->any_;
    }

    Sphere::AnySequence& Sphere::
    getAny ()
    {
      return this->any_;
    }

    void Sphere::
    setAny (const AnySequence& s)
    {
      this->any_ = s;
    }

    const Sphere::FromOptional& Sphere::
    getFrom () const
    {
      return this->from_;
    }

    Sphere::FromOptional& Sphere::
    getFrom ()
    {
      return this->from_;
    }

    void Sphere::
    setFrom (const FromType& x)
    {
      this->from_.set (x);
    }

    void Sphere::
    setFrom (const FromOptional& x)
    {
      this->from_ = x;
    }

    void Sphere::
    setFrom (::std::unique_ptr< FromType > x)
    {
      this->from_.set (std::move (x));
    }

    const Sphere::UntilOptional& Sphere::
    getUntil () const
    {
      return this->until_;
    }

    Sphere::UntilOptional& Sphere::
    getUntil ()
    {
      return this->until_;
    }

    void Sphere::
    setUntil (const UntilType& x)
    {
      this->until_.set (x);
    }

    void Sphere::
    setUntil (const UntilOptional& x)
    {
      this->until_ = x;
    }

    void Sphere::
    setUntil (::std::unique_ptr< UntilType > x)
    {
      this->until_.set (std::move (x));
    }

    const Sphere::IdOptional& Sphere::
    getId () const
    {
      return this->id_;
    }

    Sphere::IdOptional& Sphere::
    getId ()
    {
      return this->id_;
    }

    void Sphere::
    setId (const IdType& x)
    {
      this->id_.set (x);
    }

    void Sphere::
    setId (const IdOptional& x)
    {
      this->id_ = x;
    }

    void Sphere::
    setId (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const Sphere::AnyAttributeSet& Sphere::
    getAnyAttribute () const
    {
      return this->any_attribute_;
    }

    Sphere::AnyAttributeSet& Sphere::
    getAnyAttribute ()
    {
      return this->any_attribute_;
    }

    void Sphere::
    setAnyAttribute (const AnyAttributeSet& s)
    {
      this->any_attribute_ = s;
    }

    const ::xercesc::DOMDocument& Sphere::
    getDomDocument () const
    {
      return *this->dom_document_;
    }

    ::xercesc::DOMDocument& Sphere::
    getDomDocument ()
    {
      return *this->dom_document_;
    }


    // StatusIcon
    // 

    const StatusIcon::FromOptional& StatusIcon::
    getFrom () const
    {
      return this->from_;
    }

    StatusIcon::FromOptional& StatusIcon::
    getFrom ()
    {
      return this->from_;
    }

    void StatusIcon::
    setFrom (const FromType& x)
    {
      this->from_.set (x);
    }

    void StatusIcon::
    setFrom (const FromOptional& x)
    {
      this->from_ = x;
    }

    void StatusIcon::
    setFrom (::std::unique_ptr< FromType > x)
    {
      this->from_.set (std::move (x));
    }

    const StatusIcon::UntilOptional& StatusIcon::
    getUntil () const
    {
      return this->until_;
    }

    StatusIcon::UntilOptional& StatusIcon::
    getUntil ()
    {
      return this->until_;
    }

    void StatusIcon::
    setUntil (const UntilType& x)
    {
      this->until_.set (x);
    }

    void StatusIcon::
    setUntil (const UntilOptional& x)
    {
      this->until_ = x;
    }

    void StatusIcon::
    setUntil (::std::unique_ptr< UntilType > x)
    {
      this->until_.set (std::move (x));
    }

    const StatusIcon::IdOptional& StatusIcon::
    getId () const
    {
      return this->id_;
    }

    StatusIcon::IdOptional& StatusIcon::
    getId ()
    {
      return this->id_;
    }

    void StatusIcon::
    setId (const IdType& x)
    {
      this->id_.set (x);
    }

    void StatusIcon::
    setId (const IdOptional& x)
    {
      this->id_ = x;
    }

    void StatusIcon::
    setId (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const StatusIcon::AnyAttributeSet& StatusIcon::
    getAnyAttribute () const
    {
      return this->any_attribute_;
    }

    StatusIcon::AnyAttributeSet& StatusIcon::
    getAnyAttribute ()
    {
      return this->any_attribute_;
    }

    void StatusIcon::
    setAnyAttribute (const AnyAttributeSet& s)
    {
      this->any_attribute_ = s;
    }

    const ::xercesc::DOMDocument& StatusIcon::
    getDomDocument () const
    {
      return *this->dom_document_;
    }

    ::xercesc::DOMDocument& StatusIcon::
    getDomDocument ()
    {
      return *this->dom_document_;
    }


    // TimeOffset
    // 

    const TimeOffset::FromOptional& TimeOffset::
    getFrom () const
    {
      return this->from_;
    }

    TimeOffset::FromOptional& TimeOffset::
    getFrom ()
    {
      return this->from_;
    }

    void TimeOffset::
    setFrom (const FromType& x)
    {
      this->from_.set (x);
    }

    void TimeOffset::
    setFrom (const FromOptional& x)
    {
      this->from_ = x;
    }

    void TimeOffset::
    setFrom (::std::unique_ptr< FromType > x)
    {
      this->from_.set (std::move (x));
    }

    const TimeOffset::UntilOptional& TimeOffset::
    getUntil () const
    {
      return this->until_;
    }

    TimeOffset::UntilOptional& TimeOffset::
    getUntil ()
    {
      return this->until_;
    }

    void TimeOffset::
    setUntil (const UntilType& x)
    {
      this->until_.set (x);
    }

    void TimeOffset::
    setUntil (const UntilOptional& x)
    {
      this->until_ = x;
    }

    void TimeOffset::
    setUntil (::std::unique_ptr< UntilType > x)
    {
      this->until_.set (std::move (x));
    }

    const TimeOffset::DescriptionOptional& TimeOffset::
    getDescription () const
    {
      return this->description_;
    }

    TimeOffset::DescriptionOptional& TimeOffset::
    getDescription ()
    {
      return this->description_;
    }

    void TimeOffset::
    setDescription (const DescriptionType& x)
    {
      this->description_.set (x);
    }

    void TimeOffset::
    setDescription (const DescriptionOptional& x)
    {
      this->description_ = x;
    }

    void TimeOffset::
    setDescription (::std::unique_ptr< DescriptionType > x)
    {
      this->description_.set (std::move (x));
    }

    const TimeOffset::IdOptional& TimeOffset::
    getId () const
    {
      return this->id_;
    }

    TimeOffset::IdOptional& TimeOffset::
    getId ()
    {
      return this->id_;
    }

    void TimeOffset::
    setId (const IdType& x)
    {
      this->id_.set (x);
    }

    void TimeOffset::
    setId (const IdOptional& x)
    {
      this->id_ = x;
    }

    void TimeOffset::
    setId (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const TimeOffset::AnyAttributeSet& TimeOffset::
    getAnyAttribute () const
    {
      return this->any_attribute_;
    }

    TimeOffset::AnyAttributeSet& TimeOffset::
    getAnyAttribute ()
    {
      return this->any_attribute_;
    }

    void TimeOffset::
    setAnyAttribute (const AnyAttributeSet& s)
    {
      this->any_attribute_ = s;
    }

    const ::xercesc::DOMDocument& TimeOffset::
    getDomDocument () const
    {
      return *this->dom_document_;
    }

    ::xercesc::DOMDocument& TimeOffset::
    getDomDocument ()
    {
      return *this->dom_document_;
    }


    // UserInput
    // 

    const UserInput::IdleThresholdOptional& UserInput::
    getIdleThreshold () const
    {
      return this->idle_threshold_;
    }

    UserInput::IdleThresholdOptional& UserInput::
    getIdleThreshold ()
    {
      return this->idle_threshold_;
    }

    void UserInput::
    setIdleThreshold (const IdleThresholdType& x)
    {
      this->idle_threshold_.set (x);
    }

    void UserInput::
    setIdleThreshold (const IdleThresholdOptional& x)
    {
      this->idle_threshold_ = x;
    }

    const UserInput::LastInputOptional& UserInput::
    getLastInput () const
    {
      return this->last_input_;
    }

    UserInput::LastInputOptional& UserInput::
    getLastInput ()
    {
      return this->last_input_;
    }

    void UserInput::
    setLastInput (const LastInputType& x)
    {
      this->last_input_.set (x);
    }

    void UserInput::
    setLastInput (const LastInputOptional& x)
    {
      this->last_input_ = x;
    }

    void UserInput::
    setLastInput (::std::unique_ptr< LastInputType > x)
    {
      this->last_input_.set (std::move (x));
    }

    const UserInput::IdOptional& UserInput::
    getId () const
    {
      return this->id_;
    }

    UserInput::IdOptional& UserInput::
    getId ()
    {
      return this->id_;
    }

    void UserInput::
    setId (const IdType& x)
    {
      this->id_.set (x);
    }

    void UserInput::
    setId (const IdOptional& x)
    {
      this->id_ = x;
    }

    void UserInput::
    setId (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const UserInput::AnyAttributeSet& UserInput::
    getAnyAttribute () const
    {
      return this->any_attribute_;
    }

    UserInput::AnyAttributeSet& UserInput::
    getAnyAttribute ()
    {
      return this->any_attribute_;
    }

    void UserInput::
    setAnyAttribute (const AnyAttributeSet& s)
    {
      this->any_attribute_ = s;
    }

    const ::xercesc::DOMDocument& UserInput::
    getDomDocument () const
    {
      return *this->dom_document_;
    }

    ::xercesc::DOMDocument& UserInput::
    getDomDocument ()
    {
      return *this->dom_document_;
    }


    // Audio
    // 

    const Audio::NoisyOptional& Audio::
    getNoisy () const
    {
      return this->noisy_;
    }

    Audio::NoisyOptional& Audio::
    getNoisy ()
    {
      return this->noisy_;
    }

    void Audio::
    setNoisy (const NoisyType& x)
    {
      this->noisy_.set (x);
    }

    void Audio::
    setNoisy (const NoisyOptional& x)
    {
      this->noisy_ = x;
    }

    void Audio::
    setNoisy (::std::unique_ptr< NoisyType > x)
    {
      this->noisy_.set (std::move (x));
    }

    const Audio::OkOptional& Audio::
    getOk () const
    {
      return this->ok_;
    }

    Audio::OkOptional& Audio::
    getOk ()
    {
      return this->ok_;
    }

    void Audio::
    setOk (const OkType& x)
    {
      this->ok_.set (x);
    }

    void Audio::
    setOk (const OkOptional& x)
    {
      this->ok_ = x;
    }

    void Audio::
    setOk (::std::unique_ptr< OkType > x)
    {
      this->ok_.set (std::move (x));
    }

    const Audio::QuietOptional& Audio::
    getQuiet () const
    {
      return this->quiet_;
    }

    Audio::QuietOptional& Audio::
    getQuiet ()
    {
      return this->quiet_;
    }

    void Audio::
    setQuiet (const QuietType& x)
    {
      this->quiet_.set (x);
    }

    void Audio::
    setQuiet (const QuietOptional& x)
    {
      this->quiet_ = x;
    }

    void Audio::
    setQuiet (::std::unique_ptr< QuietType > x)
    {
      this->quiet_.set (std::move (x));
    }

    const Audio::UnknownOptional& Audio::
    getUnknown () const
    {
      return this->unknown_;
    }

    Audio::UnknownOptional& Audio::
    getUnknown ()
    {
      return this->unknown_;
    }

    void Audio::
    setUnknown (const UnknownType& x)
    {
      this->unknown_.set (x);
    }

    void Audio::
    setUnknown (const UnknownOptional& x)
    {
      this->unknown_ = x;
    }

    void Audio::
    setUnknown (::std::unique_ptr< UnknownType > x)
    {
      this->unknown_.set (std::move (x));
    }


    // Video
    // 

    const Video::ToobrightOptional& Video::
    getToobright () const
    {
      return this->toobright_;
    }

    Video::ToobrightOptional& Video::
    getToobright ()
    {
      return this->toobright_;
    }

    void Video::
    setToobright (const ToobrightType& x)
    {
      this->toobright_.set (x);
    }

    void Video::
    setToobright (const ToobrightOptional& x)
    {
      this->toobright_ = x;
    }

    void Video::
    setToobright (::std::unique_ptr< ToobrightType > x)
    {
      this->toobright_.set (std::move (x));
    }

    const Video::OkOptional& Video::
    getOk () const
    {
      return this->ok_;
    }

    Video::OkOptional& Video::
    getOk ()
    {
      return this->ok_;
    }

    void Video::
    setOk (const OkType& x)
    {
      this->ok_.set (x);
    }

    void Video::
    setOk (const OkOptional& x)
    {
      this->ok_ = x;
    }

    void Video::
    setOk (::std::unique_ptr< OkType > x)
    {
      this->ok_.set (std::move (x));
    }

    const Video::DarkOptional& Video::
    getDark () const
    {
      return this->dark_;
    }

    Video::DarkOptional& Video::
    getDark ()
    {
      return this->dark_;
    }

    void Video::
    setDark (const DarkType& x)
    {
      this->dark_.set (x);
    }

    void Video::
    setDark (const DarkOptional& x)
    {
      this->dark_ = x;
    }

    void Video::
    setDark (::std::unique_ptr< DarkType > x)
    {
      this->dark_.set (std::move (x));
    }

    const Video::UnknownOptional& Video::
    getUnknown () const
    {
      return this->unknown_;
    }

    Video::UnknownOptional& Video::
    getUnknown ()
    {
      return this->unknown_;
    }

    void Video::
    setUnknown (const UnknownType& x)
    {
      this->unknown_.set (x);
    }

    void Video::
    setUnknown (const UnknownOptional& x)
    {
      this->unknown_ = x;
    }

    void Video::
    setUnknown (::std::unique_ptr< UnknownType > x)
    {
      this->unknown_.set (std::move (x));
    }


    // Text
    // 

    const Text::UncomfortableOptional& Text::
    getUncomfortable () const
    {
      return this->uncomfortable_;
    }

    Text::UncomfortableOptional& Text::
    getUncomfortable ()
    {
      return this->uncomfortable_;
    }

    void Text::
    setUncomfortable (const UncomfortableType& x)
    {
      this->uncomfortable_.set (x);
    }

    void Text::
    setUncomfortable (const UncomfortableOptional& x)
    {
      this->uncomfortable_ = x;
    }

    void Text::
    setUncomfortable (::std::unique_ptr< UncomfortableType > x)
    {
      this->uncomfortable_.set (std::move (x));
    }

    const Text::InappropriateOptional& Text::
    getInappropriate () const
    {
      return this->inappropriate_;
    }

    Text::InappropriateOptional& Text::
    getInappropriate ()
    {
      return this->inappropriate_;
    }

    void Text::
    setInappropriate (const InappropriateType& x)
    {
      this->inappropriate_.set (x);
    }

    void Text::
    setInappropriate (const InappropriateOptional& x)
    {
      this->inappropriate_ = x;
    }

    void Text::
    setInappropriate (::std::unique_ptr< InappropriateType > x)
    {
      this->inappropriate_.set (std::move (x));
    }

    const Text::OkOptional& Text::
    getOk () const
    {
      return this->ok_;
    }

    Text::OkOptional& Text::
    getOk ()
    {
      return this->ok_;
    }

    void Text::
    setOk (const OkType& x)
    {
      this->ok_.set (x);
    }

    void Text::
    setOk (const OkOptional& x)
    {
      this->ok_ = x;
    }

    void Text::
    setOk (::std::unique_ptr< OkType > x)
    {
      this->ok_.set (std::move (x));
    }

    const Text::UnknownOptional& Text::
    getUnknown () const
    {
      return this->unknown_;
    }

    Text::UnknownOptional& Text::
    getUnknown ()
    {
      return this->unknown_;
    }

    void Text::
    setUnknown (const UnknownType& x)
    {
      this->unknown_.set (x);
    }

    void Text::
    setUnknown (const UnknownOptional& x)
    {
      this->unknown_ = x;
    }

    void Text::
    setUnknown (::std::unique_ptr< UnknownType > x)
    {
      this->unknown_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/wildcard-source.hxx>

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace Xsd
{
  namespace Rpid
  {
    // Timestamp_t
    //

    Timestamp_t::
    Timestamp_t (const ::Xsd::XmlSchema::DateTime& _xsd_DateTime_base)
    : ::Xsd::XmlSchema::DateTime (_xsd_DateTime_base)
    {
    }

    Timestamp_t::
    Timestamp_t (const Timestamp_t& x,
                 ::Xsd::XmlSchema::Flags f,
                 ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::DateTime (x, f, c)
    {
    }

    Timestamp_t::
    Timestamp_t (const ::xercesc::DOMElement& e,
                 ::Xsd::XmlSchema::Flags f,
                 ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::DateTime (e, f, c)
    {
    }

    Timestamp_t::
    Timestamp_t (const ::xercesc::DOMAttr& a,
                 ::Xsd::XmlSchema::Flags f,
                 ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::DateTime (a, f, c)
    {
    }

    Timestamp_t::
    Timestamp_t (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::Xsd::XmlSchema::Flags f,
                 ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::DateTime (s, e, f, c)
    {
    }

    Timestamp_t* Timestamp_t::
    _clone (::Xsd::XmlSchema::Flags f,
            ::Xsd::XmlSchema::Container* c) const
    {
      return new class Timestamp_t (*this, f, c);
    }

    Timestamp_t::
    ~Timestamp_t ()
    {
    }

    // DeviceID_t
    //

    DeviceID_t::
    DeviceID_t (const ::Xsd::XmlSchema::Uri& _xsd_Uri_base)
    : ::Xsd::XmlSchema::Uri (_xsd_Uri_base)
    {
    }

    DeviceID_t::
    DeviceID_t (const DeviceID_t& x,
                ::Xsd::XmlSchema::Flags f,
                ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Uri (x, f, c)
    {
    }

    DeviceID_t::
    DeviceID_t (const ::xercesc::DOMElement& e,
                ::Xsd::XmlSchema::Flags f,
                ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Uri (e, f, c)
    {
    }

    DeviceID_t::
    DeviceID_t (const ::xercesc::DOMAttr& a,
                ::Xsd::XmlSchema::Flags f,
                ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Uri (a, f, c)
    {
    }

    DeviceID_t::
    DeviceID_t (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::Xsd::XmlSchema::Flags f,
                ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Uri (s, e, f, c)
    {
    }

    DeviceID_t* DeviceID_t::
    _clone (::Xsd::XmlSchema::Flags f,
            ::Xsd::XmlSchema::Container* c) const
    {
      return new class DeviceID_t (*this, f, c);
    }

    DeviceID_t::
    ~DeviceID_t ()
    {
    }

    // Note_t
    //

    Note_t::
    Note_t ()
    : ::Xsd::XmlSchema::String (),
      lang_ (this)
    {
    }

    Note_t::
    Note_t (const char* _xsd_String_base)
    : ::Xsd::XmlSchema::String (_xsd_String_base),
      lang_ (this)
    {
    }

    Note_t::
    Note_t (const ::std::string& _xsd_String_base)
    : ::Xsd::XmlSchema::String (_xsd_String_base),
      lang_ (this)
    {
    }

    Note_t::
    Note_t (const ::Xsd::XmlSchema::String& _xsd_String_base)
    : ::Xsd::XmlSchema::String (_xsd_String_base),
      lang_ (this)
    {
    }

    Note_t::
    Note_t (const Note_t& x,
            ::Xsd::XmlSchema::Flags f,
            ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::String (x, f, c),
      lang_ (x.lang_, f, this)
    {
    }

    Note_t::
    Note_t (const ::xercesc::DOMElement& e,
            ::Xsd::XmlSchema::Flags f,
            ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::String (e, f | ::Xsd::XmlSchema::Flags::base, c),
      lang_ (this)
    {
      if ((f & ::Xsd::XmlSchema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Note_t::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::Xsd::XmlSchema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "lang" && n.namespace_ () == "http://www.w3.org/XML/1998/namespace")
        {
          this->lang_.set (LangTraits::create (i, f, this));
          continue;
        }
      }
    }

    Note_t* Note_t::
    _clone (::Xsd::XmlSchema::Flags f,
            ::Xsd::XmlSchema::Container* c) const
    {
      return new class Note_t (*this, f, c);
    }

    Note_t& Note_t::
    operator= (const Note_t& x)
    {
      if (this != &x)
      {
        static_cast< ::Xsd::XmlSchema::String& > (*this) = x;
        this->lang_ = x.lang_;
      }

      return *this;
    }

    Note_t::
    ~Note_t ()
    {
    }

    // Empty
    //

    Empty::
    Empty ()
    : ::Xsd::XmlSchema::Type ()
    {
    }

    Empty::
    Empty (const Empty& x,
           ::Xsd::XmlSchema::Flags f,
           ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (x, f, c)
    {
    }

    Empty::
    Empty (const ::xercesc::DOMElement& e,
           ::Xsd::XmlSchema::Flags f,
           ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (e, f, c)
    {
    }

    Empty::
    Empty (const ::xercesc::DOMAttr& a,
           ::Xsd::XmlSchema::Flags f,
           ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (a, f, c)
    {
    }

    Empty::
    Empty (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::Xsd::XmlSchema::Flags f,
           ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (s, e, f, c)
    {
    }

    Empty* Empty::
    _clone (::Xsd::XmlSchema::Flags f,
            ::Xsd::XmlSchema::Container* c) const
    {
      return new class Empty (*this, f, c);
    }

    Empty::
    ~Empty ()
    {
    }
  }
}

namespace Xsd
{
  namespace Rpid
  {
    // ActiveIdle
    //

    ActiveIdle::
    ActiveIdle (const ::xercesc::DOMElement& e,
                ::Xsd::XmlSchema::Flags f,
                ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::String (e, f, c)
    {
      _xsd_ActiveIdle_convert ();
    }

    ActiveIdle::
    ActiveIdle (const ::xercesc::DOMAttr& a,
                ::Xsd::XmlSchema::Flags f,
                ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::String (a, f, c)
    {
      _xsd_ActiveIdle_convert ();
    }

    ActiveIdle::
    ActiveIdle (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::Xsd::XmlSchema::Flags f,
                ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::String (s, e, f, c)
    {
      _xsd_ActiveIdle_convert ();
    }

    ActiveIdle* ActiveIdle::
    _clone (::Xsd::XmlSchema::Flags f,
            ::Xsd::XmlSchema::Container* c) const
    {
      return new class ActiveIdle (*this, f, c);
    }

    ActiveIdle::Value ActiveIdle::
    _xsd_ActiveIdle_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ActiveIdle_literals_);
      const Value* i (::std::lower_bound (
                        _xsd_ActiveIdle_indexes_,
                        _xsd_ActiveIdle_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_ActiveIdle_indexes_ + 2 || _xsd_ActiveIdle_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const ActiveIdle::
    _xsd_ActiveIdle_literals_[2] =
    {
      "active",
      "idle"
    };

    const ActiveIdle::Value ActiveIdle::
    _xsd_ActiveIdle_indexes_[2] =
    {
      ::Xsd::Rpid::ActiveIdle::active,
      ::Xsd::Rpid::ActiveIdle::idle
    };

    // Activities
    //

    Activities::
    Activities ()
    : ::Xsd::XmlSchema::Type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      note_ (this),
      unknown_ (this),
      appointment_ (this),
      away_ (this),
      breakfast_ (this),
      busy_ (this),
      dinner_ (this),
      holiday_ (this),
      in_transit_ (this),
      looking_for_work_ (this),
      meal_ (this),
      meeting_ (this),
      on_the_phone_ (this),
      performance_ (this),
      permanent_absence_ (this),
      playing_ (this),
      presentation_ (this),
      shopping_ (this),
      sleeping_ (this),
      spectator_ (this),
      steering_ (this),
      travel_ (this),
      tv_ (this),
      vacation_ (this),
      working_ (this),
      worship_ (this),
      other_ (this),
      any_ (this->getDomDocument ()),
      from_ (this),
      until_ (this),
      id_ (this),
      any_attribute_ (this->getDomDocument ())
    {
    }

    Activities::
    Activities (const Activities& x,
                ::Xsd::XmlSchema::Flags f,
                ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      note_ (x.note_, f, this),
      unknown_ (x.unknown_, f, this),
      appointment_ (x.appointment_, f, this),
      away_ (x.away_, f, this),
      breakfast_ (x.breakfast_, f, this),
      busy_ (x.busy_, f, this),
      dinner_ (x.dinner_, f, this),
      holiday_ (x.holiday_, f, this),
      in_transit_ (x.in_transit_, f, this),
      looking_for_work_ (x.looking_for_work_, f, this),
      meal_ (x.meal_, f, this),
      meeting_ (x.meeting_, f, this),
      on_the_phone_ (x.on_the_phone_, f, this),
      performance_ (x.performance_, f, this),
      permanent_absence_ (x.permanent_absence_, f, this),
      playing_ (x.playing_, f, this),
      presentation_ (x.presentation_, f, this),
      shopping_ (x.shopping_, f, this),
      sleeping_ (x.sleeping_, f, this),
      spectator_ (x.spectator_, f, this),
      steering_ (x.steering_, f, this),
      travel_ (x.travel_, f, this),
      tv_ (x.tv_, f, this),
      vacation_ (x.vacation_, f, this),
      working_ (x.working_, f, this),
      worship_ (x.worship_, f, this),
      other_ (x.other_, f, this),
      any_ (x.any_, this->getDomDocument ()),
      from_ (x.from_, f, this),
      until_ (x.until_, f, this),
      id_ (x.id_, f, this),
      any_attribute_ (x.any_attribute_, this->getDomDocument ())
    {
    }

    Activities::
    Activities (const ::xercesc::DOMElement& e,
                ::Xsd::XmlSchema::Flags f,
                ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (e, f | ::Xsd::XmlSchema::Flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      note_ (this),
      unknown_ (this),
      appointment_ (this),
      away_ (this),
      breakfast_ (this),
      busy_ (this),
      dinner_ (this),
      holiday_ (this),
      in_transit_ (this),
      looking_for_work_ (this),
      meal_ (this),
      meeting_ (this),
      on_the_phone_ (this),
      performance_ (this),
      permanent_absence_ (this),
      playing_ (this),
      presentation_ (this),
      shopping_ (this),
      sleeping_ (this),
      spectator_ (this),
      steering_ (this),
      travel_ (this),
      tv_ (this),
      vacation_ (this),
      working_ (this),
      worship_ (this),
      other_ (this),
      any_ (this->getDomDocument ()),
      from_ (this),
      until_ (this),
      id_ (this),
      any_attribute_ (this->getDomDocument ())
    {
      if ((f & ::Xsd::XmlSchema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Activities::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::Xsd::XmlSchema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // note
        //
        if (n.name () == "note" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< NoteType > r (
            NoteTraits::create (i, f, this));

          this->note_.push_back (::std::move (r));
          continue;
        }

        // unknown
        //
        if (n.name () == "unknown" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< UnknownType > r (
            UnknownTraits::create (i, f, this));

          if (!this->unknown_)
          {
            this->unknown_.set (::std::move (r));
            continue;
          }
        }

        // appointment
        //
        if (n.name () == "appointment" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< AppointmentType > r (
            AppointmentTraits::create (i, f, this));

          this->appointment_.push_back (::std::move (r));
          continue;
        }

        // away
        //
        if (n.name () == "away" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< AwayType > r (
            AwayTraits::create (i, f, this));

          this->away_.push_back (::std::move (r));
          continue;
        }

        // breakfast
        //
        if (n.name () == "breakfast" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< BreakfastType > r (
            BreakfastTraits::create (i, f, this));

          this->breakfast_.push_back (::std::move (r));
          continue;
        }

        // busy
        //
        if (n.name () == "busy" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< BusyType > r (
            BusyTraits::create (i, f, this));

          this->busy_.push_back (::std::move (r));
          continue;
        }

        // dinner
        //
        if (n.name () == "dinner" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< DinnerType > r (
            DinnerTraits::create (i, f, this));

          this->dinner_.push_back (::std::move (r));
          continue;
        }

        // holiday
        //
        if (n.name () == "holiday" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< HolidayType > r (
            HolidayTraits::create (i, f, this));

          this->holiday_.push_back (::std::move (r));
          continue;
        }

        // in-transit
        //
        if (n.name () == "in-transit" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< InTransitType > r (
            InTransitTraits::create (i, f, this));

          this->in_transit_.push_back (::std::move (r));
          continue;
        }

        // looking-for-work
        //
        if (n.name () == "looking-for-work" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< LookingForWorkType > r (
            LookingForWorkTraits::create (i, f, this));

          this->looking_for_work_.push_back (::std::move (r));
          continue;
        }

        // meal
        //
        if (n.name () == "meal" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< MealType > r (
            MealTraits::create (i, f, this));

          this->meal_.push_back (::std::move (r));
          continue;
        }

        // meeting
        //
        if (n.name () == "meeting" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< MeetingType > r (
            MeetingTraits::create (i, f, this));

          this->meeting_.push_back (::std::move (r));
          continue;
        }

        // on-the-phone
        //
        if (n.name () == "on-the-phone" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< OnThePhoneType > r (
            OnThePhoneTraits::create (i, f, this));

          this->on_the_phone_.push_back (::std::move (r));
          continue;
        }

        // performance
        //
        if (n.name () == "performance" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< PerformanceType > r (
            PerformanceTraits::create (i, f, this));

          this->performance_.push_back (::std::move (r));
          continue;
        }

        // permanent-absence
        //
        if (n.name () == "permanent-absence" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< PermanentAbsenceType > r (
            PermanentAbsenceTraits::create (i, f, this));

          this->permanent_absence_.push_back (::std::move (r));
          continue;
        }

        // playing
        //
        if (n.name () == "playing" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< PlayingType > r (
            PlayingTraits::create (i, f, this));

          this->playing_.push_back (::std::move (r));
          continue;
        }

        // presentation
        //
        if (n.name () == "presentation" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< PresentationType > r (
            PresentationTraits::create (i, f, this));

          this->presentation_.push_back (::std::move (r));
          continue;
        }

        // shopping
        //
        if (n.name () == "shopping" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ShoppingType > r (
            ShoppingTraits::create (i, f, this));

          this->shopping_.push_back (::std::move (r));
          continue;
        }

        // sleeping
        //
        if (n.name () == "sleeping" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< SleepingType > r (
            SleepingTraits::create (i, f, this));

          this->sleeping_.push_back (::std::move (r));
          continue;
        }

        // spectator
        //
        if (n.name () == "spectator" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< SpectatorType > r (
            SpectatorTraits::create (i, f, this));

          this->spectator_.push_back (::std::move (r));
          continue;
        }

        // steering
        //
        if (n.name () == "steering" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< SteeringType > r (
            SteeringTraits::create (i, f, this));

          this->steering_.push_back (::std::move (r));
          continue;
        }

        // travel
        //
        if (n.name () == "travel" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< TravelType > r (
            TravelTraits::create (i, f, this));

          this->travel_.push_back (::std::move (r));
          continue;
        }

        // tv
        //
        if (n.name () == "tv" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< TvType > r (
            TvTraits::create (i, f, this));

          this->tv_.push_back (::std::move (r));
          continue;
        }

        // vacation
        //
        if (n.name () == "vacation" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< VacationType > r (
            VacationTraits::create (i, f, this));

          this->vacation_.push_back (::std::move (r));
          continue;
        }

        // working
        //
        if (n.name () == "working" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< WorkingType > r (
            WorkingTraits::create (i, f, this));

          this->working_.push_back (::std::move (r));
          continue;
        }

        // worship
        //
        if (n.name () == "worship" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< WorshipType > r (
            WorshipTraits::create (i, f, this));

          this->worship_.push_back (::std::move (r));
          continue;
        }

        // other
        //
        if (n.name () == "other" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< OtherType > r (
            OtherTraits::create (i, f, this));

          this->other_.push_back (::std::move (r));
          continue;
        }

        // any
        //
        if ((!n.namespace_ ().empty () && n.namespace_ () != "urn:ietf:params:xml:ns:pidf:rpid"))
        {
          ::xercesc::DOMElement* r (
            static_cast< ::xercesc::DOMElement* > (
              this->getDomDocument ().importNode (
                const_cast< ::xercesc::DOMElement* > (&i), true)));
          this->any_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "from" && n.namespace_ ().empty ())
        {
          this->from_.set (FromTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "until" && n.namespace_ ().empty ())
        {
          this->until_.set (UntilTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (IdTraits::create (i, f, this));
          continue;
        }

        // any_attribute
        //
        if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->getDomDocument ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute_ .insert (r);
          continue;
        }
      }
    }

    Activities* Activities::
    _clone (::Xsd::XmlSchema::Flags f,
            ::Xsd::XmlSchema::Container* c) const
    {
      return new class Activities (*this, f, c);
    }

    Activities& Activities::
    operator= (const Activities& x)
    {
      if (this != &x)
      {
        static_cast< ::Xsd::XmlSchema::Type& > (*this) = x;
        this->note_ = x.note_;
        this->unknown_ = x.unknown_;
        this->appointment_ = x.appointment_;
        this->away_ = x.away_;
        this->breakfast_ = x.breakfast_;
        this->busy_ = x.busy_;
        this->dinner_ = x.dinner_;
        this->holiday_ = x.holiday_;
        this->in_transit_ = x.in_transit_;
        this->looking_for_work_ = x.looking_for_work_;
        this->meal_ = x.meal_;
        this->meeting_ = x.meeting_;
        this->on_the_phone_ = x.on_the_phone_;
        this->performance_ = x.performance_;
        this->permanent_absence_ = x.permanent_absence_;
        this->playing_ = x.playing_;
        this->presentation_ = x.presentation_;
        this->shopping_ = x.shopping_;
        this->sleeping_ = x.sleeping_;
        this->spectator_ = x.spectator_;
        this->steering_ = x.steering_;
        this->travel_ = x.travel_;
        this->tv_ = x.tv_;
        this->vacation_ = x.vacation_;
        this->working_ = x.working_;
        this->worship_ = x.worship_;
        this->other_ = x.other_;
        this->any_ = x.any_;
        this->from_ = x.from_;
        this->until_ = x.until_;
        this->id_ = x.id_;
        this->any_attribute_ = x.any_attribute_;
      }

      return *this;
    }

    Activities::
    ~Activities ()
    {
    }

    // Mood
    //

    Mood::
    Mood ()
    : ::Xsd::XmlSchema::Type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      note_ (this),
      unknown_ (this),
      afraid_ (this),
      amazed_ (this),
      angry_ (this),
      annoyed_ (this),
      anxious_ (this),
      ashamed_ (this),
      bored_ (this),
      brave_ (this),
      calm_ (this),
      cold_ (this),
      confused_ (this),
      contented_ (this),
      cranky_ (this),
      curious_ (this),
      depressed_ (this),
      disappointed_ (this),
      disgusted_ (this),
      distracted_ (this),
      embarrassed_ (this),
      excited_ (this),
      flirtatious_ (this),
      frustrated_ (this),
      grumpy_ (this),
      guilty_ (this),
      happy_ (this),
      hot_ (this),
      humbled_ (this),
      humiliated_ (this),
      hungry_ (this),
      hurt_ (this),
      impressed_ (this),
      in_awe_ (this),
      in_love_ (this),
      indignant_ (this),
      interested_ (this),
      invincible_ (this),
      jealous_ (this),
      lonely_ (this),
      mean_ (this),
      moody_ (this),
      nervous_ (this),
      neutral_ (this),
      offended_ (this),
      playful_ (this),
      proud_ (this),
      relieved_ (this),
      remorseful_ (this),
      restless_ (this),
      sad_ (this),
      sarcastic_ (this),
      serious_ (this),
      shocked_ (this),
      shy_ (this),
      sick_ (this),
      sleepy_ (this),
      stressed_ (this),
      surprised_ (this),
      thirsty_ (this),
      worried_ (this),
      other_ (this),
      any_ (this->getDomDocument ()),
      from_ (this),
      until_ (this),
      id_ (this),
      any_attribute_ (this->getDomDocument ())
    {
    }

    Mood::
    Mood (const Mood& x,
          ::Xsd::XmlSchema::Flags f,
          ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      note_ (x.note_, f, this),
      unknown_ (x.unknown_, f, this),
      afraid_ (x.afraid_, f, this),
      amazed_ (x.amazed_, f, this),
      angry_ (x.angry_, f, this),
      annoyed_ (x.annoyed_, f, this),
      anxious_ (x.anxious_, f, this),
      ashamed_ (x.ashamed_, f, this),
      bored_ (x.bored_, f, this),
      brave_ (x.brave_, f, this),
      calm_ (x.calm_, f, this),
      cold_ (x.cold_, f, this),
      confused_ (x.confused_, f, this),
      contented_ (x.contented_, f, this),
      cranky_ (x.cranky_, f, this),
      curious_ (x.curious_, f, this),
      depressed_ (x.depressed_, f, this),
      disappointed_ (x.disappointed_, f, this),
      disgusted_ (x.disgusted_, f, this),
      distracted_ (x.distracted_, f, this),
      embarrassed_ (x.embarrassed_, f, this),
      excited_ (x.excited_, f, this),
      flirtatious_ (x.flirtatious_, f, this),
      frustrated_ (x.frustrated_, f, this),
      grumpy_ (x.grumpy_, f, this),
      guilty_ (x.guilty_, f, this),
      happy_ (x.happy_, f, this),
      hot_ (x.hot_, f, this),
      humbled_ (x.humbled_, f, this),
      humiliated_ (x.humiliated_, f, this),
      hungry_ (x.hungry_, f, this),
      hurt_ (x.hurt_, f, this),
      impressed_ (x.impressed_, f, this),
      in_awe_ (x.in_awe_, f, this),
      in_love_ (x.in_love_, f, this),
      indignant_ (x.indignant_, f, this),
      interested_ (x.interested_, f, this),
      invincible_ (x.invincible_, f, this),
      jealous_ (x.jealous_, f, this),
      lonely_ (x.lonely_, f, this),
      mean_ (x.mean_, f, this),
      moody_ (x.moody_, f, this),
      nervous_ (x.nervous_, f, this),
      neutral_ (x.neutral_, f, this),
      offended_ (x.offended_, f, this),
      playful_ (x.playful_, f, this),
      proud_ (x.proud_, f, this),
      relieved_ (x.relieved_, f, this),
      remorseful_ (x.remorseful_, f, this),
      restless_ (x.restless_, f, this),
      sad_ (x.sad_, f, this),
      sarcastic_ (x.sarcastic_, f, this),
      serious_ (x.serious_, f, this),
      shocked_ (x.shocked_, f, this),
      shy_ (x.shy_, f, this),
      sick_ (x.sick_, f, this),
      sleepy_ (x.sleepy_, f, this),
      stressed_ (x.stressed_, f, this),
      surprised_ (x.surprised_, f, this),
      thirsty_ (x.thirsty_, f, this),
      worried_ (x.worried_, f, this),
      other_ (x.other_, f, this),
      any_ (x.any_, this->getDomDocument ()),
      from_ (x.from_, f, this),
      until_ (x.until_, f, this),
      id_ (x.id_, f, this),
      any_attribute_ (x.any_attribute_, this->getDomDocument ())
    {
    }

    Mood::
    Mood (const ::xercesc::DOMElement& e,
          ::Xsd::XmlSchema::Flags f,
          ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (e, f | ::Xsd::XmlSchema::Flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      note_ (this),
      unknown_ (this),
      afraid_ (this),
      amazed_ (this),
      angry_ (this),
      annoyed_ (this),
      anxious_ (this),
      ashamed_ (this),
      bored_ (this),
      brave_ (this),
      calm_ (this),
      cold_ (this),
      confused_ (this),
      contented_ (this),
      cranky_ (this),
      curious_ (this),
      depressed_ (this),
      disappointed_ (this),
      disgusted_ (this),
      distracted_ (this),
      embarrassed_ (this),
      excited_ (this),
      flirtatious_ (this),
      frustrated_ (this),
      grumpy_ (this),
      guilty_ (this),
      happy_ (this),
      hot_ (this),
      humbled_ (this),
      humiliated_ (this),
      hungry_ (this),
      hurt_ (this),
      impressed_ (this),
      in_awe_ (this),
      in_love_ (this),
      indignant_ (this),
      interested_ (this),
      invincible_ (this),
      jealous_ (this),
      lonely_ (this),
      mean_ (this),
      moody_ (this),
      nervous_ (this),
      neutral_ (this),
      offended_ (this),
      playful_ (this),
      proud_ (this),
      relieved_ (this),
      remorseful_ (this),
      restless_ (this),
      sad_ (this),
      sarcastic_ (this),
      serious_ (this),
      shocked_ (this),
      shy_ (this),
      sick_ (this),
      sleepy_ (this),
      stressed_ (this),
      surprised_ (this),
      thirsty_ (this),
      worried_ (this),
      other_ (this),
      any_ (this->getDomDocument ()),
      from_ (this),
      until_ (this),
      id_ (this),
      any_attribute_ (this->getDomDocument ())
    {
      if ((f & ::Xsd::XmlSchema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Mood::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::Xsd::XmlSchema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // note
        //
        if (n.name () == "note" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< NoteType > r (
            NoteTraits::create (i, f, this));

          this->note_.push_back (::std::move (r));
          continue;
        }

        // unknown
        //
        if (n.name () == "unknown" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< UnknownType > r (
            UnknownTraits::create (i, f, this));

          if (!this->unknown_)
          {
            this->unknown_.set (::std::move (r));
            continue;
          }
        }

        // afraid
        //
        if (n.name () == "afraid" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< AfraidType > r (
            AfraidTraits::create (i, f, this));

          this->afraid_.push_back (::std::move (r));
          continue;
        }

        // amazed
        //
        if (n.name () == "amazed" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< AmazedType > r (
            AmazedTraits::create (i, f, this));

          this->amazed_.push_back (::std::move (r));
          continue;
        }

        // angry
        //
        if (n.name () == "angry" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< AngryType > r (
            AngryTraits::create (i, f, this));

          this->angry_.push_back (::std::move (r));
          continue;
        }

        // annoyed
        //
        if (n.name () == "annoyed" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< AnnoyedType > r (
            AnnoyedTraits::create (i, f, this));

          this->annoyed_.push_back (::std::move (r));
          continue;
        }

        // anxious
        //
        if (n.name () == "anxious" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< AnxiousType > r (
            AnxiousTraits::create (i, f, this));

          this->anxious_.push_back (::std::move (r));
          continue;
        }

        // ashamed
        //
        if (n.name () == "ashamed" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< AshamedType > r (
            AshamedTraits::create (i, f, this));

          this->ashamed_.push_back (::std::move (r));
          continue;
        }

        // bored
        //
        if (n.name () == "bored" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< BoredType > r (
            BoredTraits::create (i, f, this));

          this->bored_.push_back (::std::move (r));
          continue;
        }

        // brave
        //
        if (n.name () == "brave" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< BraveType > r (
            BraveTraits::create (i, f, this));

          this->brave_.push_back (::std::move (r));
          continue;
        }

        // calm
        //
        if (n.name () == "calm" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< CalmType > r (
            CalmTraits::create (i, f, this));

          this->calm_.push_back (::std::move (r));
          continue;
        }

        // cold
        //
        if (n.name () == "cold" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ColdType > r (
            ColdTraits::create (i, f, this));

          this->cold_.push_back (::std::move (r));
          continue;
        }

        // confused
        //
        if (n.name () == "confused" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ConfusedType > r (
            ConfusedTraits::create (i, f, this));

          this->confused_.push_back (::std::move (r));
          continue;
        }

        // contented
        //
        if (n.name () == "contented" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ContentedType > r (
            ContentedTraits::create (i, f, this));

          this->contented_.push_back (::std::move (r));
          continue;
        }

        // cranky
        //
        if (n.name () == "cranky" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< CrankyType > r (
            CrankyTraits::create (i, f, this));

          this->cranky_.push_back (::std::move (r));
          continue;
        }

        // curious
        //
        if (n.name () == "curious" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< CuriousType > r (
            CuriousTraits::create (i, f, this));

          this->curious_.push_back (::std::move (r));
          continue;
        }

        // depressed
        //
        if (n.name () == "depressed" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< DepressedType > r (
            DepressedTraits::create (i, f, this));

          this->depressed_.push_back (::std::move (r));
          continue;
        }

        // disappointed
        //
        if (n.name () == "disappointed" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< DisappointedType > r (
            DisappointedTraits::create (i, f, this));

          this->disappointed_.push_back (::std::move (r));
          continue;
        }

        // disgusted
        //
        if (n.name () == "disgusted" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< DisgustedType > r (
            DisgustedTraits::create (i, f, this));

          this->disgusted_.push_back (::std::move (r));
          continue;
        }

        // distracted
        //
        if (n.name () == "distracted" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< DistractedType > r (
            DistractedTraits::create (i, f, this));

          this->distracted_.push_back (::std::move (r));
          continue;
        }

        // embarrassed
        //
        if (n.name () == "embarrassed" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< EmbarrassedType > r (
            EmbarrassedTraits::create (i, f, this));

          this->embarrassed_.push_back (::std::move (r));
          continue;
        }

        // excited
        //
        if (n.name () == "excited" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ExcitedType > r (
            ExcitedTraits::create (i, f, this));

          this->excited_.push_back (::std::move (r));
          continue;
        }

        // flirtatious
        //
        if (n.name () == "flirtatious" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< FlirtatiousType > r (
            FlirtatiousTraits::create (i, f, this));

          this->flirtatious_.push_back (::std::move (r));
          continue;
        }

        // frustrated
        //
        if (n.name () == "frustrated" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< FrustratedType > r (
            FrustratedTraits::create (i, f, this));

          this->frustrated_.push_back (::std::move (r));
          continue;
        }

        // grumpy
        //
        if (n.name () == "grumpy" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< GrumpyType > r (
            GrumpyTraits::create (i, f, this));

          this->grumpy_.push_back (::std::move (r));
          continue;
        }

        // guilty
        //
        if (n.name () == "guilty" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< GuiltyType > r (
            GuiltyTraits::create (i, f, this));

          this->guilty_.push_back (::std::move (r));
          continue;
        }

        // happy
        //
        if (n.name () == "happy" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< HappyType > r (
            HappyTraits::create (i, f, this));

          this->happy_.push_back (::std::move (r));
          continue;
        }

        // hot
        //
        if (n.name () == "hot" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< HotType > r (
            HotTraits::create (i, f, this));

          this->hot_.push_back (::std::move (r));
          continue;
        }

        // humbled
        //
        if (n.name () == "humbled" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< HumbledType > r (
            HumbledTraits::create (i, f, this));

          this->humbled_.push_back (::std::move (r));
          continue;
        }

        // humiliated
        //
        if (n.name () == "humiliated" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< HumiliatedType > r (
            HumiliatedTraits::create (i, f, this));

          this->humiliated_.push_back (::std::move (r));
          continue;
        }

        // hungry
        //
        if (n.name () == "hungry" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< HungryType > r (
            HungryTraits::create (i, f, this));

          this->hungry_.push_back (::std::move (r));
          continue;
        }

        // hurt
        //
        if (n.name () == "hurt" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< HurtType > r (
            HurtTraits::create (i, f, this));

          this->hurt_.push_back (::std::move (r));
          continue;
        }

        // impressed
        //
        if (n.name () == "impressed" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ImpressedType > r (
            ImpressedTraits::create (i, f, this));

          this->impressed_.push_back (::std::move (r));
          continue;
        }

        // in_awe
        //
        if (n.name () == "in_awe" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< In_aweType > r (
            In_aweTraits::create (i, f, this));

          this->in_awe_.push_back (::std::move (r));
          continue;
        }

        // in_love
        //
        if (n.name () == "in_love" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< In_loveType > r (
            In_loveTraits::create (i, f, this));

          this->in_love_.push_back (::std::move (r));
          continue;
        }

        // indignant
        //
        if (n.name () == "indignant" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< IndignantType > r (
            IndignantTraits::create (i, f, this));

          this->indignant_.push_back (::std::move (r));
          continue;
        }

        // interested
        //
        if (n.name () == "interested" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< InterestedType > r (
            InterestedTraits::create (i, f, this));

          this->interested_.push_back (::std::move (r));
          continue;
        }

        // invincible
        //
        if (n.name () == "invincible" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< InvincibleType > r (
            InvincibleTraits::create (i, f, this));

          this->invincible_.push_back (::std::move (r));
          continue;
        }

        // jealous
        //
        if (n.name () == "jealous" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< JealousType > r (
            JealousTraits::create (i, f, this));

          this->jealous_.push_back (::std::move (r));
          continue;
        }

        // lonely
        //
        if (n.name () == "lonely" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< LonelyType > r (
            LonelyTraits::create (i, f, this));

          this->lonely_.push_back (::std::move (r));
          continue;
        }

        // mean
        //
        if (n.name () == "mean" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< MeanType > r (
            MeanTraits::create (i, f, this));

          this->mean_.push_back (::std::move (r));
          continue;
        }

        // moody
        //
        if (n.name () == "moody" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< MoodyType > r (
            MoodyTraits::create (i, f, this));

          this->moody_.push_back (::std::move (r));
          continue;
        }

        // nervous
        //
        if (n.name () == "nervous" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< NervousType > r (
            NervousTraits::create (i, f, this));

          this->nervous_.push_back (::std::move (r));
          continue;
        }

        // neutral
        //
        if (n.name () == "neutral" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< NeutralType > r (
            NeutralTraits::create (i, f, this));

          this->neutral_.push_back (::std::move (r));
          continue;
        }

        // offended
        //
        if (n.name () == "offended" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< OffendedType > r (
            OffendedTraits::create (i, f, this));

          this->offended_.push_back (::std::move (r));
          continue;
        }

        // playful
        //
        if (n.name () == "playful" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< PlayfulType > r (
            PlayfulTraits::create (i, f, this));

          this->playful_.push_back (::std::move (r));
          continue;
        }

        // proud
        //
        if (n.name () == "proud" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ProudType > r (
            ProudTraits::create (i, f, this));

          this->proud_.push_back (::std::move (r));
          continue;
        }

        // relieved
        //
        if (n.name () == "relieved" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< RelievedType > r (
            RelievedTraits::create (i, f, this));

          this->relieved_.push_back (::std::move (r));
          continue;
        }

        // remorseful
        //
        if (n.name () == "remorseful" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< RemorsefulType > r (
            RemorsefulTraits::create (i, f, this));

          this->remorseful_.push_back (::std::move (r));
          continue;
        }

        // restless
        //
        if (n.name () == "restless" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< RestlessType > r (
            RestlessTraits::create (i, f, this));

          this->restless_.push_back (::std::move (r));
          continue;
        }

        // sad
        //
        if (n.name () == "sad" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< SadType > r (
            SadTraits::create (i, f, this));

          this->sad_.push_back (::std::move (r));
          continue;
        }

        // sarcastic
        //
        if (n.name () == "sarcastic" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< SarcasticType > r (
            SarcasticTraits::create (i, f, this));

          this->sarcastic_.push_back (::std::move (r));
          continue;
        }

        // serious
        //
        if (n.name () == "serious" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< SeriousType > r (
            SeriousTraits::create (i, f, this));

          this->serious_.push_back (::std::move (r));
          continue;
        }

        // shocked
        //
        if (n.name () == "shocked" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ShockedType > r (
            ShockedTraits::create (i, f, this));

          this->shocked_.push_back (::std::move (r));
          continue;
        }

        // shy
        //
        if (n.name () == "shy" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ShyType > r (
            ShyTraits::create (i, f, this));

          this->shy_.push_back (::std::move (r));
          continue;
        }

        // sick
        //
        if (n.name () == "sick" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< SickType > r (
            SickTraits::create (i, f, this));

          this->sick_.push_back (::std::move (r));
          continue;
        }

        // sleepy
        //
        if (n.name () == "sleepy" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< SleepyType > r (
            SleepyTraits::create (i, f, this));

          this->sleepy_.push_back (::std::move (r));
          continue;
        }

        // stressed
        //
        if (n.name () == "stressed" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< StressedType > r (
            StressedTraits::create (i, f, this));

          this->stressed_.push_back (::std::move (r));
          continue;
        }

        // surprised
        //
        if (n.name () == "surprised" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< SurprisedType > r (
            SurprisedTraits::create (i, f, this));

          this->surprised_.push_back (::std::move (r));
          continue;
        }

        // thirsty
        //
        if (n.name () == "thirsty" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ThirstyType > r (
            ThirstyTraits::create (i, f, this));

          this->thirsty_.push_back (::std::move (r));
          continue;
        }

        // worried
        //
        if (n.name () == "worried" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< WorriedType > r (
            WorriedTraits::create (i, f, this));

          this->worried_.push_back (::std::move (r));
          continue;
        }

        // other
        //
        if (n.name () == "other" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< OtherType > r (
            OtherTraits::create (i, f, this));

          this->other_.push_back (::std::move (r));
          continue;
        }

        // any
        //
        if ((!n.namespace_ ().empty () && n.namespace_ () != "urn:ietf:params:xml:ns:pidf:rpid"))
        {
          ::xercesc::DOMElement* r (
            static_cast< ::xercesc::DOMElement* > (
              this->getDomDocument ().importNode (
                const_cast< ::xercesc::DOMElement* > (&i), true)));
          this->any_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "from" && n.namespace_ ().empty ())
        {
          this->from_.set (FromTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "until" && n.namespace_ ().empty ())
        {
          this->until_.set (UntilTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (IdTraits::create (i, f, this));
          continue;
        }

        // any_attribute
        //
        if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->getDomDocument ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute_ .insert (r);
          continue;
        }
      }
    }

    Mood* Mood::
    _clone (::Xsd::XmlSchema::Flags f,
            ::Xsd::XmlSchema::Container* c) const
    {
      return new class Mood (*this, f, c);
    }

    Mood& Mood::
    operator= (const Mood& x)
    {
      if (this != &x)
      {
        static_cast< ::Xsd::XmlSchema::Type& > (*this) = x;
        this->note_ = x.note_;
        this->unknown_ = x.unknown_;
        this->afraid_ = x.afraid_;
        this->amazed_ = x.amazed_;
        this->angry_ = x.angry_;
        this->annoyed_ = x.annoyed_;
        this->anxious_ = x.anxious_;
        this->ashamed_ = x.ashamed_;
        this->bored_ = x.bored_;
        this->brave_ = x.brave_;
        this->calm_ = x.calm_;
        this->cold_ = x.cold_;
        this->confused_ = x.confused_;
        this->contented_ = x.contented_;
        this->cranky_ = x.cranky_;
        this->curious_ = x.curious_;
        this->depressed_ = x.depressed_;
        this->disappointed_ = x.disappointed_;
        this->disgusted_ = x.disgusted_;
        this->distracted_ = x.distracted_;
        this->embarrassed_ = x.embarrassed_;
        this->excited_ = x.excited_;
        this->flirtatious_ = x.flirtatious_;
        this->frustrated_ = x.frustrated_;
        this->grumpy_ = x.grumpy_;
        this->guilty_ = x.guilty_;
        this->happy_ = x.happy_;
        this->hot_ = x.hot_;
        this->humbled_ = x.humbled_;
        this->humiliated_ = x.humiliated_;
        this->hungry_ = x.hungry_;
        this->hurt_ = x.hurt_;
        this->impressed_ = x.impressed_;
        this->in_awe_ = x.in_awe_;
        this->in_love_ = x.in_love_;
        this->indignant_ = x.indignant_;
        this->interested_ = x.interested_;
        this->invincible_ = x.invincible_;
        this->jealous_ = x.jealous_;
        this->lonely_ = x.lonely_;
        this->mean_ = x.mean_;
        this->moody_ = x.moody_;
        this->nervous_ = x.nervous_;
        this->neutral_ = x.neutral_;
        this->offended_ = x.offended_;
        this->playful_ = x.playful_;
        this->proud_ = x.proud_;
        this->relieved_ = x.relieved_;
        this->remorseful_ = x.remorseful_;
        this->restless_ = x.restless_;
        this->sad_ = x.sad_;
        this->sarcastic_ = x.sarcastic_;
        this->serious_ = x.serious_;
        this->shocked_ = x.shocked_;
        this->shy_ = x.shy_;
        this->sick_ = x.sick_;
        this->sleepy_ = x.sleepy_;
        this->stressed_ = x.stressed_;
        this->surprised_ = x.surprised_;
        this->thirsty_ = x.thirsty_;
        this->worried_ = x.worried_;
        this->other_ = x.other_;
        this->any_ = x.any_;
        this->from_ = x.from_;
        this->until_ = x.until_;
        this->id_ = x.id_;
        this->any_attribute_ = x.any_attribute_;
      }

      return *this;
    }

    Mood::
    ~Mood ()
    {
    }

    // PlaceIs
    //

    PlaceIs::
    PlaceIs ()
    : ::Xsd::XmlSchema::Type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      note_ (this),
      audio_ (this),
      video_ (this),
      text_ (this),
      from_ (this),
      until_ (this),
      id_ (this),
      any_attribute_ (this->getDomDocument ())
    {
    }

    PlaceIs::
    PlaceIs (const PlaceIs& x,
             ::Xsd::XmlSchema::Flags f,
             ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      note_ (x.note_, f, this),
      audio_ (x.audio_, f, this),
      video_ (x.video_, f, this),
      text_ (x.text_, f, this),
      from_ (x.from_, f, this),
      until_ (x.until_, f, this),
      id_ (x.id_, f, this),
      any_attribute_ (x.any_attribute_, this->getDomDocument ())
    {
    }

    PlaceIs::
    PlaceIs (const ::xercesc::DOMElement& e,
             ::Xsd::XmlSchema::Flags f,
             ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (e, f | ::Xsd::XmlSchema::Flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      note_ (this),
      audio_ (this),
      video_ (this),
      text_ (this),
      from_ (this),
      until_ (this),
      id_ (this),
      any_attribute_ (this->getDomDocument ())
    {
      if ((f & ::Xsd::XmlSchema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PlaceIs::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::Xsd::XmlSchema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // note
        //
        if (n.name () == "note" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< NoteType > r (
            NoteTraits::create (i, f, this));

          this->note_.push_back (::std::move (r));
          continue;
        }

        // audio
        //
        if (n.name () == "audio" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< AudioType > r (
            AudioTraits::create (i, f, this));

          if (!this->audio_)
          {
            this->audio_.set (::std::move (r));
            continue;
          }
        }

        // video
        //
        if (n.name () == "video" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< VideoType > r (
            VideoTraits::create (i, f, this));

          if (!this->video_)
          {
            this->video_.set (::std::move (r));
            continue;
          }
        }

        // text
        //
        if (n.name () == "text" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< TextType > r (
            TextTraits::create (i, f, this));

          if (!this->text_)
          {
            this->text_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "from" && n.namespace_ ().empty ())
        {
          this->from_.set (FromTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "until" && n.namespace_ ().empty ())
        {
          this->until_.set (UntilTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (IdTraits::create (i, f, this));
          continue;
        }

        // any_attribute
        //
        if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->getDomDocument ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute_ .insert (r);
          continue;
        }
      }
    }

    PlaceIs* PlaceIs::
    _clone (::Xsd::XmlSchema::Flags f,
            ::Xsd::XmlSchema::Container* c) const
    {
      return new class PlaceIs (*this, f, c);
    }

    PlaceIs& PlaceIs::
    operator= (const PlaceIs& x)
    {
      if (this != &x)
      {
        static_cast< ::Xsd::XmlSchema::Type& > (*this) = x;
        this->note_ = x.note_;
        this->audio_ = x.audio_;
        this->video_ = x.video_;
        this->text_ = x.text_;
        this->from_ = x.from_;
        this->until_ = x.until_;
        this->id_ = x.id_;
        this->any_attribute_ = x.any_attribute_;
      }

      return *this;
    }

    PlaceIs::
    ~PlaceIs ()
    {
    }

    // PlaceType
    //

    PlaceType::
    PlaceType ()
    : ::Xsd::XmlSchema::Type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      note_ (this),
      other_ (this),
      any_ (this->getDomDocument ()),
      from_ (this),
      until_ (this),
      id_ (this),
      any_attribute_ (this->getDomDocument ())
    {
    }

    PlaceType::
    PlaceType (const PlaceType& x,
               ::Xsd::XmlSchema::Flags f,
               ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      note_ (x.note_, f, this),
      other_ (x.other_, f, this),
      any_ (x.any_, this->getDomDocument ()),
      from_ (x.from_, f, this),
      until_ (x.until_, f, this),
      id_ (x.id_, f, this),
      any_attribute_ (x.any_attribute_, this->getDomDocument ())
    {
    }

    PlaceType::
    PlaceType (const ::xercesc::DOMElement& e,
               ::Xsd::XmlSchema::Flags f,
               ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (e, f | ::Xsd::XmlSchema::Flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      note_ (this),
      other_ (this),
      any_ (this->getDomDocument ()),
      from_ (this),
      until_ (this),
      id_ (this),
      any_attribute_ (this->getDomDocument ())
    {
      if ((f & ::Xsd::XmlSchema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PlaceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::Xsd::XmlSchema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // note
        //
        if (n.name () == "note" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< NoteType > r (
            NoteTraits::create (i, f, this));

          this->note_.push_back (::std::move (r));
          continue;
        }

        // other
        //
        if (n.name () == "other" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< OtherType > r (
            OtherTraits::create (i, f, this));

          if (!this->other_)
          {
            this->other_.set (::std::move (r));
            continue;
          }
        }

        // any
        //
        if ((!n.namespace_ ().empty () && n.namespace_ () != "urn:ietf:params:xml:ns:pidf:rpid"))
        {
          ::xercesc::DOMElement* r (
            static_cast< ::xercesc::DOMElement* > (
              this->getDomDocument ().importNode (
                const_cast< ::xercesc::DOMElement* > (&i), true)));
          this->any_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "from" && n.namespace_ ().empty ())
        {
          this->from_.set (FromTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "until" && n.namespace_ ().empty ())
        {
          this->until_.set (UntilTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (IdTraits::create (i, f, this));
          continue;
        }

        // any_attribute
        //
        if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->getDomDocument ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute_ .insert (r);
          continue;
        }
      }
    }

    PlaceType* PlaceType::
    _clone (::Xsd::XmlSchema::Flags f,
            ::Xsd::XmlSchema::Container* c) const
    {
      return new class PlaceType (*this, f, c);
    }

    PlaceType& PlaceType::
    operator= (const PlaceType& x)
    {
      if (this != &x)
      {
        static_cast< ::Xsd::XmlSchema::Type& > (*this) = x;
        this->note_ = x.note_;
        this->other_ = x.other_;
        this->any_ = x.any_;
        this->from_ = x.from_;
        this->until_ = x.until_;
        this->id_ = x.id_;
        this->any_attribute_ = x.any_attribute_;
      }

      return *this;
    }

    PlaceType::
    ~PlaceType ()
    {
    }

    // Privacy
    //

    Privacy::
    Privacy ()
    : ::Xsd::XmlSchema::Type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      note_ (this),
      unknown_ (this),
      audio_ (this),
      text_ (this),
      video_ (this),
      any_ (this->getDomDocument ()),
      from_ (this),
      until_ (this),
      id_ (this),
      any_attribute_ (this->getDomDocument ())
    {
    }

    Privacy::
    Privacy (const Privacy& x,
             ::Xsd::XmlSchema::Flags f,
             ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      note_ (x.note_, f, this),
      unknown_ (x.unknown_, f, this),
      audio_ (x.audio_, f, this),
      text_ (x.text_, f, this),
      video_ (x.video_, f, this),
      any_ (x.any_, this->getDomDocument ()),
      from_ (x.from_, f, this),
      until_ (x.until_, f, this),
      id_ (x.id_, f, this),
      any_attribute_ (x.any_attribute_, this->getDomDocument ())
    {
    }

    Privacy::
    Privacy (const ::xercesc::DOMElement& e,
             ::Xsd::XmlSchema::Flags f,
             ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (e, f | ::Xsd::XmlSchema::Flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      note_ (this),
      unknown_ (this),
      audio_ (this),
      text_ (this),
      video_ (this),
      any_ (this->getDomDocument ()),
      from_ (this),
      until_ (this),
      id_ (this),
      any_attribute_ (this->getDomDocument ())
    {
      if ((f & ::Xsd::XmlSchema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Privacy::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::Xsd::XmlSchema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // note
        //
        if (n.name () == "note" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< NoteType > r (
            NoteTraits::create (i, f, this));

          this->note_.push_back (::std::move (r));
          continue;
        }

        // unknown
        //
        if (n.name () == "unknown" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< UnknownType > r (
            UnknownTraits::create (i, f, this));

          if (!this->unknown_)
          {
            this->unknown_.set (::std::move (r));
            continue;
          }
        }

        // audio
        //
        if (n.name () == "audio" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< AudioType > r (
            AudioTraits::create (i, f, this));

          if (!this->audio_)
          {
            this->audio_.set (::std::move (r));
            continue;
          }
        }

        // text
        //
        if (n.name () == "text" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< TextType > r (
            TextTraits::create (i, f, this));

          if (!this->text_)
          {
            this->text_.set (::std::move (r));
            continue;
          }
        }

        // video
        //
        if (n.name () == "video" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< VideoType > r (
            VideoTraits::create (i, f, this));

          if (!this->video_)
          {
            this->video_.set (::std::move (r));
            continue;
          }
        }

        // any
        //
        if ((!n.namespace_ ().empty () && n.namespace_ () != "urn:ietf:params:xml:ns:pidf:rpid"))
        {
          ::xercesc::DOMElement* r (
            static_cast< ::xercesc::DOMElement* > (
              this->getDomDocument ().importNode (
                const_cast< ::xercesc::DOMElement* > (&i), true)));
          this->any_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "from" && n.namespace_ ().empty ())
        {
          this->from_.set (FromTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "until" && n.namespace_ ().empty ())
        {
          this->until_.set (UntilTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (IdTraits::create (i, f, this));
          continue;
        }

        // any_attribute
        //
        if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->getDomDocument ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute_ .insert (r);
          continue;
        }
      }
    }

    Privacy* Privacy::
    _clone (::Xsd::XmlSchema::Flags f,
            ::Xsd::XmlSchema::Container* c) const
    {
      return new class Privacy (*this, f, c);
    }

    Privacy& Privacy::
    operator= (const Privacy& x)
    {
      if (this != &x)
      {
        static_cast< ::Xsd::XmlSchema::Type& > (*this) = x;
        this->note_ = x.note_;
        this->unknown_ = x.unknown_;
        this->audio_ = x.audio_;
        this->text_ = x.text_;
        this->video_ = x.video_;
        this->any_ = x.any_;
        this->from_ = x.from_;
        this->until_ = x.until_;
        this->id_ = x.id_;
        this->any_attribute_ = x.any_attribute_;
      }

      return *this;
    }

    Privacy::
    ~Privacy ()
    {
    }

    // Relationship
    //

    Relationship::
    Relationship ()
    : ::Xsd::XmlSchema::Type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      note_ (this),
      assistant_ (this),
      associate_ (this),
      family_ (this),
      friend__ (this),
      other_ (this),
      self_ (this),
      supervisor_ (this),
      unknown_ (this),
      any_ (this->getDomDocument ())
    {
    }

    Relationship::
    Relationship (const Relationship& x,
                  ::Xsd::XmlSchema::Flags f,
                  ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      note_ (x.note_, f, this),
      assistant_ (x.assistant_, f, this),
      associate_ (x.associate_, f, this),
      family_ (x.family_, f, this),
      friend__ (x.friend__, f, this),
      other_ (x.other_, f, this),
      self_ (x.self_, f, this),
      supervisor_ (x.supervisor_, f, this),
      unknown_ (x.unknown_, f, this),
      any_ (x.any_, this->getDomDocument ())
    {
    }

    Relationship::
    Relationship (const ::xercesc::DOMElement& e,
                  ::Xsd::XmlSchema::Flags f,
                  ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (e, f | ::Xsd::XmlSchema::Flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      note_ (this),
      assistant_ (this),
      associate_ (this),
      family_ (this),
      friend__ (this),
      other_ (this),
      self_ (this),
      supervisor_ (this),
      unknown_ (this),
      any_ (this->getDomDocument ())
    {
      if ((f & ::Xsd::XmlSchema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Relationship::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::Xsd::XmlSchema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // note
        //
        if (n.name () == "note" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< NoteType > r (
            NoteTraits::create (i, f, this));

          this->note_.push_back (::std::move (r));
          continue;
        }

        // assistant
        //
        if (n.name () == "assistant" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< AssistantType > r (
            AssistantTraits::create (i, f, this));

          if (!this->assistant_)
          {
            this->assistant_.set (::std::move (r));
            continue;
          }
        }

        // associate
        //
        if (n.name () == "associate" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< AssociateType > r (
            AssociateTraits::create (i, f, this));

          if (!this->associate_)
          {
            this->associate_.set (::std::move (r));
            continue;
          }
        }

        // family
        //
        if (n.name () == "family" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< FamilyType > r (
            FamilyTraits::create (i, f, this));

          if (!this->family_)
          {
            this->family_.set (::std::move (r));
            continue;
          }
        }

        // friend
        //
        if (n.name () == "friend" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< FriendType > r (
            FriendTraits::create (i, f, this));

          if (!this->friend__)
          {
            this->friend__.set (::std::move (r));
            continue;
          }
        }

        // other
        //
        if (n.name () == "other" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< OtherType > r (
            OtherTraits::create (i, f, this));

          if (!this->other_)
          {
            this->other_.set (::std::move (r));
            continue;
          }
        }

        // self
        //
        if (n.name () == "self" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< SelfType > r (
            SelfTraits::create (i, f, this));

          if (!this->self_)
          {
            this->self_.set (::std::move (r));
            continue;
          }
        }

        // supervisor
        //
        if (n.name () == "supervisor" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< SupervisorType > r (
            SupervisorTraits::create (i, f, this));

          if (!this->supervisor_)
          {
            this->supervisor_.set (::std::move (r));
            continue;
          }
        }

        // unknown
        //
        if (n.name () == "unknown" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< UnknownType > r (
            UnknownTraits::create (i, f, this));

          if (!this->unknown_)
          {
            this->unknown_.set (::std::move (r));
            continue;
          }
        }

        // any
        //
        if ((!n.namespace_ ().empty () && n.namespace_ () != "urn:ietf:params:xml:ns:pidf:rpid"))
        {
          ::xercesc::DOMElement* r (
            static_cast< ::xercesc::DOMElement* > (
              this->getDomDocument ().importNode (
                const_cast< ::xercesc::DOMElement* > (&i), true)));
          this->any_.push_back (r);
          continue;
        }

        break;
      }
    }

    Relationship* Relationship::
    _clone (::Xsd::XmlSchema::Flags f,
            ::Xsd::XmlSchema::Container* c) const
    {
      return new class Relationship (*this, f, c);
    }

    Relationship& Relationship::
    operator= (const Relationship& x)
    {
      if (this != &x)
      {
        static_cast< ::Xsd::XmlSchema::Type& > (*this) = x;
        this->note_ = x.note_;
        this->assistant_ = x.assistant_;
        this->associate_ = x.associate_;
        this->family_ = x.family_;
        this->friend__ = x.friend__;
        this->other_ = x.other_;
        this->self_ = x.self_;
        this->supervisor_ = x.supervisor_;
        this->unknown_ = x.unknown_;
        this->any_ = x.any_;
      }

      return *this;
    }

    Relationship::
    ~Relationship ()
    {
    }

    // ServiceClass
    //

    ServiceClass::
    ServiceClass ()
    : ::Xsd::XmlSchema::Type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      note_ (this),
      courier_ (this),
      electronic_ (this),
      freight_ (this),
      in_person_ (this),
      postal_ (this),
      unknown_ (this),
      any_ (this->getDomDocument ())
    {
    }

    ServiceClass::
    ServiceClass (const ServiceClass& x,
                  ::Xsd::XmlSchema::Flags f,
                  ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      note_ (x.note_, f, this),
      courier_ (x.courier_, f, this),
      electronic_ (x.electronic_, f, this),
      freight_ (x.freight_, f, this),
      in_person_ (x.in_person_, f, this),
      postal_ (x.postal_, f, this),
      unknown_ (x.unknown_, f, this),
      any_ (x.any_, this->getDomDocument ())
    {
    }

    ServiceClass::
    ServiceClass (const ::xercesc::DOMElement& e,
                  ::Xsd::XmlSchema::Flags f,
                  ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (e, f | ::Xsd::XmlSchema::Flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      note_ (this),
      courier_ (this),
      electronic_ (this),
      freight_ (this),
      in_person_ (this),
      postal_ (this),
      unknown_ (this),
      any_ (this->getDomDocument ())
    {
      if ((f & ::Xsd::XmlSchema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ServiceClass::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::Xsd::XmlSchema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // note
        //
        if (n.name () == "note" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< NoteType > r (
            NoteTraits::create (i, f, this));

          this->note_.push_back (::std::move (r));
          continue;
        }

        // courier
        //
        if (n.name () == "courier" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< CourierType > r (
            CourierTraits::create (i, f, this));

          if (!this->courier_)
          {
            this->courier_.set (::std::move (r));
            continue;
          }
        }

        // electronic
        //
        if (n.name () == "electronic" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ElectronicType > r (
            ElectronicTraits::create (i, f, this));

          if (!this->electronic_)
          {
            this->electronic_.set (::std::move (r));
            continue;
          }
        }

        // freight
        //
        if (n.name () == "freight" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< FreightType > r (
            FreightTraits::create (i, f, this));

          if (!this->freight_)
          {
            this->freight_.set (::std::move (r));
            continue;
          }
        }

        // in-person
        //
        if (n.name () == "in-person" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< InPersonType > r (
            InPersonTraits::create (i, f, this));

          if (!this->in_person_)
          {
            this->in_person_.set (::std::move (r));
            continue;
          }
        }

        // postal
        //
        if (n.name () == "postal" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< PostalType > r (
            PostalTraits::create (i, f, this));

          if (!this->postal_)
          {
            this->postal_.set (::std::move (r));
            continue;
          }
        }

        // unknown
        //
        if (n.name () == "unknown" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< UnknownType > r (
            UnknownTraits::create (i, f, this));

          if (!this->unknown_)
          {
            this->unknown_.set (::std::move (r));
            continue;
          }
        }

        // any
        //
        if ((!n.namespace_ ().empty () && n.namespace_ () != "urn:ietf:params:xml:ns:pidf:rpid"))
        {
          ::xercesc::DOMElement* r (
            static_cast< ::xercesc::DOMElement* > (
              this->getDomDocument ().importNode (
                const_cast< ::xercesc::DOMElement* > (&i), true)));
          this->any_.push_back (r);
          continue;
        }

        break;
      }
    }

    ServiceClass* ServiceClass::
    _clone (::Xsd::XmlSchema::Flags f,
            ::Xsd::XmlSchema::Container* c) const
    {
      return new class ServiceClass (*this, f, c);
    }

    ServiceClass& ServiceClass::
    operator= (const ServiceClass& x)
    {
      if (this != &x)
      {
        static_cast< ::Xsd::XmlSchema::Type& > (*this) = x;
        this->note_ = x.note_;
        this->courier_ = x.courier_;
        this->electronic_ = x.electronic_;
        this->freight_ = x.freight_;
        this->in_person_ = x.in_person_;
        this->postal_ = x.postal_;
        this->unknown_ = x.unknown_;
        this->any_ = x.any_;
      }

      return *this;
    }

    ServiceClass::
    ~ServiceClass ()
    {
    }

    // Sphere
    //

    Sphere::
    Sphere ()
    : ::Xsd::XmlSchema::Type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      home_ (this),
      work_ (this),
      unknown_ (this),
      any_ (this->getDomDocument ()),
      from_ (this),
      until_ (this),
      id_ (this),
      any_attribute_ (this->getDomDocument ())
    {
    }

    Sphere::
    Sphere (const Sphere& x,
            ::Xsd::XmlSchema::Flags f,
            ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      home_ (x.home_, f, this),
      work_ (x.work_, f, this),
      unknown_ (x.unknown_, f, this),
      any_ (x.any_, this->getDomDocument ()),
      from_ (x.from_, f, this),
      until_ (x.until_, f, this),
      id_ (x.id_, f, this),
      any_attribute_ (x.any_attribute_, this->getDomDocument ())
    {
    }

    Sphere::
    Sphere (const ::xercesc::DOMElement& e,
            ::Xsd::XmlSchema::Flags f,
            ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (e, f | ::Xsd::XmlSchema::Flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      home_ (this),
      work_ (this),
      unknown_ (this),
      any_ (this->getDomDocument ()),
      from_ (this),
      until_ (this),
      id_ (this),
      any_attribute_ (this->getDomDocument ())
    {
      if ((f & ::Xsd::XmlSchema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Sphere::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::Xsd::XmlSchema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // home
        //
        if (n.name () == "home" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< HomeType > r (
            HomeTraits::create (i, f, this));

          if (!this->home_)
          {
            this->home_.set (::std::move (r));
            continue;
          }
        }

        // work
        //
        if (n.name () == "work" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< WorkType > r (
            WorkTraits::create (i, f, this));

          if (!this->work_)
          {
            this->work_.set (::std::move (r));
            continue;
          }
        }

        // unknown
        //
        if (n.name () == "unknown" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< UnknownType > r (
            UnknownTraits::create (i, f, this));

          if (!this->unknown_)
          {
            this->unknown_.set (::std::move (r));
            continue;
          }
        }

        // any
        //
        if ((!n.namespace_ ().empty () && n.namespace_ () != "urn:ietf:params:xml:ns:pidf:rpid"))
        {
          ::xercesc::DOMElement* r (
            static_cast< ::xercesc::DOMElement* > (
              this->getDomDocument ().importNode (
                const_cast< ::xercesc::DOMElement* > (&i), true)));
          this->any_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "from" && n.namespace_ ().empty ())
        {
          this->from_.set (FromTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "until" && n.namespace_ ().empty ())
        {
          this->until_.set (UntilTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (IdTraits::create (i, f, this));
          continue;
        }

        // any_attribute
        //
        if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->getDomDocument ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute_ .insert (r);
          continue;
        }
      }
    }

    Sphere* Sphere::
    _clone (::Xsd::XmlSchema::Flags f,
            ::Xsd::XmlSchema::Container* c) const
    {
      return new class Sphere (*this, f, c);
    }

    Sphere& Sphere::
    operator= (const Sphere& x)
    {
      if (this != &x)
      {
        static_cast< ::Xsd::XmlSchema::Type& > (*this) = x;
        this->home_ = x.home_;
        this->work_ = x.work_;
        this->unknown_ = x.unknown_;
        this->any_ = x.any_;
        this->from_ = x.from_;
        this->until_ = x.until_;
        this->id_ = x.id_;
        this->any_attribute_ = x.any_attribute_;
      }

      return *this;
    }

    Sphere::
    ~Sphere ()
    {
    }

    // StatusIcon
    //

    StatusIcon::
    StatusIcon (const ::Xsd::XmlSchema::Uri& _xsd_Uri_base)
    : ::Xsd::XmlSchema::Uri (_xsd_Uri_base),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      from_ (this),
      until_ (this),
      id_ (this),
      any_attribute_ (this->getDomDocument ())
    {
    }

    StatusIcon::
    StatusIcon (const StatusIcon& x,
                ::Xsd::XmlSchema::Flags f,
                ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Uri (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      from_ (x.from_, f, this),
      until_ (x.until_, f, this),
      id_ (x.id_, f, this),
      any_attribute_ (x.any_attribute_, this->getDomDocument ())
    {
    }

    StatusIcon::
    StatusIcon (const ::xercesc::DOMElement& e,
                ::Xsd::XmlSchema::Flags f,
                ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Uri (e, f | ::Xsd::XmlSchema::Flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      from_ (this),
      until_ (this),
      id_ (this),
      any_attribute_ (this->getDomDocument ())
    {
      if ((f & ::Xsd::XmlSchema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void StatusIcon::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::Xsd::XmlSchema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "from" && n.namespace_ ().empty ())
        {
          this->from_.set (FromTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "until" && n.namespace_ ().empty ())
        {
          this->until_.set (UntilTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (IdTraits::create (i, f, this));
          continue;
        }

        // any_attribute
        //
        if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->getDomDocument ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute_ .insert (r);
          continue;
        }
      }
    }

    StatusIcon* StatusIcon::
    _clone (::Xsd::XmlSchema::Flags f,
            ::Xsd::XmlSchema::Container* c) const
    {
      return new class StatusIcon (*this, f, c);
    }

    StatusIcon& StatusIcon::
    operator= (const StatusIcon& x)
    {
      if (this != &x)
      {
        static_cast< ::Xsd::XmlSchema::Uri& > (*this) = x;
        this->from_ = x.from_;
        this->until_ = x.until_;
        this->id_ = x.id_;
        this->any_attribute_ = x.any_attribute_;
      }

      return *this;
    }

    StatusIcon::
    ~StatusIcon ()
    {
    }

    // TimeOffset
    //

    TimeOffset::
    TimeOffset (const ::Xsd::XmlSchema::Integer& _xsd_Integer_base)
    : ::xsd::cxx::tree::fundamental_base< ::Xsd::XmlSchema::Integer, char, ::Xsd::XmlSchema::SimpleType > (_xsd_Integer_base),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      from_ (this),
      until_ (this),
      description_ (this),
      id_ (this),
      any_attribute_ (this->getDomDocument ())
    {
    }

    TimeOffset::
    TimeOffset (const TimeOffset& x,
                ::Xsd::XmlSchema::Flags f,
                ::Xsd::XmlSchema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::Xsd::XmlSchema::Integer, char, ::Xsd::XmlSchema::SimpleType > (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      from_ (x.from_, f, this),
      until_ (x.until_, f, this),
      description_ (x.description_, f, this),
      id_ (x.id_, f, this),
      any_attribute_ (x.any_attribute_, this->getDomDocument ())
    {
    }

    TimeOffset::
    TimeOffset (const ::xercesc::DOMElement& e,
                ::Xsd::XmlSchema::Flags f,
                ::Xsd::XmlSchema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::Xsd::XmlSchema::Integer, char, ::Xsd::XmlSchema::SimpleType > (e, f | ::Xsd::XmlSchema::Flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      from_ (this),
      until_ (this),
      description_ (this),
      id_ (this),
      any_attribute_ (this->getDomDocument ())
    {
      if ((f & ::Xsd::XmlSchema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void TimeOffset::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::Xsd::XmlSchema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "from" && n.namespace_ ().empty ())
        {
          this->from_.set (FromTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "until" && n.namespace_ ().empty ())
        {
          this->until_.set (UntilTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "description" && n.namespace_ ().empty ())
        {
          this->description_.set (DescriptionTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (IdTraits::create (i, f, this));
          continue;
        }

        // any_attribute
        //
        if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->getDomDocument ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute_ .insert (r);
          continue;
        }
      }
    }

    TimeOffset* TimeOffset::
    _clone (::Xsd::XmlSchema::Flags f,
            ::Xsd::XmlSchema::Container* c) const
    {
      return new class TimeOffset (*this, f, c);
    }

    TimeOffset& TimeOffset::
    operator= (const TimeOffset& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::cxx::tree::fundamental_base< ::Xsd::XmlSchema::Integer, char, ::Xsd::XmlSchema::SimpleType >& > (*this) = x;
        this->from_ = x.from_;
        this->until_ = x.until_;
        this->description_ = x.description_;
        this->id_ = x.id_;
        this->any_attribute_ = x.any_attribute_;
      }

      return *this;
    }

    TimeOffset::
    ~TimeOffset ()
    {
    }

    // UserInput
    //

    UserInput::
    UserInput (::Xsd::Rpid::ActiveIdle::Value _xsd_ActiveIdle_base)
    : ::Xsd::Rpid::ActiveIdle (_xsd_ActiveIdle_base),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      idle_threshold_ (this),
      last_input_ (this),
      id_ (this),
      any_attribute_ (this->getDomDocument ())
    {
    }

    UserInput::
    UserInput (const char* _xsd_String_base)
    : ::Xsd::Rpid::ActiveIdle (_xsd_String_base),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      idle_threshold_ (this),
      last_input_ (this),
      id_ (this),
      any_attribute_ (this->getDomDocument ())
    {
    }

    UserInput::
    UserInput (const ::std::string& _xsd_String_base)
    : ::Xsd::Rpid::ActiveIdle (_xsd_String_base),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      idle_threshold_ (this),
      last_input_ (this),
      id_ (this),
      any_attribute_ (this->getDomDocument ())
    {
    }

    UserInput::
    UserInput (const ::Xsd::Rpid::ActiveIdle& _xsd_ActiveIdle_base)
    : ::Xsd::Rpid::ActiveIdle (_xsd_ActiveIdle_base),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      idle_threshold_ (this),
      last_input_ (this),
      id_ (this),
      any_attribute_ (this->getDomDocument ())
    {
    }

    UserInput::
    UserInput (const UserInput& x,
               ::Xsd::XmlSchema::Flags f,
               ::Xsd::XmlSchema::Container* c)
    : ::Xsd::Rpid::ActiveIdle (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      idle_threshold_ (x.idle_threshold_, f, this),
      last_input_ (x.last_input_, f, this),
      id_ (x.id_, f, this),
      any_attribute_ (x.any_attribute_, this->getDomDocument ())
    {
    }

    UserInput::
    UserInput (const ::xercesc::DOMElement& e,
               ::Xsd::XmlSchema::Flags f,
               ::Xsd::XmlSchema::Container* c)
    : ::Xsd::Rpid::ActiveIdle (e, f | ::Xsd::XmlSchema::Flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      idle_threshold_ (this),
      last_input_ (this),
      id_ (this),
      any_attribute_ (this->getDomDocument ())
    {
      if ((f & ::Xsd::XmlSchema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void UserInput::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::Xsd::XmlSchema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "idle-threshold" && n.namespace_ ().empty ())
        {
          this->idle_threshold_.set (IdleThresholdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "last-input" && n.namespace_ ().empty ())
        {
          this->last_input_.set (LastInputTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (IdTraits::create (i, f, this));
          continue;
        }

        // any_attribute
        //
        if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->getDomDocument ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute_ .insert (r);
          continue;
        }
      }
    }

    UserInput* UserInput::
    _clone (::Xsd::XmlSchema::Flags f,
            ::Xsd::XmlSchema::Container* c) const
    {
      return new class UserInput (*this, f, c);
    }

    UserInput& UserInput::
    operator= (const UserInput& x)
    {
      if (this != &x)
      {
        static_cast< ::Xsd::Rpid::ActiveIdle& > (*this) = x;
        this->idle_threshold_ = x.idle_threshold_;
        this->last_input_ = x.last_input_;
        this->id_ = x.id_;
        this->any_attribute_ = x.any_attribute_;
      }

      return *this;
    }

    UserInput::
    ~UserInput ()
    {
    }

    // Audio
    //

    Audio::
    Audio ()
    : ::Xsd::XmlSchema::Type (),
      noisy_ (this),
      ok_ (this),
      quiet_ (this),
      unknown_ (this)
    {
    }

    Audio::
    Audio (const Audio& x,
           ::Xsd::XmlSchema::Flags f,
           ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (x, f, c),
      noisy_ (x.noisy_, f, this),
      ok_ (x.ok_, f, this),
      quiet_ (x.quiet_, f, this),
      unknown_ (x.unknown_, f, this)
    {
    }

    Audio::
    Audio (const ::xercesc::DOMElement& e,
           ::Xsd::XmlSchema::Flags f,
           ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (e, f | ::Xsd::XmlSchema::Flags::base, c),
      noisy_ (this),
      ok_ (this),
      quiet_ (this),
      unknown_ (this)
    {
      if ((f & ::Xsd::XmlSchema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Audio::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::Xsd::XmlSchema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // noisy
        //
        if (n.name () == "noisy" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< NoisyType > r (
            NoisyTraits::create (i, f, this));

          if (!this->noisy_)
          {
            this->noisy_.set (::std::move (r));
            continue;
          }
        }

        // ok
        //
        if (n.name () == "ok" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< OkType > r (
            OkTraits::create (i, f, this));

          if (!this->ok_)
          {
            this->ok_.set (::std::move (r));
            continue;
          }
        }

        // quiet
        //
        if (n.name () == "quiet" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< QuietType > r (
            QuietTraits::create (i, f, this));

          if (!this->quiet_)
          {
            this->quiet_.set (::std::move (r));
            continue;
          }
        }

        // unknown
        //
        if (n.name () == "unknown" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< UnknownType > r (
            UnknownTraits::create (i, f, this));

          if (!this->unknown_)
          {
            this->unknown_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    Audio* Audio::
    _clone (::Xsd::XmlSchema::Flags f,
            ::Xsd::XmlSchema::Container* c) const
    {
      return new class Audio (*this, f, c);
    }

    Audio& Audio::
    operator= (const Audio& x)
    {
      if (this != &x)
      {
        static_cast< ::Xsd::XmlSchema::Type& > (*this) = x;
        this->noisy_ = x.noisy_;
        this->ok_ = x.ok_;
        this->quiet_ = x.quiet_;
        this->unknown_ = x.unknown_;
      }

      return *this;
    }

    Audio::
    ~Audio ()
    {
    }

    // Video
    //

    Video::
    Video ()
    : ::Xsd::XmlSchema::Type (),
      toobright_ (this),
      ok_ (this),
      dark_ (this),
      unknown_ (this)
    {
    }

    Video::
    Video (const Video& x,
           ::Xsd::XmlSchema::Flags f,
           ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (x, f, c),
      toobright_ (x.toobright_, f, this),
      ok_ (x.ok_, f, this),
      dark_ (x.dark_, f, this),
      unknown_ (x.unknown_, f, this)
    {
    }

    Video::
    Video (const ::xercesc::DOMElement& e,
           ::Xsd::XmlSchema::Flags f,
           ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (e, f | ::Xsd::XmlSchema::Flags::base, c),
      toobright_ (this),
      ok_ (this),
      dark_ (this),
      unknown_ (this)
    {
      if ((f & ::Xsd::XmlSchema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Video::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::Xsd::XmlSchema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // toobright
        //
        if (n.name () == "toobright" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ToobrightType > r (
            ToobrightTraits::create (i, f, this));

          if (!this->toobright_)
          {
            this->toobright_.set (::std::move (r));
            continue;
          }
        }

        // ok
        //
        if (n.name () == "ok" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< OkType > r (
            OkTraits::create (i, f, this));

          if (!this->ok_)
          {
            this->ok_.set (::std::move (r));
            continue;
          }
        }

        // dark
        //
        if (n.name () == "dark" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< DarkType > r (
            DarkTraits::create (i, f, this));

          if (!this->dark_)
          {
            this->dark_.set (::std::move (r));
            continue;
          }
        }

        // unknown
        //
        if (n.name () == "unknown" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< UnknownType > r (
            UnknownTraits::create (i, f, this));

          if (!this->unknown_)
          {
            this->unknown_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    Video* Video::
    _clone (::Xsd::XmlSchema::Flags f,
            ::Xsd::XmlSchema::Container* c) const
    {
      return new class Video (*this, f, c);
    }

    Video& Video::
    operator= (const Video& x)
    {
      if (this != &x)
      {
        static_cast< ::Xsd::XmlSchema::Type& > (*this) = x;
        this->toobright_ = x.toobright_;
        this->ok_ = x.ok_;
        this->dark_ = x.dark_;
        this->unknown_ = x.unknown_;
      }

      return *this;
    }

    Video::
    ~Video ()
    {
    }

    // Text
    //

    Text::
    Text ()
    : ::Xsd::XmlSchema::Type (),
      uncomfortable_ (this),
      inappropriate_ (this),
      ok_ (this),
      unknown_ (this)
    {
    }

    Text::
    Text (const Text& x,
          ::Xsd::XmlSchema::Flags f,
          ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (x, f, c),
      uncomfortable_ (x.uncomfortable_, f, this),
      inappropriate_ (x.inappropriate_, f, this),
      ok_ (x.ok_, f, this),
      unknown_ (x.unknown_, f, this)
    {
    }

    Text::
    Text (const ::xercesc::DOMElement& e,
          ::Xsd::XmlSchema::Flags f,
          ::Xsd::XmlSchema::Container* c)
    : ::Xsd::XmlSchema::Type (e, f | ::Xsd::XmlSchema::Flags::base, c),
      uncomfortable_ (this),
      inappropriate_ (this),
      ok_ (this),
      unknown_ (this)
    {
      if ((f & ::Xsd::XmlSchema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Text::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::Xsd::XmlSchema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // uncomfortable
        //
        if (n.name () == "uncomfortable" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< UncomfortableType > r (
            UncomfortableTraits::create (i, f, this));

          if (!this->uncomfortable_)
          {
            this->uncomfortable_.set (::std::move (r));
            continue;
          }
        }

        // inappropriate
        //
        if (n.name () == "inappropriate" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< InappropriateType > r (
            InappropriateTraits::create (i, f, this));

          if (!this->inappropriate_)
          {
            this->inappropriate_.set (::std::move (r));
            continue;
          }
        }

        // ok
        //
        if (n.name () == "ok" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< OkType > r (
            OkTraits::create (i, f, this));

          if (!this->ok_)
          {
            this->ok_.set (::std::move (r));
            continue;
          }
        }

        // unknown
        //
        if (n.name () == "unknown" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< UnknownType > r (
            UnknownTraits::create (i, f, this));

          if (!this->unknown_)
          {
            this->unknown_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    Text* Text::
    _clone (::Xsd::XmlSchema::Flags f,
            ::Xsd::XmlSchema::Container* c) const
    {
      return new class Text (*this, f, c);
    }

    Text& Text::
    operator= (const Text& x)
    {
      if (this != &x)
      {
        static_cast< ::Xsd::XmlSchema::Type& > (*this) = x;
        this->uncomfortable_ = x.uncomfortable_;
        this->inappropriate_ = x.inappropriate_;
        this->ok_ = x.ok_;
        this->unknown_ = x.unknown_;
      }

      return *this;
    }

    Text::
    ~Text ()
    {
    }
  }
}

#include <ostream>

namespace Xsd
{
  namespace Rpid
  {
    ::std::ostream&
    operator<< (::std::ostream& o, const Timestamp_t& i)
    {
      o << static_cast< const ::Xsd::XmlSchema::DateTime& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const DeviceID_t& i)
    {
      o << static_cast< const ::Xsd::XmlSchema::Uri& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Note_t& i)
    {
      o << static_cast< const ::Xsd::XmlSchema::String& > (i);

      if (i.getLang ())
      {
        o << ::std::endl << "lang: " << *i.getLang ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Empty&)
    {
      return o;
    }
  }
}

namespace Xsd
{
  namespace Rpid
  {
    ::std::ostream&
    operator<< (::std::ostream& o, ActiveIdle::Value i)
    {
      return o << ActiveIdle::_xsd_ActiveIdle_literals_[i];
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const ActiveIdle& i)
    {
      return o << static_cast< const ::Xsd::XmlSchema::String& > (i);
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Activities& i)
    {
      for (Activities::NoteConstIterator
           b (i.getNote ().begin ()), e (i.getNote ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "note: " << *b;
      }

      if (i.getUnknown ())
      {
        o << ::std::endl << "unknown: " << *i.getUnknown ();
      }

      for (Activities::AppointmentConstIterator
           b (i.getAppointment ().begin ()), e (i.getAppointment ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "appointment: " << *b;
      }

      for (Activities::AwayConstIterator
           b (i.getAway ().begin ()), e (i.getAway ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "away: " << *b;
      }

      for (Activities::BreakfastConstIterator
           b (i.getBreakfast ().begin ()), e (i.getBreakfast ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "breakfast: " << *b;
      }

      for (Activities::BusyConstIterator
           b (i.getBusy ().begin ()), e (i.getBusy ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "busy: " << *b;
      }

      for (Activities::DinnerConstIterator
           b (i.getDinner ().begin ()), e (i.getDinner ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "dinner: " << *b;
      }

      for (Activities::HolidayConstIterator
           b (i.getHoliday ().begin ()), e (i.getHoliday ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "holiday: " << *b;
      }

      for (Activities::InTransitConstIterator
           b (i.getInTransit ().begin ()), e (i.getInTransit ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "in-transit: " << *b;
      }

      for (Activities::LookingForWorkConstIterator
           b (i.getLookingForWork ().begin ()), e (i.getLookingForWork ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "looking-for-work: " << *b;
      }

      for (Activities::MealConstIterator
           b (i.getMeal ().begin ()), e (i.getMeal ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "meal: " << *b;
      }

      for (Activities::MeetingConstIterator
           b (i.getMeeting ().begin ()), e (i.getMeeting ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "meeting: " << *b;
      }

      for (Activities::OnThePhoneConstIterator
           b (i.getOnThePhone ().begin ()), e (i.getOnThePhone ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "on-the-phone: " << *b;
      }

      for (Activities::PerformanceConstIterator
           b (i.getPerformance ().begin ()), e (i.getPerformance ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "performance: " << *b;
      }

      for (Activities::PermanentAbsenceConstIterator
           b (i.getPermanentAbsence ().begin ()), e (i.getPermanentAbsence ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "permanent-absence: " << *b;
      }

      for (Activities::PlayingConstIterator
           b (i.getPlaying ().begin ()), e (i.getPlaying ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "playing: " << *b;
      }

      for (Activities::PresentationConstIterator
           b (i.getPresentation ().begin ()), e (i.getPresentation ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "presentation: " << *b;
      }

      for (Activities::ShoppingConstIterator
           b (i.getShopping ().begin ()), e (i.getShopping ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "shopping: " << *b;
      }

      for (Activities::SleepingConstIterator
           b (i.getSleeping ().begin ()), e (i.getSleeping ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "sleeping: " << *b;
      }

      for (Activities::SpectatorConstIterator
           b (i.getSpectator ().begin ()), e (i.getSpectator ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "spectator: " << *b;
      }

      for (Activities::SteeringConstIterator
           b (i.getSteering ().begin ()), e (i.getSteering ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "steering: " << *b;
      }

      for (Activities::TravelConstIterator
           b (i.getTravel ().begin ()), e (i.getTravel ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "travel: " << *b;
      }

      for (Activities::TvConstIterator
           b (i.getTv ().begin ()), e (i.getTv ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "tv: " << *b;
      }

      for (Activities::VacationConstIterator
           b (i.getVacation ().begin ()), e (i.getVacation ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "vacation: " << *b;
      }

      for (Activities::WorkingConstIterator
           b (i.getWorking ().begin ()), e (i.getWorking ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "working: " << *b;
      }

      for (Activities::WorshipConstIterator
           b (i.getWorship ().begin ()), e (i.getWorship ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "worship: " << *b;
      }

      for (Activities::OtherConstIterator
           b (i.getOther ().begin ()), e (i.getOther ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "other: " << *b;
      }

      if (i.getFrom ())
      {
        o << ::std::endl << "from: " << *i.getFrom ();
      }

      if (i.getUntil ())
      {
        o << ::std::endl << "until: " << *i.getUntil ();
      }

      if (i.getId ())
      {
        o << ::std::endl << "id: " << *i.getId ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Mood& i)
    {
      for (Mood::NoteConstIterator
           b (i.getNote ().begin ()), e (i.getNote ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "note: " << *b;
      }

      if (i.getUnknown ())
      {
        o << ::std::endl << "unknown: " << *i.getUnknown ();
      }

      for (Mood::AfraidConstIterator
           b (i.getAfraid ().begin ()), e (i.getAfraid ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "afraid: " << *b;
      }

      for (Mood::AmazedConstIterator
           b (i.getAmazed ().begin ()), e (i.getAmazed ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "amazed: " << *b;
      }

      for (Mood::AngryConstIterator
           b (i.getAngry ().begin ()), e (i.getAngry ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "angry: " << *b;
      }

      for (Mood::AnnoyedConstIterator
           b (i.getAnnoyed ().begin ()), e (i.getAnnoyed ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "annoyed: " << *b;
      }

      for (Mood::AnxiousConstIterator
           b (i.getAnxious ().begin ()), e (i.getAnxious ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "anxious: " << *b;
      }

      for (Mood::AshamedConstIterator
           b (i.getAshamed ().begin ()), e (i.getAshamed ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "ashamed: " << *b;
      }

      for (Mood::BoredConstIterator
           b (i.getBored ().begin ()), e (i.getBored ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "bored: " << *b;
      }

      for (Mood::BraveConstIterator
           b (i.getBrave ().begin ()), e (i.getBrave ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "brave: " << *b;
      }

      for (Mood::CalmConstIterator
           b (i.getCalm ().begin ()), e (i.getCalm ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "calm: " << *b;
      }

      for (Mood::ColdConstIterator
           b (i.getCold ().begin ()), e (i.getCold ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "cold: " << *b;
      }

      for (Mood::ConfusedConstIterator
           b (i.getConfused ().begin ()), e (i.getConfused ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "confused: " << *b;
      }

      for (Mood::ContentedConstIterator
           b (i.getContented ().begin ()), e (i.getContented ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "contented: " << *b;
      }

      for (Mood::CrankyConstIterator
           b (i.getCranky ().begin ()), e (i.getCranky ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "cranky: " << *b;
      }

      for (Mood::CuriousConstIterator
           b (i.getCurious ().begin ()), e (i.getCurious ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "curious: " << *b;
      }

      for (Mood::DepressedConstIterator
           b (i.getDepressed ().begin ()), e (i.getDepressed ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "depressed: " << *b;
      }

      for (Mood::DisappointedConstIterator
           b (i.getDisappointed ().begin ()), e (i.getDisappointed ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "disappointed: " << *b;
      }

      for (Mood::DisgustedConstIterator
           b (i.getDisgusted ().begin ()), e (i.getDisgusted ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "disgusted: " << *b;
      }

      for (Mood::DistractedConstIterator
           b (i.getDistracted ().begin ()), e (i.getDistracted ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "distracted: " << *b;
      }

      for (Mood::EmbarrassedConstIterator
           b (i.getEmbarrassed ().begin ()), e (i.getEmbarrassed ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "embarrassed: " << *b;
      }

      for (Mood::ExcitedConstIterator
           b (i.getExcited ().begin ()), e (i.getExcited ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "excited: " << *b;
      }

      for (Mood::FlirtatiousConstIterator
           b (i.getFlirtatious ().begin ()), e (i.getFlirtatious ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "flirtatious: " << *b;
      }

      for (Mood::FrustratedConstIterator
           b (i.getFrustrated ().begin ()), e (i.getFrustrated ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "frustrated: " << *b;
      }

      for (Mood::GrumpyConstIterator
           b (i.getGrumpy ().begin ()), e (i.getGrumpy ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "grumpy: " << *b;
      }

      for (Mood::GuiltyConstIterator
           b (i.getGuilty ().begin ()), e (i.getGuilty ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "guilty: " << *b;
      }

      for (Mood::HappyConstIterator
           b (i.getHappy ().begin ()), e (i.getHappy ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "happy: " << *b;
      }

      for (Mood::HotConstIterator
           b (i.getHot ().begin ()), e (i.getHot ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "hot: " << *b;
      }

      for (Mood::HumbledConstIterator
           b (i.getHumbled ().begin ()), e (i.getHumbled ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "humbled: " << *b;
      }

      for (Mood::HumiliatedConstIterator
           b (i.getHumiliated ().begin ()), e (i.getHumiliated ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "humiliated: " << *b;
      }

      for (Mood::HungryConstIterator
           b (i.getHungry ().begin ()), e (i.getHungry ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "hungry: " << *b;
      }

      for (Mood::HurtConstIterator
           b (i.getHurt ().begin ()), e (i.getHurt ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "hurt: " << *b;
      }

      for (Mood::ImpressedConstIterator
           b (i.getImpressed ().begin ()), e (i.getImpressed ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "impressed: " << *b;
      }

      for (Mood::In_aweConstIterator
           b (i.getIn_awe ().begin ()), e (i.getIn_awe ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "in_awe: " << *b;
      }

      for (Mood::In_loveConstIterator
           b (i.getIn_love ().begin ()), e (i.getIn_love ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "in_love: " << *b;
      }

      for (Mood::IndignantConstIterator
           b (i.getIndignant ().begin ()), e (i.getIndignant ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "indignant: " << *b;
      }

      for (Mood::InterestedConstIterator
           b (i.getInterested ().begin ()), e (i.getInterested ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "interested: " << *b;
      }

      for (Mood::InvincibleConstIterator
           b (i.getInvincible ().begin ()), e (i.getInvincible ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "invincible: " << *b;
      }

      for (Mood::JealousConstIterator
           b (i.getJealous ().begin ()), e (i.getJealous ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "jealous: " << *b;
      }

      for (Mood::LonelyConstIterator
           b (i.getLonely ().begin ()), e (i.getLonely ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "lonely: " << *b;
      }

      for (Mood::MeanConstIterator
           b (i.getMean ().begin ()), e (i.getMean ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "mean: " << *b;
      }

      for (Mood::MoodyConstIterator
           b (i.getMoody ().begin ()), e (i.getMoody ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "moody: " << *b;
      }

      for (Mood::NervousConstIterator
           b (i.getNervous ().begin ()), e (i.getNervous ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "nervous: " << *b;
      }

      for (Mood::NeutralConstIterator
           b (i.getNeutral ().begin ()), e (i.getNeutral ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "neutral: " << *b;
      }

      for (Mood::OffendedConstIterator
           b (i.getOffended ().begin ()), e (i.getOffended ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "offended: " << *b;
      }

      for (Mood::PlayfulConstIterator
           b (i.getPlayful ().begin ()), e (i.getPlayful ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "playful: " << *b;
      }

      for (Mood::ProudConstIterator
           b (i.getProud ().begin ()), e (i.getProud ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "proud: " << *b;
      }

      for (Mood::RelievedConstIterator
           b (i.getRelieved ().begin ()), e (i.getRelieved ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "relieved: " << *b;
      }

      for (Mood::RemorsefulConstIterator
           b (i.getRemorseful ().begin ()), e (i.getRemorseful ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "remorseful: " << *b;
      }

      for (Mood::RestlessConstIterator
           b (i.getRestless ().begin ()), e (i.getRestless ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "restless: " << *b;
      }

      for (Mood::SadConstIterator
           b (i.getSad ().begin ()), e (i.getSad ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "sad: " << *b;
      }

      for (Mood::SarcasticConstIterator
           b (i.getSarcastic ().begin ()), e (i.getSarcastic ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "sarcastic: " << *b;
      }

      for (Mood::SeriousConstIterator
           b (i.getSerious ().begin ()), e (i.getSerious ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "serious: " << *b;
      }

      for (Mood::ShockedConstIterator
           b (i.getShocked ().begin ()), e (i.getShocked ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "shocked: " << *b;
      }

      for (Mood::ShyConstIterator
           b (i.getShy ().begin ()), e (i.getShy ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "shy: " << *b;
      }

      for (Mood::SickConstIterator
           b (i.getSick ().begin ()), e (i.getSick ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "sick: " << *b;
      }

      for (Mood::SleepyConstIterator
           b (i.getSleepy ().begin ()), e (i.getSleepy ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "sleepy: " << *b;
      }

      for (Mood::StressedConstIterator
           b (i.getStressed ().begin ()), e (i.getStressed ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "stressed: " << *b;
      }

      for (Mood::SurprisedConstIterator
           b (i.getSurprised ().begin ()), e (i.getSurprised ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "surprised: " << *b;
      }

      for (Mood::ThirstyConstIterator
           b (i.getThirsty ().begin ()), e (i.getThirsty ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "thirsty: " << *b;
      }

      for (Mood::WorriedConstIterator
           b (i.getWorried ().begin ()), e (i.getWorried ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "worried: " << *b;
      }

      for (Mood::OtherConstIterator
           b (i.getOther ().begin ()), e (i.getOther ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "other: " << *b;
      }

      if (i.getFrom ())
      {
        o << ::std::endl << "from: " << *i.getFrom ();
      }

      if (i.getUntil ())
      {
        o << ::std::endl << "until: " << *i.getUntil ();
      }

      if (i.getId ())
      {
        o << ::std::endl << "id: " << *i.getId ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const PlaceIs& i)
    {
      for (PlaceIs::NoteConstIterator
           b (i.getNote ().begin ()), e (i.getNote ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "note: " << *b;
      }

      if (i.getAudio ())
      {
        o << ::std::endl << "audio: " << *i.getAudio ();
      }

      if (i.getVideo ())
      {
        o << ::std::endl << "video: " << *i.getVideo ();
      }

      if (i.getText ())
      {
        o << ::std::endl << "text: " << *i.getText ();
      }

      if (i.getFrom ())
      {
        o << ::std::endl << "from: " << *i.getFrom ();
      }

      if (i.getUntil ())
      {
        o << ::std::endl << "until: " << *i.getUntil ();
      }

      if (i.getId ())
      {
        o << ::std::endl << "id: " << *i.getId ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const PlaceType& i)
    {
      for (PlaceType::NoteConstIterator
           b (i.getNote ().begin ()), e (i.getNote ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "note: " << *b;
      }

      if (i.getOther ())
      {
        o << ::std::endl << "other: " << *i.getOther ();
      }

      if (i.getFrom ())
      {
        o << ::std::endl << "from: " << *i.getFrom ();
      }

      if (i.getUntil ())
      {
        o << ::std::endl << "until: " << *i.getUntil ();
      }

      if (i.getId ())
      {
        o << ::std::endl << "id: " << *i.getId ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Privacy& i)
    {
      for (Privacy::NoteConstIterator
           b (i.getNote ().begin ()), e (i.getNote ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "note: " << *b;
      }

      if (i.getUnknown ())
      {
        o << ::std::endl << "unknown: " << *i.getUnknown ();
      }

      if (i.getAudio ())
      {
        o << ::std::endl << "audio: " << *i.getAudio ();
      }

      if (i.getText ())
      {
        o << ::std::endl << "text: " << *i.getText ();
      }

      if (i.getVideo ())
      {
        o << ::std::endl << "video: " << *i.getVideo ();
      }

      if (i.getFrom ())
      {
        o << ::std::endl << "from: " << *i.getFrom ();
      }

      if (i.getUntil ())
      {
        o << ::std::endl << "until: " << *i.getUntil ();
      }

      if (i.getId ())
      {
        o << ::std::endl << "id: " << *i.getId ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Relationship& i)
    {
      for (Relationship::NoteConstIterator
           b (i.getNote ().begin ()), e (i.getNote ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "note: " << *b;
      }

      if (i.getAssistant ())
      {
        o << ::std::endl << "assistant: " << *i.getAssistant ();
      }

      if (i.getAssociate ())
      {
        o << ::std::endl << "associate: " << *i.getAssociate ();
      }

      if (i.getFamily ())
      {
        o << ::std::endl << "family: " << *i.getFamily ();
      }

      if (i.getFriend ())
      {
        o << ::std::endl << "friend: " << *i.getFriend ();
      }

      if (i.getOther ())
      {
        o << ::std::endl << "other: " << *i.getOther ();
      }

      if (i.getSelf ())
      {
        o << ::std::endl << "self: " << *i.getSelf ();
      }

      if (i.getSupervisor ())
      {
        o << ::std::endl << "supervisor: " << *i.getSupervisor ();
      }

      if (i.getUnknown ())
      {
        o << ::std::endl << "unknown: " << *i.getUnknown ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const ServiceClass& i)
    {
      for (ServiceClass::NoteConstIterator
           b (i.getNote ().begin ()), e (i.getNote ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "note: " << *b;
      }

      if (i.getCourier ())
      {
        o << ::std::endl << "courier: " << *i.getCourier ();
      }

      if (i.getElectronic ())
      {
        o << ::std::endl << "electronic: " << *i.getElectronic ();
      }

      if (i.getFreight ())
      {
        o << ::std::endl << "freight: " << *i.getFreight ();
      }

      if (i.getInPerson ())
      {
        o << ::std::endl << "in-person: " << *i.getInPerson ();
      }

      if (i.getPostal ())
      {
        o << ::std::endl << "postal: " << *i.getPostal ();
      }

      if (i.getUnknown ())
      {
        o << ::std::endl << "unknown: " << *i.getUnknown ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Sphere& i)
    {
      if (i.getHome ())
      {
        o << ::std::endl << "home: " << *i.getHome ();
      }

      if (i.getWork ())
      {
        o << ::std::endl << "work: " << *i.getWork ();
      }

      if (i.getUnknown ())
      {
        o << ::std::endl << "unknown: " << *i.getUnknown ();
      }

      if (i.getFrom ())
      {
        o << ::std::endl << "from: " << *i.getFrom ();
      }

      if (i.getUntil ())
      {
        o << ::std::endl << "until: " << *i.getUntil ();
      }

      if (i.getId ())
      {
        o << ::std::endl << "id: " << *i.getId ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const StatusIcon& i)
    {
      o << static_cast< const ::Xsd::XmlSchema::Uri& > (i);

      if (i.getFrom ())
      {
        o << ::std::endl << "from: " << *i.getFrom ();
      }

      if (i.getUntil ())
      {
        o << ::std::endl << "until: " << *i.getUntil ();
      }

      if (i.getId ())
      {
        o << ::std::endl << "id: " << *i.getId ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const TimeOffset& i)
    {
      o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::Xsd::XmlSchema::Integer, char, ::Xsd::XmlSchema::SimpleType >& > (i);

      if (i.getFrom ())
      {
        o << ::std::endl << "from: " << *i.getFrom ();
      }

      if (i.getUntil ())
      {
        o << ::std::endl << "until: " << *i.getUntil ();
      }

      if (i.getDescription ())
      {
        o << ::std::endl << "description: " << *i.getDescription ();
      }

      if (i.getId ())
      {
        o << ::std::endl << "id: " << *i.getId ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const UserInput& i)
    {
      o << static_cast< const ::Xsd::Rpid::ActiveIdle& > (i);

      if (i.getIdleThreshold ())
      {
        o << ::std::endl << "idle-threshold: " << *i.getIdleThreshold ();
      }

      if (i.getLastInput ())
      {
        o << ::std::endl << "last-input: " << *i.getLastInput ();
      }

      if (i.getId ())
      {
        o << ::std::endl << "id: " << *i.getId ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Audio& i)
    {
      if (i.getNoisy ())
      {
        o << ::std::endl << "noisy: " << *i.getNoisy ();
      }

      if (i.getOk ())
      {
        o << ::std::endl << "ok: " << *i.getOk ();
      }

      if (i.getQuiet ())
      {
        o << ::std::endl << "quiet: " << *i.getQuiet ();
      }

      if (i.getUnknown ())
      {
        o << ::std::endl << "unknown: " << *i.getUnknown ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Video& i)
    {
      if (i.getToobright ())
      {
        o << ::std::endl << "toobright: " << *i.getToobright ();
      }

      if (i.getOk ())
      {
        o << ::std::endl << "ok: " << *i.getOk ();
      }

      if (i.getDark ())
      {
        o << ::std::endl << "dark: " << *i.getDark ();
      }

      if (i.getUnknown ())
      {
        o << ::std::endl << "unknown: " << *i.getUnknown ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Text& i)
    {
      if (i.getUncomfortable ())
      {
        o << ::std::endl << "uncomfortable: " << *i.getUncomfortable ();
      }

      if (i.getInappropriate ())
      {
        o << ::std::endl << "inappropriate: " << *i.getInappropriate ();
      }

      if (i.getOk ())
      {
        o << ::std::endl << "ok: " << *i.getOk ();
      }

      if (i.getUnknown ())
      {
        o << ::std::endl << "unknown: " << *i.getUnknown ();
      }

      return o;
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace Xsd
{
  namespace Rpid
  {
  }
}

namespace Xsd
{
  namespace Rpid
  {
    ::std::unique_ptr< ::Xsd::Rpid::Activities >
    parseActivities (const ::std::string& u,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Activities > (
        ::Xsd::Rpid::parseActivities (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Activities >
    parseActivities (const ::std::string& u,
                     ::Xsd::XmlSchema::ErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Activities > (
        ::Xsd::Rpid::parseActivities (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Activities >
    parseActivities (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Activities > (
        ::Xsd::Rpid::parseActivities (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Activities >
    parseActivities (::std::istream& is,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseActivities (isrc, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Activities >
    parseActivities (::std::istream& is,
                     ::Xsd::XmlSchema::ErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseActivities (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Activities >
    parseActivities (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseActivities (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Activities >
    parseActivities (::std::istream& is,
                     const ::std::string& sid,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseActivities (isrc, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Activities >
    parseActivities (::std::istream& is,
                     const ::std::string& sid,
                     ::Xsd::XmlSchema::ErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseActivities (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Activities >
    parseActivities (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseActivities (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Activities >
    parseActivities (::xercesc::InputSource& i,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Activities > (
        ::Xsd::Rpid::parseActivities (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Activities >
    parseActivities (::xercesc::InputSource& i,
                     ::Xsd::XmlSchema::ErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Activities > (
        ::Xsd::Rpid::parseActivities (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Activities >
    parseActivities (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Activities > (
        ::Xsd::Rpid::parseActivities (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Activities >
    parseActivities (const ::xercesc::DOMDocument& doc,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      if (f & ::Xsd::XmlSchema::Flags::keep_dom)
      {
        ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::Xsd::Rpid::Activities > (
          ::Xsd::Rpid::parseActivities (
            std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "activities" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        ::std::unique_ptr< ::Xsd::Rpid::Activities > r (
          ::xsd::cxx::tree::traits< ::Xsd::Rpid::Activities, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "activities",
        "urn:ietf:params:xml:ns:pidf:rpid");
    }

    ::std::unique_ptr< ::Xsd::Rpid::Activities >
    parseActivities (::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties&)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::Xsd::XmlSchema::Flags::keep_dom) &&
         !(f & ::Xsd::XmlSchema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::Xsd::XmlSchema::Flags::keep_dom)
        doc.setUserData (::Xsd::XmlSchema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "activities" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        ::std::unique_ptr< ::Xsd::Rpid::Activities > r (
          ::xsd::cxx::tree::traits< ::Xsd::Rpid::Activities, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "activities",
        "urn:ietf:params:xml:ns:pidf:rpid");
    }

    ::std::unique_ptr< ::Xsd::XmlSchema::Token >
    parseClass (const ::std::string& u,
                ::Xsd::XmlSchema::Flags f,
                const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::Xsd::XmlSchema::Token > (
        ::Xsd::Rpid::parseClass (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::XmlSchema::Token >
    parseClass (const ::std::string& u,
                ::Xsd::XmlSchema::ErrorHandler& h,
                ::Xsd::XmlSchema::Flags f,
                const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::XmlSchema::Token > (
        ::Xsd::Rpid::parseClass (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::XmlSchema::Token >
    parseClass (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::Xsd::XmlSchema::Flags f,
                const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::XmlSchema::Token > (
        ::Xsd::Rpid::parseClass (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::XmlSchema::Token >
    parseClass (::std::istream& is,
                ::Xsd::XmlSchema::Flags f,
                const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseClass (isrc, f, p);
    }

    ::std::unique_ptr< ::Xsd::XmlSchema::Token >
    parseClass (::std::istream& is,
                ::Xsd::XmlSchema::ErrorHandler& h,
                ::Xsd::XmlSchema::Flags f,
                const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseClass (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::XmlSchema::Token >
    parseClass (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::Xsd::XmlSchema::Flags f,
                const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseClass (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::XmlSchema::Token >
    parseClass (::std::istream& is,
                const ::std::string& sid,
                ::Xsd::XmlSchema::Flags f,
                const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseClass (isrc, f, p);
    }

    ::std::unique_ptr< ::Xsd::XmlSchema::Token >
    parseClass (::std::istream& is,
                const ::std::string& sid,
                ::Xsd::XmlSchema::ErrorHandler& h,
                ::Xsd::XmlSchema::Flags f,
                const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseClass (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::XmlSchema::Token >
    parseClass (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::Xsd::XmlSchema::Flags f,
                const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseClass (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::XmlSchema::Token >
    parseClass (::xercesc::InputSource& i,
                ::Xsd::XmlSchema::Flags f,
                const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::Xsd::XmlSchema::Token > (
        ::Xsd::Rpid::parseClass (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::XmlSchema::Token >
    parseClass (::xercesc::InputSource& i,
                ::Xsd::XmlSchema::ErrorHandler& h,
                ::Xsd::XmlSchema::Flags f,
                const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::XmlSchema::Token > (
        ::Xsd::Rpid::parseClass (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::XmlSchema::Token >
    parseClass (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::Xsd::XmlSchema::Flags f,
                const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::XmlSchema::Token > (
        ::Xsd::Rpid::parseClass (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::XmlSchema::Token >
    parseClass (const ::xercesc::DOMDocument& doc,
                ::Xsd::XmlSchema::Flags f,
                const ::Xsd::XmlSchema::Properties& p)
    {
      if (f & ::Xsd::XmlSchema::Flags::keep_dom)
      {
        ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::Xsd::XmlSchema::Token > (
          ::Xsd::Rpid::parseClass (
            std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "class" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        ::std::unique_ptr< ::Xsd::XmlSchema::Token > r (
          ::xsd::cxx::tree::traits< ::Xsd::XmlSchema::Token, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "class",
        "urn:ietf:params:xml:ns:pidf:rpid");
    }

    ::std::unique_ptr< ::Xsd::XmlSchema::Token >
    parseClass (::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                ::Xsd::XmlSchema::Flags f,
                const ::Xsd::XmlSchema::Properties&)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::Xsd::XmlSchema::Flags::keep_dom) &&
         !(f & ::Xsd::XmlSchema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::Xsd::XmlSchema::Flags::keep_dom)
        doc.setUserData (::Xsd::XmlSchema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "class" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        ::std::unique_ptr< ::Xsd::XmlSchema::Token > r (
          ::xsd::cxx::tree::traits< ::Xsd::XmlSchema::Token, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "class",
        "urn:ietf:params:xml:ns:pidf:rpid");
    }

    ::std::unique_ptr< ::Xsd::Rpid::Mood >
    parseMood (const ::std::string& u,
               ::Xsd::XmlSchema::Flags f,
               const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Mood > (
        ::Xsd::Rpid::parseMood (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Mood >
    parseMood (const ::std::string& u,
               ::Xsd::XmlSchema::ErrorHandler& h,
               ::Xsd::XmlSchema::Flags f,
               const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Mood > (
        ::Xsd::Rpid::parseMood (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Mood >
    parseMood (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::Xsd::XmlSchema::Flags f,
               const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Mood > (
        ::Xsd::Rpid::parseMood (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Mood >
    parseMood (::std::istream& is,
               ::Xsd::XmlSchema::Flags f,
               const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseMood (isrc, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Mood >
    parseMood (::std::istream& is,
               ::Xsd::XmlSchema::ErrorHandler& h,
               ::Xsd::XmlSchema::Flags f,
               const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseMood (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Mood >
    parseMood (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::Xsd::XmlSchema::Flags f,
               const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseMood (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Mood >
    parseMood (::std::istream& is,
               const ::std::string& sid,
               ::Xsd::XmlSchema::Flags f,
               const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseMood (isrc, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Mood >
    parseMood (::std::istream& is,
               const ::std::string& sid,
               ::Xsd::XmlSchema::ErrorHandler& h,
               ::Xsd::XmlSchema::Flags f,
               const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseMood (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Mood >
    parseMood (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::Xsd::XmlSchema::Flags f,
               const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseMood (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Mood >
    parseMood (::xercesc::InputSource& i,
               ::Xsd::XmlSchema::Flags f,
               const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Mood > (
        ::Xsd::Rpid::parseMood (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Mood >
    parseMood (::xercesc::InputSource& i,
               ::Xsd::XmlSchema::ErrorHandler& h,
               ::Xsd::XmlSchema::Flags f,
               const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Mood > (
        ::Xsd::Rpid::parseMood (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Mood >
    parseMood (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::Xsd::XmlSchema::Flags f,
               const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Mood > (
        ::Xsd::Rpid::parseMood (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Mood >
    parseMood (const ::xercesc::DOMDocument& doc,
               ::Xsd::XmlSchema::Flags f,
               const ::Xsd::XmlSchema::Properties& p)
    {
      if (f & ::Xsd::XmlSchema::Flags::keep_dom)
      {
        ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::Xsd::Rpid::Mood > (
          ::Xsd::Rpid::parseMood (
            std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "mood" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        ::std::unique_ptr< ::Xsd::Rpid::Mood > r (
          ::xsd::cxx::tree::traits< ::Xsd::Rpid::Mood, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "mood",
        "urn:ietf:params:xml:ns:pidf:rpid");
    }

    ::std::unique_ptr< ::Xsd::Rpid::Mood >
    parseMood (::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
               ::Xsd::XmlSchema::Flags f,
               const ::Xsd::XmlSchema::Properties&)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::Xsd::XmlSchema::Flags::keep_dom) &&
         !(f & ::Xsd::XmlSchema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::Xsd::XmlSchema::Flags::keep_dom)
        doc.setUserData (::Xsd::XmlSchema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "mood" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        ::std::unique_ptr< ::Xsd::Rpid::Mood > r (
          ::xsd::cxx::tree::traits< ::Xsd::Rpid::Mood, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "mood",
        "urn:ietf:params:xml:ns:pidf:rpid");
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceIs >
    parsePlaceIs (const ::std::string& u,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::Xsd::Rpid::PlaceIs > (
        ::Xsd::Rpid::parsePlaceIs (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceIs >
    parsePlaceIs (const ::std::string& u,
                  ::Xsd::XmlSchema::ErrorHandler& h,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::PlaceIs > (
        ::Xsd::Rpid::parsePlaceIs (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceIs >
    parsePlaceIs (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::PlaceIs > (
        ::Xsd::Rpid::parsePlaceIs (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceIs >
    parsePlaceIs (::std::istream& is,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parsePlaceIs (isrc, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceIs >
    parsePlaceIs (::std::istream& is,
                  ::Xsd::XmlSchema::ErrorHandler& h,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parsePlaceIs (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceIs >
    parsePlaceIs (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parsePlaceIs (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceIs >
    parsePlaceIs (::std::istream& is,
                  const ::std::string& sid,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parsePlaceIs (isrc, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceIs >
    parsePlaceIs (::std::istream& is,
                  const ::std::string& sid,
                  ::Xsd::XmlSchema::ErrorHandler& h,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parsePlaceIs (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceIs >
    parsePlaceIs (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parsePlaceIs (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceIs >
    parsePlaceIs (::xercesc::InputSource& i,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::Xsd::Rpid::PlaceIs > (
        ::Xsd::Rpid::parsePlaceIs (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceIs >
    parsePlaceIs (::xercesc::InputSource& i,
                  ::Xsd::XmlSchema::ErrorHandler& h,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::PlaceIs > (
        ::Xsd::Rpid::parsePlaceIs (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceIs >
    parsePlaceIs (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::PlaceIs > (
        ::Xsd::Rpid::parsePlaceIs (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceIs >
    parsePlaceIs (const ::xercesc::DOMDocument& doc,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      if (f & ::Xsd::XmlSchema::Flags::keep_dom)
      {
        ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::Xsd::Rpid::PlaceIs > (
          ::Xsd::Rpid::parsePlaceIs (
            std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "place-is" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        ::std::unique_ptr< ::Xsd::Rpid::PlaceIs > r (
          ::xsd::cxx::tree::traits< ::Xsd::Rpid::PlaceIs, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "place-is",
        "urn:ietf:params:xml:ns:pidf:rpid");
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceIs >
    parsePlaceIs (::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties&)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::Xsd::XmlSchema::Flags::keep_dom) &&
         !(f & ::Xsd::XmlSchema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::Xsd::XmlSchema::Flags::keep_dom)
        doc.setUserData (::Xsd::XmlSchema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "place-is" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        ::std::unique_ptr< ::Xsd::Rpid::PlaceIs > r (
          ::xsd::cxx::tree::traits< ::Xsd::Rpid::PlaceIs, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "place-is",
        "urn:ietf:params:xml:ns:pidf:rpid");
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceType >
    parsePlaceType (const ::std::string& u,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::Xsd::Rpid::PlaceType > (
        ::Xsd::Rpid::parsePlaceType (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceType >
    parsePlaceType (const ::std::string& u,
                    ::Xsd::XmlSchema::ErrorHandler& h,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::PlaceType > (
        ::Xsd::Rpid::parsePlaceType (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceType >
    parsePlaceType (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::PlaceType > (
        ::Xsd::Rpid::parsePlaceType (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceType >
    parsePlaceType (::std::istream& is,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parsePlaceType (isrc, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceType >
    parsePlaceType (::std::istream& is,
                    ::Xsd::XmlSchema::ErrorHandler& h,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parsePlaceType (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceType >
    parsePlaceType (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parsePlaceType (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceType >
    parsePlaceType (::std::istream& is,
                    const ::std::string& sid,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parsePlaceType (isrc, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceType >
    parsePlaceType (::std::istream& is,
                    const ::std::string& sid,
                    ::Xsd::XmlSchema::ErrorHandler& h,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parsePlaceType (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceType >
    parsePlaceType (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parsePlaceType (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceType >
    parsePlaceType (::xercesc::InputSource& i,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::Xsd::Rpid::PlaceType > (
        ::Xsd::Rpid::parsePlaceType (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceType >
    parsePlaceType (::xercesc::InputSource& i,
                    ::Xsd::XmlSchema::ErrorHandler& h,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::PlaceType > (
        ::Xsd::Rpid::parsePlaceType (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceType >
    parsePlaceType (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::PlaceType > (
        ::Xsd::Rpid::parsePlaceType (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceType >
    parsePlaceType (const ::xercesc::DOMDocument& doc,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      if (f & ::Xsd::XmlSchema::Flags::keep_dom)
      {
        ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::Xsd::Rpid::PlaceType > (
          ::Xsd::Rpid::parsePlaceType (
            std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "place-type" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        ::std::unique_ptr< ::Xsd::Rpid::PlaceType > r (
          ::xsd::cxx::tree::traits< ::Xsd::Rpid::PlaceType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "place-type",
        "urn:ietf:params:xml:ns:pidf:rpid");
    }

    ::std::unique_ptr< ::Xsd::Rpid::PlaceType >
    parsePlaceType (::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties&)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::Xsd::XmlSchema::Flags::keep_dom) &&
         !(f & ::Xsd::XmlSchema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::Xsd::XmlSchema::Flags::keep_dom)
        doc.setUserData (::Xsd::XmlSchema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "place-type" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        ::std::unique_ptr< ::Xsd::Rpid::PlaceType > r (
          ::xsd::cxx::tree::traits< ::Xsd::Rpid::PlaceType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "place-type",
        "urn:ietf:params:xml:ns:pidf:rpid");
    }

    ::std::unique_ptr< ::Xsd::Rpid::Privacy >
    parsePrivacy (const ::std::string& u,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Privacy > (
        ::Xsd::Rpid::parsePrivacy (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Privacy >
    parsePrivacy (const ::std::string& u,
                  ::Xsd::XmlSchema::ErrorHandler& h,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Privacy > (
        ::Xsd::Rpid::parsePrivacy (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Privacy >
    parsePrivacy (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Privacy > (
        ::Xsd::Rpid::parsePrivacy (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Privacy >
    parsePrivacy (::std::istream& is,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parsePrivacy (isrc, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Privacy >
    parsePrivacy (::std::istream& is,
                  ::Xsd::XmlSchema::ErrorHandler& h,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parsePrivacy (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Privacy >
    parsePrivacy (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parsePrivacy (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Privacy >
    parsePrivacy (::std::istream& is,
                  const ::std::string& sid,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parsePrivacy (isrc, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Privacy >
    parsePrivacy (::std::istream& is,
                  const ::std::string& sid,
                  ::Xsd::XmlSchema::ErrorHandler& h,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parsePrivacy (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Privacy >
    parsePrivacy (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parsePrivacy (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Privacy >
    parsePrivacy (::xercesc::InputSource& i,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Privacy > (
        ::Xsd::Rpid::parsePrivacy (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Privacy >
    parsePrivacy (::xercesc::InputSource& i,
                  ::Xsd::XmlSchema::ErrorHandler& h,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Privacy > (
        ::Xsd::Rpid::parsePrivacy (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Privacy >
    parsePrivacy (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Privacy > (
        ::Xsd::Rpid::parsePrivacy (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Privacy >
    parsePrivacy (const ::xercesc::DOMDocument& doc,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties& p)
    {
      if (f & ::Xsd::XmlSchema::Flags::keep_dom)
      {
        ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::Xsd::Rpid::Privacy > (
          ::Xsd::Rpid::parsePrivacy (
            std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "privacy" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        ::std::unique_ptr< ::Xsd::Rpid::Privacy > r (
          ::xsd::cxx::tree::traits< ::Xsd::Rpid::Privacy, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "privacy",
        "urn:ietf:params:xml:ns:pidf:rpid");
    }

    ::std::unique_ptr< ::Xsd::Rpid::Privacy >
    parsePrivacy (::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                  ::Xsd::XmlSchema::Flags f,
                  const ::Xsd::XmlSchema::Properties&)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::Xsd::XmlSchema::Flags::keep_dom) &&
         !(f & ::Xsd::XmlSchema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::Xsd::XmlSchema::Flags::keep_dom)
        doc.setUserData (::Xsd::XmlSchema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "privacy" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        ::std::unique_ptr< ::Xsd::Rpid::Privacy > r (
          ::xsd::cxx::tree::traits< ::Xsd::Rpid::Privacy, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "privacy",
        "urn:ietf:params:xml:ns:pidf:rpid");
    }

    ::std::unique_ptr< ::Xsd::Rpid::Relationship >
    parseRelationship (const ::std::string& u,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Relationship > (
        ::Xsd::Rpid::parseRelationship (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Relationship >
    parseRelationship (const ::std::string& u,
                       ::Xsd::XmlSchema::ErrorHandler& h,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Relationship > (
        ::Xsd::Rpid::parseRelationship (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Relationship >
    parseRelationship (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Relationship > (
        ::Xsd::Rpid::parseRelationship (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Relationship >
    parseRelationship (::std::istream& is,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseRelationship (isrc, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Relationship >
    parseRelationship (::std::istream& is,
                       ::Xsd::XmlSchema::ErrorHandler& h,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseRelationship (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Relationship >
    parseRelationship (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseRelationship (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Relationship >
    parseRelationship (::std::istream& is,
                       const ::std::string& sid,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseRelationship (isrc, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Relationship >
    parseRelationship (::std::istream& is,
                       const ::std::string& sid,
                       ::Xsd::XmlSchema::ErrorHandler& h,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseRelationship (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Relationship >
    parseRelationship (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseRelationship (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Relationship >
    parseRelationship (::xercesc::InputSource& i,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Relationship > (
        ::Xsd::Rpid::parseRelationship (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Relationship >
    parseRelationship (::xercesc::InputSource& i,
                       ::Xsd::XmlSchema::ErrorHandler& h,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Relationship > (
        ::Xsd::Rpid::parseRelationship (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Relationship >
    parseRelationship (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Relationship > (
        ::Xsd::Rpid::parseRelationship (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Relationship >
    parseRelationship (const ::xercesc::DOMDocument& doc,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      if (f & ::Xsd::XmlSchema::Flags::keep_dom)
      {
        ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::Xsd::Rpid::Relationship > (
          ::Xsd::Rpid::parseRelationship (
            std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "relationship" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        ::std::unique_ptr< ::Xsd::Rpid::Relationship > r (
          ::xsd::cxx::tree::traits< ::Xsd::Rpid::Relationship, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "relationship",
        "urn:ietf:params:xml:ns:pidf:rpid");
    }

    ::std::unique_ptr< ::Xsd::Rpid::Relationship >
    parseRelationship (::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties&)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::Xsd::XmlSchema::Flags::keep_dom) &&
         !(f & ::Xsd::XmlSchema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::Xsd::XmlSchema::Flags::keep_dom)
        doc.setUserData (::Xsd::XmlSchema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "relationship" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        ::std::unique_ptr< ::Xsd::Rpid::Relationship > r (
          ::xsd::cxx::tree::traits< ::Xsd::Rpid::Relationship, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "relationship",
        "urn:ietf:params:xml:ns:pidf:rpid");
    }

    ::std::unique_ptr< ::Xsd::Rpid::ServiceClass >
    parseServiceClass (const ::std::string& u,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::Xsd::Rpid::ServiceClass > (
        ::Xsd::Rpid::parseServiceClass (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::ServiceClass >
    parseServiceClass (const ::std::string& u,
                       ::Xsd::XmlSchema::ErrorHandler& h,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::ServiceClass > (
        ::Xsd::Rpid::parseServiceClass (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::ServiceClass >
    parseServiceClass (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::ServiceClass > (
        ::Xsd::Rpid::parseServiceClass (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::ServiceClass >
    parseServiceClass (::std::istream& is,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseServiceClass (isrc, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::ServiceClass >
    parseServiceClass (::std::istream& is,
                       ::Xsd::XmlSchema::ErrorHandler& h,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseServiceClass (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::ServiceClass >
    parseServiceClass (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseServiceClass (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::ServiceClass >
    parseServiceClass (::std::istream& is,
                       const ::std::string& sid,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseServiceClass (isrc, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::ServiceClass >
    parseServiceClass (::std::istream& is,
                       const ::std::string& sid,
                       ::Xsd::XmlSchema::ErrorHandler& h,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseServiceClass (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::ServiceClass >
    parseServiceClass (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseServiceClass (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::ServiceClass >
    parseServiceClass (::xercesc::InputSource& i,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::Xsd::Rpid::ServiceClass > (
        ::Xsd::Rpid::parseServiceClass (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::ServiceClass >
    parseServiceClass (::xercesc::InputSource& i,
                       ::Xsd::XmlSchema::ErrorHandler& h,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::ServiceClass > (
        ::Xsd::Rpid::parseServiceClass (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::ServiceClass >
    parseServiceClass (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::ServiceClass > (
        ::Xsd::Rpid::parseServiceClass (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::ServiceClass >
    parseServiceClass (const ::xercesc::DOMDocument& doc,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties& p)
    {
      if (f & ::Xsd::XmlSchema::Flags::keep_dom)
      {
        ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::Xsd::Rpid::ServiceClass > (
          ::Xsd::Rpid::parseServiceClass (
            std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "service-class" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        ::std::unique_ptr< ::Xsd::Rpid::ServiceClass > r (
          ::xsd::cxx::tree::traits< ::Xsd::Rpid::ServiceClass, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "service-class",
        "urn:ietf:params:xml:ns:pidf:rpid");
    }

    ::std::unique_ptr< ::Xsd::Rpid::ServiceClass >
    parseServiceClass (::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                       ::Xsd::XmlSchema::Flags f,
                       const ::Xsd::XmlSchema::Properties&)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::Xsd::XmlSchema::Flags::keep_dom) &&
         !(f & ::Xsd::XmlSchema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::Xsd::XmlSchema::Flags::keep_dom)
        doc.setUserData (::Xsd::XmlSchema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "service-class" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        ::std::unique_ptr< ::Xsd::Rpid::ServiceClass > r (
          ::xsd::cxx::tree::traits< ::Xsd::Rpid::ServiceClass, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "service-class",
        "urn:ietf:params:xml:ns:pidf:rpid");
    }

    ::std::unique_ptr< ::Xsd::Rpid::Sphere >
    parseSphere (const ::std::string& u,
                 ::Xsd::XmlSchema::Flags f,
                 const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Sphere > (
        ::Xsd::Rpid::parseSphere (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Sphere >
    parseSphere (const ::std::string& u,
                 ::Xsd::XmlSchema::ErrorHandler& h,
                 ::Xsd::XmlSchema::Flags f,
                 const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Sphere > (
        ::Xsd::Rpid::parseSphere (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Sphere >
    parseSphere (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::Xsd::XmlSchema::Flags f,
                 const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Sphere > (
        ::Xsd::Rpid::parseSphere (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Sphere >
    parseSphere (::std::istream& is,
                 ::Xsd::XmlSchema::Flags f,
                 const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseSphere (isrc, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Sphere >
    parseSphere (::std::istream& is,
                 ::Xsd::XmlSchema::ErrorHandler& h,
                 ::Xsd::XmlSchema::Flags f,
                 const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseSphere (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Sphere >
    parseSphere (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::Xsd::XmlSchema::Flags f,
                 const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseSphere (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Sphere >
    parseSphere (::std::istream& is,
                 const ::std::string& sid,
                 ::Xsd::XmlSchema::Flags f,
                 const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseSphere (isrc, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Sphere >
    parseSphere (::std::istream& is,
                 const ::std::string& sid,
                 ::Xsd::XmlSchema::ErrorHandler& h,
                 ::Xsd::XmlSchema::Flags f,
                 const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseSphere (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Sphere >
    parseSphere (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::Xsd::XmlSchema::Flags f,
                 const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseSphere (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::Sphere >
    parseSphere (::xercesc::InputSource& i,
                 ::Xsd::XmlSchema::Flags f,
                 const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Sphere > (
        ::Xsd::Rpid::parseSphere (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Sphere >
    parseSphere (::xercesc::InputSource& i,
                 ::Xsd::XmlSchema::ErrorHandler& h,
                 ::Xsd::XmlSchema::Flags f,
                 const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Sphere > (
        ::Xsd::Rpid::parseSphere (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Sphere >
    parseSphere (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::Xsd::XmlSchema::Flags f,
                 const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::Sphere > (
        ::Xsd::Rpid::parseSphere (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::Sphere >
    parseSphere (const ::xercesc::DOMDocument& doc,
                 ::Xsd::XmlSchema::Flags f,
                 const ::Xsd::XmlSchema::Properties& p)
    {
      if (f & ::Xsd::XmlSchema::Flags::keep_dom)
      {
        ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::Xsd::Rpid::Sphere > (
          ::Xsd::Rpid::parseSphere (
            std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "sphere" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        ::std::unique_ptr< ::Xsd::Rpid::Sphere > r (
          ::xsd::cxx::tree::traits< ::Xsd::Rpid::Sphere, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "sphere",
        "urn:ietf:params:xml:ns:pidf:rpid");
    }

    ::std::unique_ptr< ::Xsd::Rpid::Sphere >
    parseSphere (::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                 ::Xsd::XmlSchema::Flags f,
                 const ::Xsd::XmlSchema::Properties&)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::Xsd::XmlSchema::Flags::keep_dom) &&
         !(f & ::Xsd::XmlSchema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::Xsd::XmlSchema::Flags::keep_dom)
        doc.setUserData (::Xsd::XmlSchema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "sphere" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        ::std::unique_ptr< ::Xsd::Rpid::Sphere > r (
          ::xsd::cxx::tree::traits< ::Xsd::Rpid::Sphere, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "sphere",
        "urn:ietf:params:xml:ns:pidf:rpid");
    }

    ::std::unique_ptr< ::Xsd::Rpid::StatusIcon >
    parseStatusIcon (const ::std::string& u,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::Xsd::Rpid::StatusIcon > (
        ::Xsd::Rpid::parseStatusIcon (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::StatusIcon >
    parseStatusIcon (const ::std::string& u,
                     ::Xsd::XmlSchema::ErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::StatusIcon > (
        ::Xsd::Rpid::parseStatusIcon (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::StatusIcon >
    parseStatusIcon (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::StatusIcon > (
        ::Xsd::Rpid::parseStatusIcon (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::StatusIcon >
    parseStatusIcon (::std::istream& is,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseStatusIcon (isrc, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::StatusIcon >
    parseStatusIcon (::std::istream& is,
                     ::Xsd::XmlSchema::ErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseStatusIcon (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::StatusIcon >
    parseStatusIcon (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseStatusIcon (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::StatusIcon >
    parseStatusIcon (::std::istream& is,
                     const ::std::string& sid,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseStatusIcon (isrc, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::StatusIcon >
    parseStatusIcon (::std::istream& is,
                     const ::std::string& sid,
                     ::Xsd::XmlSchema::ErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseStatusIcon (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::StatusIcon >
    parseStatusIcon (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseStatusIcon (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::StatusIcon >
    parseStatusIcon (::xercesc::InputSource& i,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::Xsd::Rpid::StatusIcon > (
        ::Xsd::Rpid::parseStatusIcon (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::StatusIcon >
    parseStatusIcon (::xercesc::InputSource& i,
                     ::Xsd::XmlSchema::ErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::StatusIcon > (
        ::Xsd::Rpid::parseStatusIcon (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::StatusIcon >
    parseStatusIcon (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::StatusIcon > (
        ::Xsd::Rpid::parseStatusIcon (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::StatusIcon >
    parseStatusIcon (const ::xercesc::DOMDocument& doc,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      if (f & ::Xsd::XmlSchema::Flags::keep_dom)
      {
        ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::Xsd::Rpid::StatusIcon > (
          ::Xsd::Rpid::parseStatusIcon (
            std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "status-icon" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        ::std::unique_ptr< ::Xsd::Rpid::StatusIcon > r (
          ::xsd::cxx::tree::traits< ::Xsd::Rpid::StatusIcon, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "status-icon",
        "urn:ietf:params:xml:ns:pidf:rpid");
    }

    ::std::unique_ptr< ::Xsd::Rpid::StatusIcon >
    parseStatusIcon (::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties&)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::Xsd::XmlSchema::Flags::keep_dom) &&
         !(f & ::Xsd::XmlSchema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::Xsd::XmlSchema::Flags::keep_dom)
        doc.setUserData (::Xsd::XmlSchema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "status-icon" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        ::std::unique_ptr< ::Xsd::Rpid::StatusIcon > r (
          ::xsd::cxx::tree::traits< ::Xsd::Rpid::StatusIcon, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "status-icon",
        "urn:ietf:params:xml:ns:pidf:rpid");
    }

    ::std::unique_ptr< ::Xsd::Rpid::TimeOffset >
    parseTimeOffset (const ::std::string& u,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::Xsd::Rpid::TimeOffset > (
        ::Xsd::Rpid::parseTimeOffset (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::TimeOffset >
    parseTimeOffset (const ::std::string& u,
                     ::Xsd::XmlSchema::ErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::TimeOffset > (
        ::Xsd::Rpid::parseTimeOffset (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::TimeOffset >
    parseTimeOffset (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::TimeOffset > (
        ::Xsd::Rpid::parseTimeOffset (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::TimeOffset >
    parseTimeOffset (::std::istream& is,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseTimeOffset (isrc, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::TimeOffset >
    parseTimeOffset (::std::istream& is,
                     ::Xsd::XmlSchema::ErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseTimeOffset (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::TimeOffset >
    parseTimeOffset (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseTimeOffset (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::TimeOffset >
    parseTimeOffset (::std::istream& is,
                     const ::std::string& sid,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseTimeOffset (isrc, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::TimeOffset >
    parseTimeOffset (::std::istream& is,
                     const ::std::string& sid,
                     ::Xsd::XmlSchema::ErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseTimeOffset (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::TimeOffset >
    parseTimeOffset (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseTimeOffset (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::TimeOffset >
    parseTimeOffset (::xercesc::InputSource& i,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::Xsd::Rpid::TimeOffset > (
        ::Xsd::Rpid::parseTimeOffset (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::TimeOffset >
    parseTimeOffset (::xercesc::InputSource& i,
                     ::Xsd::XmlSchema::ErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::TimeOffset > (
        ::Xsd::Rpid::parseTimeOffset (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::TimeOffset >
    parseTimeOffset (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::TimeOffset > (
        ::Xsd::Rpid::parseTimeOffset (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::TimeOffset >
    parseTimeOffset (const ::xercesc::DOMDocument& doc,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
    {
      if (f & ::Xsd::XmlSchema::Flags::keep_dom)
      {
        ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::Xsd::Rpid::TimeOffset > (
          ::Xsd::Rpid::parseTimeOffset (
            std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "time-offset" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        ::std::unique_ptr< ::Xsd::Rpid::TimeOffset > r (
          ::xsd::cxx::tree::traits< ::Xsd::Rpid::TimeOffset, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "time-offset",
        "urn:ietf:params:xml:ns:pidf:rpid");
    }

    ::std::unique_ptr< ::Xsd::Rpid::TimeOffset >
    parseTimeOffset (::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties&)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::Xsd::XmlSchema::Flags::keep_dom) &&
         !(f & ::Xsd::XmlSchema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::Xsd::XmlSchema::Flags::keep_dom)
        doc.setUserData (::Xsd::XmlSchema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "time-offset" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        ::std::unique_ptr< ::Xsd::Rpid::TimeOffset > r (
          ::xsd::cxx::tree::traits< ::Xsd::Rpid::TimeOffset, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "time-offset",
        "urn:ietf:params:xml:ns:pidf:rpid");
    }

    ::std::unique_ptr< ::Xsd::Rpid::UserInput >
    parseUserInput (const ::std::string& u,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::Xsd::Rpid::UserInput > (
        ::Xsd::Rpid::parseUserInput (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::UserInput >
    parseUserInput (const ::std::string& u,
                    ::Xsd::XmlSchema::ErrorHandler& h,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::UserInput > (
        ::Xsd::Rpid::parseUserInput (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::UserInput >
    parseUserInput (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::UserInput > (
        ::Xsd::Rpid::parseUserInput (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::UserInput >
    parseUserInput (::std::istream& is,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseUserInput (isrc, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::UserInput >
    parseUserInput (::std::istream& is,
                    ::Xsd::XmlSchema::ErrorHandler& h,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseUserInput (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::UserInput >
    parseUserInput (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::Xsd::Rpid::parseUserInput (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::UserInput >
    parseUserInput (::std::istream& is,
                    const ::std::string& sid,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseUserInput (isrc, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::UserInput >
    parseUserInput (::std::istream& is,
                    const ::std::string& sid,
                    ::Xsd::XmlSchema::ErrorHandler& h,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
        (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseUserInput (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::UserInput >
    parseUserInput (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::Xsd::Rpid::parseUserInput (isrc, h, f, p);
    }

    ::std::unique_ptr< ::Xsd::Rpid::UserInput >
    parseUserInput (::xercesc::InputSource& i,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::Xsd::Rpid::UserInput > (
        ::Xsd::Rpid::parseUserInput (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::UserInput >
    parseUserInput (::xercesc::InputSource& i,
                    ::Xsd::XmlSchema::ErrorHandler& h,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::UserInput > (
        ::Xsd::Rpid::parseUserInput (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::UserInput >
    parseUserInput (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::Xsd::Rpid::UserInput > (
        ::Xsd::Rpid::parseUserInput (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::Xsd::Rpid::UserInput >
    parseUserInput (const ::xercesc::DOMDocument& doc,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
    {
      if (f & ::Xsd::XmlSchema::Flags::keep_dom)
      {
        ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::Xsd::Rpid::UserInput > (
          ::Xsd::Rpid::parseUserInput (
            std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "user-input" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        ::std::unique_ptr< ::Xsd::Rpid::UserInput > r (
          ::xsd::cxx::tree::traits< ::Xsd::Rpid::UserInput, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "user-input",
        "urn:ietf:params:xml:ns:pidf:rpid");
    }

    ::std::unique_ptr< ::Xsd::Rpid::UserInput >
    parseUserInput (::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties&)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::Xsd::XmlSchema::Flags::keep_dom) &&
         !(f & ::Xsd::XmlSchema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::Xsd::XmlSchema::Flags::keep_dom)
        doc.setUserData (::Xsd::XmlSchema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "user-input" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        ::std::unique_ptr< ::Xsd::Rpid::UserInput > r (
          ::xsd::cxx::tree::traits< ::Xsd::Rpid::UserInput, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "user-input",
        "urn:ietf:params:xml:ns:pidf:rpid");
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace Xsd
{
  namespace Rpid
  {
    void
    operator<< (::xercesc::DOMElement& e, const Timestamp_t& i)
    {
      e << static_cast< const ::Xsd::XmlSchema::DateTime& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const Timestamp_t& i)
    {
      a << static_cast< const ::Xsd::XmlSchema::DateTime& > (i);
    }

    void
    operator<< (::Xsd::XmlSchema::ListStream& l,
                const Timestamp_t& i)
    {
      l << static_cast< const ::Xsd::XmlSchema::DateTime& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const DeviceID_t& i)
    {
      e << static_cast< const ::Xsd::XmlSchema::Uri& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DeviceID_t& i)
    {
      a << static_cast< const ::Xsd::XmlSchema::Uri& > (i);
    }

    void
    operator<< (::Xsd::XmlSchema::ListStream& l,
                const DeviceID_t& i)
    {
      l << static_cast< const ::Xsd::XmlSchema::Uri& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const Note_t& i)
    {
      e << static_cast< const ::Xsd::XmlSchema::String& > (i);

      // lang
      //
      if (i.getLang ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "lang",
            "http://www.w3.org/XML/1998/namespace",
            e));

        a << *i.getLang ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const Empty& i)
    {
      e << static_cast< const ::Xsd::XmlSchema::Type& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr&, const Empty&)
    {
    }

    void
    operator<< (::Xsd::XmlSchema::ListStream&,
                const Empty&)
    {
    }
  }
}

namespace Xsd
{
  namespace Rpid
  {
    void
    operator<< (::xercesc::DOMElement& e, const ActiveIdle& i)
    {
      e << static_cast< const ::Xsd::XmlSchema::String& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const ActiveIdle& i)
    {
      a << static_cast< const ::Xsd::XmlSchema::String& > (i);
    }

    void
    operator<< (::Xsd::XmlSchema::ListStream& l,
                const ActiveIdle& i)
    {
      l << static_cast< const ::Xsd::XmlSchema::String& > (i);
    }

    void
    serializeActivities (::std::ostream& o,
                         const ::Xsd::Rpid::Activities& s,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::Xsd::XmlSchema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeActivities (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeActivities (::std::ostream& o,
                         const ::Xsd::Rpid::Activities& s,
                         ::Xsd::XmlSchema::ErrorHandler& h,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::Xsd::XmlSchema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeActivities (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeActivities (::std::ostream& o,
                         const ::Xsd::Rpid::Activities& s,
                         ::xercesc::DOMErrorHandler& h,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeActivities (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeActivities (::xercesc::XMLFormatTarget& t,
                         const ::Xsd::Rpid::Activities& s,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeActivities (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeActivities (::xercesc::XMLFormatTarget& t,
                         const ::Xsd::Rpid::Activities& s,
                         ::Xsd::XmlSchema::ErrorHandler& h,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeActivities (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeActivities (::xercesc::XMLFormatTarget& t,
                         const ::Xsd::Rpid::Activities& s,
                         ::xercesc::DOMErrorHandler& h,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeActivities (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeActivities (::xercesc::DOMDocument& d,
                         const ::Xsd::Rpid::Activities& s,
                         ::Xsd::XmlSchema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "activities" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "activities",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }
    }

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializeActivities (const ::Xsd::Rpid::Activities& s,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "activities",
          "urn:ietf:params:xml:ns:pidf:rpid",
          m, f));

      ::Xsd::Rpid::serializeActivities (*d, s, f);
      return d;
    }

    void
    serializeClass (::std::ostream& o,
                    const ::Xsd::XmlSchema::Token& s,
                    const ::Xsd::XmlSchema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::Xsd::XmlSchema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeClass (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeClass (::std::ostream& o,
                    const ::Xsd::XmlSchema::Token& s,
                    ::Xsd::XmlSchema::ErrorHandler& h,
                    const ::Xsd::XmlSchema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::Xsd::XmlSchema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeClass (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeClass (::std::ostream& o,
                    const ::Xsd::XmlSchema::Token& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::Xsd::XmlSchema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeClass (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeClass (::xercesc::XMLFormatTarget& t,
                    const ::Xsd::XmlSchema::Token& s,
                    const ::Xsd::XmlSchema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeClass (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeClass (::xercesc::XMLFormatTarget& t,
                    const ::Xsd::XmlSchema::Token& s,
                    ::Xsd::XmlSchema::ErrorHandler& h,
                    const ::Xsd::XmlSchema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeClass (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeClass (::xercesc::XMLFormatTarget& t,
                    const ::Xsd::XmlSchema::Token& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::Xsd::XmlSchema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeClass (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeClass (::xercesc::DOMDocument& d,
                    const ::Xsd::XmlSchema::Token& s,
                    ::Xsd::XmlSchema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "class" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "class",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }
    }

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializeClass (const ::Xsd::XmlSchema::Token& s,
                    const ::Xsd::XmlSchema::NamespaceInfomap& m,
                    ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "class",
          "urn:ietf:params:xml:ns:pidf:rpid",
          m, f));

      ::Xsd::Rpid::serializeClass (*d, s, f);
      return d;
    }

    void
    serializeMood (::std::ostream& o,
                   const ::Xsd::Rpid::Mood& s,
                   const ::Xsd::XmlSchema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::Xsd::XmlSchema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeMood (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeMood (::std::ostream& o,
                   const ::Xsd::Rpid::Mood& s,
                   ::Xsd::XmlSchema::ErrorHandler& h,
                   const ::Xsd::XmlSchema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::Xsd::XmlSchema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeMood (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeMood (::std::ostream& o,
                   const ::Xsd::Rpid::Mood& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::Xsd::XmlSchema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeMood (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeMood (::xercesc::XMLFormatTarget& t,
                   const ::Xsd::Rpid::Mood& s,
                   const ::Xsd::XmlSchema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeMood (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeMood (::xercesc::XMLFormatTarget& t,
                   const ::Xsd::Rpid::Mood& s,
                   ::Xsd::XmlSchema::ErrorHandler& h,
                   const ::Xsd::XmlSchema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeMood (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeMood (::xercesc::XMLFormatTarget& t,
                   const ::Xsd::Rpid::Mood& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::Xsd::XmlSchema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeMood (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeMood (::xercesc::DOMDocument& d,
                   const ::Xsd::Rpid::Mood& s,
                   ::Xsd::XmlSchema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "mood" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "mood",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }
    }

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializeMood (const ::Xsd::Rpid::Mood& s,
                   const ::Xsd::XmlSchema::NamespaceInfomap& m,
                   ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "mood",
          "urn:ietf:params:xml:ns:pidf:rpid",
          m, f));

      ::Xsd::Rpid::serializeMood (*d, s, f);
      return d;
    }

    void
    serializePlaceIs (::std::ostream& o,
                      const ::Xsd::Rpid::PlaceIs& s,
                      const ::Xsd::XmlSchema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::Xsd::XmlSchema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializePlaceIs (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializePlaceIs (::std::ostream& o,
                      const ::Xsd::Rpid::PlaceIs& s,
                      ::Xsd::XmlSchema::ErrorHandler& h,
                      const ::Xsd::XmlSchema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::Xsd::XmlSchema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializePlaceIs (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializePlaceIs (::std::ostream& o,
                      const ::Xsd::Rpid::PlaceIs& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::Xsd::XmlSchema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializePlaceIs (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializePlaceIs (::xercesc::XMLFormatTarget& t,
                      const ::Xsd::Rpid::PlaceIs& s,
                      const ::Xsd::XmlSchema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializePlaceIs (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializePlaceIs (::xercesc::XMLFormatTarget& t,
                      const ::Xsd::Rpid::PlaceIs& s,
                      ::Xsd::XmlSchema::ErrorHandler& h,
                      const ::Xsd::XmlSchema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializePlaceIs (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializePlaceIs (::xercesc::XMLFormatTarget& t,
                      const ::Xsd::Rpid::PlaceIs& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::Xsd::XmlSchema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializePlaceIs (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializePlaceIs (::xercesc::DOMDocument& d,
                      const ::Xsd::Rpid::PlaceIs& s,
                      ::Xsd::XmlSchema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "place-is" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "place-is",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }
    }

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializePlaceIs (const ::Xsd::Rpid::PlaceIs& s,
                      const ::Xsd::XmlSchema::NamespaceInfomap& m,
                      ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "place-is",
          "urn:ietf:params:xml:ns:pidf:rpid",
          m, f));

      ::Xsd::Rpid::serializePlaceIs (*d, s, f);
      return d;
    }

    void
    serializePlaceType (::std::ostream& o,
                        const ::Xsd::Rpid::PlaceType& s,
                        const ::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::Xsd::XmlSchema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializePlaceType (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializePlaceType (::std::ostream& o,
                        const ::Xsd::Rpid::PlaceType& s,
                        ::Xsd::XmlSchema::ErrorHandler& h,
                        const ::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::Xsd::XmlSchema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializePlaceType (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializePlaceType (::std::ostream& o,
                        const ::Xsd::Rpid::PlaceType& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializePlaceType (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializePlaceType (::xercesc::XMLFormatTarget& t,
                        const ::Xsd::Rpid::PlaceType& s,
                        const ::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializePlaceType (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializePlaceType (::xercesc::XMLFormatTarget& t,
                        const ::Xsd::Rpid::PlaceType& s,
                        ::Xsd::XmlSchema::ErrorHandler& h,
                        const ::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializePlaceType (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializePlaceType (::xercesc::XMLFormatTarget& t,
                        const ::Xsd::Rpid::PlaceType& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializePlaceType (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializePlaceType (::xercesc::DOMDocument& d,
                        const ::Xsd::Rpid::PlaceType& s,
                        ::Xsd::XmlSchema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "place-type" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "place-type",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }
    }

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializePlaceType (const ::Xsd::Rpid::PlaceType& s,
                        const ::Xsd::XmlSchema::NamespaceInfomap& m,
                        ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "place-type",
          "urn:ietf:params:xml:ns:pidf:rpid",
          m, f));

      ::Xsd::Rpid::serializePlaceType (*d, s, f);
      return d;
    }

    void
    serializePrivacy (::std::ostream& o,
                      const ::Xsd::Rpid::Privacy& s,
                      const ::Xsd::XmlSchema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::Xsd::XmlSchema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializePrivacy (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializePrivacy (::std::ostream& o,
                      const ::Xsd::Rpid::Privacy& s,
                      ::Xsd::XmlSchema::ErrorHandler& h,
                      const ::Xsd::XmlSchema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::Xsd::XmlSchema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializePrivacy (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializePrivacy (::std::ostream& o,
                      const ::Xsd::Rpid::Privacy& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::Xsd::XmlSchema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializePrivacy (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializePrivacy (::xercesc::XMLFormatTarget& t,
                      const ::Xsd::Rpid::Privacy& s,
                      const ::Xsd::XmlSchema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializePrivacy (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializePrivacy (::xercesc::XMLFormatTarget& t,
                      const ::Xsd::Rpid::Privacy& s,
                      ::Xsd::XmlSchema::ErrorHandler& h,
                      const ::Xsd::XmlSchema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializePrivacy (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializePrivacy (::xercesc::XMLFormatTarget& t,
                      const ::Xsd::Rpid::Privacy& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::Xsd::XmlSchema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializePrivacy (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializePrivacy (::xercesc::DOMDocument& d,
                      const ::Xsd::Rpid::Privacy& s,
                      ::Xsd::XmlSchema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "privacy" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "privacy",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }
    }

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializePrivacy (const ::Xsd::Rpid::Privacy& s,
                      const ::Xsd::XmlSchema::NamespaceInfomap& m,
                      ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "privacy",
          "urn:ietf:params:xml:ns:pidf:rpid",
          m, f));

      ::Xsd::Rpid::serializePrivacy (*d, s, f);
      return d;
    }

    void
    serializeRelationship (::std::ostream& o,
                           const ::Xsd::Rpid::Relationship& s,
                           const ::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::Xsd::XmlSchema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeRelationship (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeRelationship (::std::ostream& o,
                           const ::Xsd::Rpid::Relationship& s,
                           ::Xsd::XmlSchema::ErrorHandler& h,
                           const ::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::Xsd::XmlSchema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeRelationship (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeRelationship (::std::ostream& o,
                           const ::Xsd::Rpid::Relationship& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeRelationship (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeRelationship (::xercesc::XMLFormatTarget& t,
                           const ::Xsd::Rpid::Relationship& s,
                           const ::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeRelationship (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeRelationship (::xercesc::XMLFormatTarget& t,
                           const ::Xsd::Rpid::Relationship& s,
                           ::Xsd::XmlSchema::ErrorHandler& h,
                           const ::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeRelationship (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeRelationship (::xercesc::XMLFormatTarget& t,
                           const ::Xsd::Rpid::Relationship& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeRelationship (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeRelationship (::xercesc::DOMDocument& d,
                           const ::Xsd::Rpid::Relationship& s,
                           ::Xsd::XmlSchema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "relationship" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "relationship",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }
    }

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializeRelationship (const ::Xsd::Rpid::Relationship& s,
                           const ::Xsd::XmlSchema::NamespaceInfomap& m,
                           ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "relationship",
          "urn:ietf:params:xml:ns:pidf:rpid",
          m, f));

      ::Xsd::Rpid::serializeRelationship (*d, s, f);
      return d;
    }

    void
    serializeServiceClass (::std::ostream& o,
                           const ::Xsd::Rpid::ServiceClass& s,
                           const ::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::Xsd::XmlSchema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeServiceClass (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeServiceClass (::std::ostream& o,
                           const ::Xsd::Rpid::ServiceClass& s,
                           ::Xsd::XmlSchema::ErrorHandler& h,
                           const ::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::Xsd::XmlSchema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeServiceClass (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeServiceClass (::std::ostream& o,
                           const ::Xsd::Rpid::ServiceClass& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeServiceClass (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeServiceClass (::xercesc::XMLFormatTarget& t,
                           const ::Xsd::Rpid::ServiceClass& s,
                           const ::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeServiceClass (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeServiceClass (::xercesc::XMLFormatTarget& t,
                           const ::Xsd::Rpid::ServiceClass& s,
                           ::Xsd::XmlSchema::ErrorHandler& h,
                           const ::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeServiceClass (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeServiceClass (::xercesc::XMLFormatTarget& t,
                           const ::Xsd::Rpid::ServiceClass& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeServiceClass (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeServiceClass (::xercesc::DOMDocument& d,
                           const ::Xsd::Rpid::ServiceClass& s,
                           ::Xsd::XmlSchema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "service-class" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "service-class",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }
    }

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializeServiceClass (const ::Xsd::Rpid::ServiceClass& s,
                           const ::Xsd::XmlSchema::NamespaceInfomap& m,
                           ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "service-class",
          "urn:ietf:params:xml:ns:pidf:rpid",
          m, f));

      ::Xsd::Rpid::serializeServiceClass (*d, s, f);
      return d;
    }

    void
    serializeSphere (::std::ostream& o,
                     const ::Xsd::Rpid::Sphere& s,
                     const ::Xsd::XmlSchema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::Xsd::XmlSchema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeSphere (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeSphere (::std::ostream& o,
                     const ::Xsd::Rpid::Sphere& s,
                     ::Xsd::XmlSchema::ErrorHandler& h,
                     const ::Xsd::XmlSchema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::Xsd::XmlSchema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeSphere (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeSphere (::std::ostream& o,
                     const ::Xsd::Rpid::Sphere& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::Xsd::XmlSchema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeSphere (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeSphere (::xercesc::XMLFormatTarget& t,
                     const ::Xsd::Rpid::Sphere& s,
                     const ::Xsd::XmlSchema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeSphere (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeSphere (::xercesc::XMLFormatTarget& t,
                     const ::Xsd::Rpid::Sphere& s,
                     ::Xsd::XmlSchema::ErrorHandler& h,
                     const ::Xsd::XmlSchema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeSphere (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeSphere (::xercesc::XMLFormatTarget& t,
                     const ::Xsd::Rpid::Sphere& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::Xsd::XmlSchema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeSphere (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeSphere (::xercesc::DOMDocument& d,
                     const ::Xsd::Rpid::Sphere& s,
                     ::Xsd::XmlSchema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "sphere" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "sphere",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }
    }

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializeSphere (const ::Xsd::Rpid::Sphere& s,
                     const ::Xsd::XmlSchema::NamespaceInfomap& m,
                     ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "sphere",
          "urn:ietf:params:xml:ns:pidf:rpid",
          m, f));

      ::Xsd::Rpid::serializeSphere (*d, s, f);
      return d;
    }

    void
    serializeStatusIcon (::std::ostream& o,
                         const ::Xsd::Rpid::StatusIcon& s,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::Xsd::XmlSchema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeStatusIcon (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeStatusIcon (::std::ostream& o,
                         const ::Xsd::Rpid::StatusIcon& s,
                         ::Xsd::XmlSchema::ErrorHandler& h,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::Xsd::XmlSchema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeStatusIcon (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeStatusIcon (::std::ostream& o,
                         const ::Xsd::Rpid::StatusIcon& s,
                         ::xercesc::DOMErrorHandler& h,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeStatusIcon (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeStatusIcon (::xercesc::XMLFormatTarget& t,
                         const ::Xsd::Rpid::StatusIcon& s,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeStatusIcon (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeStatusIcon (::xercesc::XMLFormatTarget& t,
                         const ::Xsd::Rpid::StatusIcon& s,
                         ::Xsd::XmlSchema::ErrorHandler& h,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeStatusIcon (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeStatusIcon (::xercesc::XMLFormatTarget& t,
                         const ::Xsd::Rpid::StatusIcon& s,
                         ::xercesc::DOMErrorHandler& h,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeStatusIcon (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeStatusIcon (::xercesc::DOMDocument& d,
                         const ::Xsd::Rpid::StatusIcon& s,
                         ::Xsd::XmlSchema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "status-icon" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "status-icon",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }
    }

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializeStatusIcon (const ::Xsd::Rpid::StatusIcon& s,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "status-icon",
          "urn:ietf:params:xml:ns:pidf:rpid",
          m, f));

      ::Xsd::Rpid::serializeStatusIcon (*d, s, f);
      return d;
    }

    void
    serializeTimeOffset (::std::ostream& o,
                         const ::Xsd::Rpid::TimeOffset& s,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::Xsd::XmlSchema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeTimeOffset (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeTimeOffset (::std::ostream& o,
                         const ::Xsd::Rpid::TimeOffset& s,
                         ::Xsd::XmlSchema::ErrorHandler& h,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::Xsd::XmlSchema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeTimeOffset (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeTimeOffset (::std::ostream& o,
                         const ::Xsd::Rpid::TimeOffset& s,
                         ::xercesc::DOMErrorHandler& h,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeTimeOffset (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeTimeOffset (::xercesc::XMLFormatTarget& t,
                         const ::Xsd::Rpid::TimeOffset& s,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeTimeOffset (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeTimeOffset (::xercesc::XMLFormatTarget& t,
                         const ::Xsd::Rpid::TimeOffset& s,
                         ::Xsd::XmlSchema::ErrorHandler& h,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeTimeOffset (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeTimeOffset (::xercesc::XMLFormatTarget& t,
                         const ::Xsd::Rpid::TimeOffset& s,
                         ::xercesc::DOMErrorHandler& h,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeTimeOffset (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeTimeOffset (::xercesc::DOMDocument& d,
                         const ::Xsd::Rpid::TimeOffset& s,
                         ::Xsd::XmlSchema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "time-offset" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "time-offset",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }
    }

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializeTimeOffset (const ::Xsd::Rpid::TimeOffset& s,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "time-offset",
          "urn:ietf:params:xml:ns:pidf:rpid",
          m, f));

      ::Xsd::Rpid::serializeTimeOffset (*d, s, f);
      return d;
    }

    void
    serializeUserInput (::std::ostream& o,
                        const ::Xsd::Rpid::UserInput& s,
                        const ::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::Xsd::XmlSchema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeUserInput (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeUserInput (::std::ostream& o,
                        const ::Xsd::Rpid::UserInput& s,
                        ::Xsd::XmlSchema::ErrorHandler& h,
                        const ::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::Xsd::XmlSchema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeUserInput (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeUserInput (::std::ostream& o,
                        const ::Xsd::Rpid::UserInput& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeUserInput (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeUserInput (::xercesc::XMLFormatTarget& t,
                        const ::Xsd::Rpid::UserInput& s,
                        const ::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeUserInput (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeUserInput (::xercesc::XMLFormatTarget& t,
                        const ::Xsd::Rpid::UserInput& s,
                        ::Xsd::XmlSchema::ErrorHandler& h,
                        const ::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeUserInput (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeUserInput (::xercesc::XMLFormatTarget& t,
                        const ::Xsd::Rpid::UserInput& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::Xsd::Rpid::serializeUserInput (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeUserInput (::xercesc::DOMDocument& d,
                        const ::Xsd::Rpid::UserInput& s,
                        ::Xsd::XmlSchema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "user-input" &&
          n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "user-input",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }
    }

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializeUserInput (const ::Xsd::Rpid::UserInput& s,
                        const ::Xsd::XmlSchema::NamespaceInfomap& m,
                        ::Xsd::XmlSchema::Flags f)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "user-input",
          "urn:ietf:params:xml:ns:pidf:rpid",
          m, f));

      ::Xsd::Rpid::serializeUserInput (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const Activities& i)
    {
      e << static_cast< const ::Xsd::XmlSchema::Type& > (i);

      // any_attribute
      //
      for (Activities::AnyAttributeConstIterator
           b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // note
      //
      for (Activities::NoteConstIterator
           b (i.getNote ().begin ()), n (i.getNote ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "note",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // unknown
      //
      if (i.getUnknown ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "unknown",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getUnknown ();
      }

      // appointment
      //
      for (Activities::AppointmentConstIterator
           b (i.getAppointment ().begin ()), n (i.getAppointment ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "appointment",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // away
      //
      for (Activities::AwayConstIterator
           b (i.getAway ().begin ()), n (i.getAway ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "away",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // breakfast
      //
      for (Activities::BreakfastConstIterator
           b (i.getBreakfast ().begin ()), n (i.getBreakfast ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "breakfast",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // busy
      //
      for (Activities::BusyConstIterator
           b (i.getBusy ().begin ()), n (i.getBusy ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "busy",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // dinner
      //
      for (Activities::DinnerConstIterator
           b (i.getDinner ().begin ()), n (i.getDinner ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "dinner",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // holiday
      //
      for (Activities::HolidayConstIterator
           b (i.getHoliday ().begin ()), n (i.getHoliday ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "holiday",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // in-transit
      //
      for (Activities::InTransitConstIterator
           b (i.getInTransit ().begin ()), n (i.getInTransit ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "in-transit",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // looking-for-work
      //
      for (Activities::LookingForWorkConstIterator
           b (i.getLookingForWork ().begin ()), n (i.getLookingForWork ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "looking-for-work",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // meal
      //
      for (Activities::MealConstIterator
           b (i.getMeal ().begin ()), n (i.getMeal ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "meal",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // meeting
      //
      for (Activities::MeetingConstIterator
           b (i.getMeeting ().begin ()), n (i.getMeeting ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "meeting",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // on-the-phone
      //
      for (Activities::OnThePhoneConstIterator
           b (i.getOnThePhone ().begin ()), n (i.getOnThePhone ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "on-the-phone",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // performance
      //
      for (Activities::PerformanceConstIterator
           b (i.getPerformance ().begin ()), n (i.getPerformance ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "performance",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // permanent-absence
      //
      for (Activities::PermanentAbsenceConstIterator
           b (i.getPermanentAbsence ().begin ()), n (i.getPermanentAbsence ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "permanent-absence",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // playing
      //
      for (Activities::PlayingConstIterator
           b (i.getPlaying ().begin ()), n (i.getPlaying ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "playing",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // presentation
      //
      for (Activities::PresentationConstIterator
           b (i.getPresentation ().begin ()), n (i.getPresentation ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "presentation",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // shopping
      //
      for (Activities::ShoppingConstIterator
           b (i.getShopping ().begin ()), n (i.getShopping ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "shopping",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // sleeping
      //
      for (Activities::SleepingConstIterator
           b (i.getSleeping ().begin ()), n (i.getSleeping ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "sleeping",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // spectator
      //
      for (Activities::SpectatorConstIterator
           b (i.getSpectator ().begin ()), n (i.getSpectator ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "spectator",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // steering
      //
      for (Activities::SteeringConstIterator
           b (i.getSteering ().begin ()), n (i.getSteering ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "steering",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // travel
      //
      for (Activities::TravelConstIterator
           b (i.getTravel ().begin ()), n (i.getTravel ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "travel",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // tv
      //
      for (Activities::TvConstIterator
           b (i.getTv ().begin ()), n (i.getTv ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "tv",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // vacation
      //
      for (Activities::VacationConstIterator
           b (i.getVacation ().begin ()), n (i.getVacation ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "vacation",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // working
      //
      for (Activities::WorkingConstIterator
           b (i.getWorking ().begin ()), n (i.getWorking ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "working",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // worship
      //
      for (Activities::WorshipConstIterator
           b (i.getWorship ().begin ()), n (i.getWorship ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "worship",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // other
      //
      for (Activities::OtherConstIterator
           b (i.getOther ().begin ()), n (i.getOther ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "other",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // any
      //
      for (Activities::AnyConstIterator
           b (i.getAny ().begin ()), n (i.getAny ().end ());
           b != n; ++b)
      {
        e.appendChild (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMElement* > (&(*b)), true));
      }

      // from
      //
      if (i.getFrom ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "from",
            e));

        a << *i.getFrom ();
      }

      // until
      //
      if (i.getUntil ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "until",
            e));

        a << *i.getUntil ();
      }

      // id
      //
      if (i.getId ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << *i.getId ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const Mood& i)
    {
      e << static_cast< const ::Xsd::XmlSchema::Type& > (i);

      // any_attribute
      //
      for (Mood::AnyAttributeConstIterator
           b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // note
      //
      for (Mood::NoteConstIterator
           b (i.getNote ().begin ()), n (i.getNote ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "note",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // unknown
      //
      if (i.getUnknown ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "unknown",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getUnknown ();
      }

      // afraid
      //
      for (Mood::AfraidConstIterator
           b (i.getAfraid ().begin ()), n (i.getAfraid ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "afraid",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // amazed
      //
      for (Mood::AmazedConstIterator
           b (i.getAmazed ().begin ()), n (i.getAmazed ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "amazed",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // angry
      //
      for (Mood::AngryConstIterator
           b (i.getAngry ().begin ()), n (i.getAngry ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "angry",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // annoyed
      //
      for (Mood::AnnoyedConstIterator
           b (i.getAnnoyed ().begin ()), n (i.getAnnoyed ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "annoyed",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // anxious
      //
      for (Mood::AnxiousConstIterator
           b (i.getAnxious ().begin ()), n (i.getAnxious ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "anxious",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // ashamed
      //
      for (Mood::AshamedConstIterator
           b (i.getAshamed ().begin ()), n (i.getAshamed ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ashamed",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // bored
      //
      for (Mood::BoredConstIterator
           b (i.getBored ().begin ()), n (i.getBored ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "bored",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // brave
      //
      for (Mood::BraveConstIterator
           b (i.getBrave ().begin ()), n (i.getBrave ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "brave",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // calm
      //
      for (Mood::CalmConstIterator
           b (i.getCalm ().begin ()), n (i.getCalm ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "calm",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // cold
      //
      for (Mood::ColdConstIterator
           b (i.getCold ().begin ()), n (i.getCold ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "cold",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // confused
      //
      for (Mood::ConfusedConstIterator
           b (i.getConfused ().begin ()), n (i.getConfused ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "confused",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // contented
      //
      for (Mood::ContentedConstIterator
           b (i.getContented ().begin ()), n (i.getContented ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "contented",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // cranky
      //
      for (Mood::CrankyConstIterator
           b (i.getCranky ().begin ()), n (i.getCranky ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "cranky",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // curious
      //
      for (Mood::CuriousConstIterator
           b (i.getCurious ().begin ()), n (i.getCurious ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "curious",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // depressed
      //
      for (Mood::DepressedConstIterator
           b (i.getDepressed ().begin ()), n (i.getDepressed ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "depressed",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // disappointed
      //
      for (Mood::DisappointedConstIterator
           b (i.getDisappointed ().begin ()), n (i.getDisappointed ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "disappointed",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // disgusted
      //
      for (Mood::DisgustedConstIterator
           b (i.getDisgusted ().begin ()), n (i.getDisgusted ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "disgusted",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // distracted
      //
      for (Mood::DistractedConstIterator
           b (i.getDistracted ().begin ()), n (i.getDistracted ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "distracted",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // embarrassed
      //
      for (Mood::EmbarrassedConstIterator
           b (i.getEmbarrassed ().begin ()), n (i.getEmbarrassed ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "embarrassed",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // excited
      //
      for (Mood::ExcitedConstIterator
           b (i.getExcited ().begin ()), n (i.getExcited ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "excited",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // flirtatious
      //
      for (Mood::FlirtatiousConstIterator
           b (i.getFlirtatious ().begin ()), n (i.getFlirtatious ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "flirtatious",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // frustrated
      //
      for (Mood::FrustratedConstIterator
           b (i.getFrustrated ().begin ()), n (i.getFrustrated ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "frustrated",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // grumpy
      //
      for (Mood::GrumpyConstIterator
           b (i.getGrumpy ().begin ()), n (i.getGrumpy ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "grumpy",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // guilty
      //
      for (Mood::GuiltyConstIterator
           b (i.getGuilty ().begin ()), n (i.getGuilty ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "guilty",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // happy
      //
      for (Mood::HappyConstIterator
           b (i.getHappy ().begin ()), n (i.getHappy ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "happy",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // hot
      //
      for (Mood::HotConstIterator
           b (i.getHot ().begin ()), n (i.getHot ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "hot",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // humbled
      //
      for (Mood::HumbledConstIterator
           b (i.getHumbled ().begin ()), n (i.getHumbled ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "humbled",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // humiliated
      //
      for (Mood::HumiliatedConstIterator
           b (i.getHumiliated ().begin ()), n (i.getHumiliated ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "humiliated",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // hungry
      //
      for (Mood::HungryConstIterator
           b (i.getHungry ().begin ()), n (i.getHungry ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "hungry",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // hurt
      //
      for (Mood::HurtConstIterator
           b (i.getHurt ().begin ()), n (i.getHurt ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "hurt",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // impressed
      //
      for (Mood::ImpressedConstIterator
           b (i.getImpressed ().begin ()), n (i.getImpressed ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "impressed",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // in_awe
      //
      for (Mood::In_aweConstIterator
           b (i.getIn_awe ().begin ()), n (i.getIn_awe ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "in_awe",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // in_love
      //
      for (Mood::In_loveConstIterator
           b (i.getIn_love ().begin ()), n (i.getIn_love ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "in_love",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // indignant
      //
      for (Mood::IndignantConstIterator
           b (i.getIndignant ().begin ()), n (i.getIndignant ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "indignant",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // interested
      //
      for (Mood::InterestedConstIterator
           b (i.getInterested ().begin ()), n (i.getInterested ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "interested",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // invincible
      //
      for (Mood::InvincibleConstIterator
           b (i.getInvincible ().begin ()), n (i.getInvincible ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "invincible",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // jealous
      //
      for (Mood::JealousConstIterator
           b (i.getJealous ().begin ()), n (i.getJealous ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "jealous",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // lonely
      //
      for (Mood::LonelyConstIterator
           b (i.getLonely ().begin ()), n (i.getLonely ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "lonely",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // mean
      //
      for (Mood::MeanConstIterator
           b (i.getMean ().begin ()), n (i.getMean ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "mean",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // moody
      //
      for (Mood::MoodyConstIterator
           b (i.getMoody ().begin ()), n (i.getMoody ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "moody",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // nervous
      //
      for (Mood::NervousConstIterator
           b (i.getNervous ().begin ()), n (i.getNervous ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "nervous",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // neutral
      //
      for (Mood::NeutralConstIterator
           b (i.getNeutral ().begin ()), n (i.getNeutral ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "neutral",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // offended
      //
      for (Mood::OffendedConstIterator
           b (i.getOffended ().begin ()), n (i.getOffended ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "offended",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // playful
      //
      for (Mood::PlayfulConstIterator
           b (i.getPlayful ().begin ()), n (i.getPlayful ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "playful",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // proud
      //
      for (Mood::ProudConstIterator
           b (i.getProud ().begin ()), n (i.getProud ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "proud",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // relieved
      //
      for (Mood::RelievedConstIterator
           b (i.getRelieved ().begin ()), n (i.getRelieved ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "relieved",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // remorseful
      //
      for (Mood::RemorsefulConstIterator
           b (i.getRemorseful ().begin ()), n (i.getRemorseful ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "remorseful",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // restless
      //
      for (Mood::RestlessConstIterator
           b (i.getRestless ().begin ()), n (i.getRestless ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "restless",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // sad
      //
      for (Mood::SadConstIterator
           b (i.getSad ().begin ()), n (i.getSad ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "sad",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // sarcastic
      //
      for (Mood::SarcasticConstIterator
           b (i.getSarcastic ().begin ()), n (i.getSarcastic ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "sarcastic",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // serious
      //
      for (Mood::SeriousConstIterator
           b (i.getSerious ().begin ()), n (i.getSerious ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "serious",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // shocked
      //
      for (Mood::ShockedConstIterator
           b (i.getShocked ().begin ()), n (i.getShocked ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "shocked",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // shy
      //
      for (Mood::ShyConstIterator
           b (i.getShy ().begin ()), n (i.getShy ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "shy",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // sick
      //
      for (Mood::SickConstIterator
           b (i.getSick ().begin ()), n (i.getSick ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "sick",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // sleepy
      //
      for (Mood::SleepyConstIterator
           b (i.getSleepy ().begin ()), n (i.getSleepy ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "sleepy",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // stressed
      //
      for (Mood::StressedConstIterator
           b (i.getStressed ().begin ()), n (i.getStressed ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "stressed",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // surprised
      //
      for (Mood::SurprisedConstIterator
           b (i.getSurprised ().begin ()), n (i.getSurprised ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "surprised",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // thirsty
      //
      for (Mood::ThirstyConstIterator
           b (i.getThirsty ().begin ()), n (i.getThirsty ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "thirsty",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // worried
      //
      for (Mood::WorriedConstIterator
           b (i.getWorried ().begin ()), n (i.getWorried ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "worried",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // other
      //
      for (Mood::OtherConstIterator
           b (i.getOther ().begin ()), n (i.getOther ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "other",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // any
      //
      for (Mood::AnyConstIterator
           b (i.getAny ().begin ()), n (i.getAny ().end ());
           b != n; ++b)
      {
        e.appendChild (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMElement* > (&(*b)), true));
      }

      // from
      //
      if (i.getFrom ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "from",
            e));

        a << *i.getFrom ();
      }

      // until
      //
      if (i.getUntil ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "until",
            e));

        a << *i.getUntil ();
      }

      // id
      //
      if (i.getId ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << *i.getId ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PlaceIs& i)
    {
      e << static_cast< const ::Xsd::XmlSchema::Type& > (i);

      // any_attribute
      //
      for (PlaceIs::AnyAttributeConstIterator
           b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // note
      //
      for (PlaceIs::NoteConstIterator
           b (i.getNote ().begin ()), n (i.getNote ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "note",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // audio
      //
      if (i.getAudio ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "audio",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getAudio ();
      }

      // video
      //
      if (i.getVideo ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "video",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getVideo ();
      }

      // text
      //
      if (i.getText ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "text",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getText ();
      }

      // from
      //
      if (i.getFrom ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "from",
            e));

        a << *i.getFrom ();
      }

      // until
      //
      if (i.getUntil ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "until",
            e));

        a << *i.getUntil ();
      }

      // id
      //
      if (i.getId ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << *i.getId ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PlaceType& i)
    {
      e << static_cast< const ::Xsd::XmlSchema::Type& > (i);

      // any_attribute
      //
      for (PlaceType::AnyAttributeConstIterator
           b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // note
      //
      for (PlaceType::NoteConstIterator
           b (i.getNote ().begin ()), n (i.getNote ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "note",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // other
      //
      if (i.getOther ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "other",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getOther ();
      }

      // any
      //
      for (PlaceType::AnyConstIterator
           b (i.getAny ().begin ()), n (i.getAny ().end ());
           b != n; ++b)
      {
        e.appendChild (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMElement* > (&(*b)), true));
      }

      // from
      //
      if (i.getFrom ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "from",
            e));

        a << *i.getFrom ();
      }

      // until
      //
      if (i.getUntil ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "until",
            e));

        a << *i.getUntil ();
      }

      // id
      //
      if (i.getId ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << *i.getId ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const Privacy& i)
    {
      e << static_cast< const ::Xsd::XmlSchema::Type& > (i);

      // any_attribute
      //
      for (Privacy::AnyAttributeConstIterator
           b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // note
      //
      for (Privacy::NoteConstIterator
           b (i.getNote ().begin ()), n (i.getNote ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "note",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // unknown
      //
      if (i.getUnknown ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "unknown",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getUnknown ();
      }

      // audio
      //
      if (i.getAudio ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "audio",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getAudio ();
      }

      // text
      //
      if (i.getText ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "text",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getText ();
      }

      // video
      //
      if (i.getVideo ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "video",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getVideo ();
      }

      // any
      //
      for (Privacy::AnyConstIterator
           b (i.getAny ().begin ()), n (i.getAny ().end ());
           b != n; ++b)
      {
        e.appendChild (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMElement* > (&(*b)), true));
      }

      // from
      //
      if (i.getFrom ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "from",
            e));

        a << *i.getFrom ();
      }

      // until
      //
      if (i.getUntil ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "until",
            e));

        a << *i.getUntil ();
      }

      // id
      //
      if (i.getId ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << *i.getId ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const Relationship& i)
    {
      e << static_cast< const ::Xsd::XmlSchema::Type& > (i);

      // note
      //
      for (Relationship::NoteConstIterator
           b (i.getNote ().begin ()), n (i.getNote ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "note",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // assistant
      //
      if (i.getAssistant ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "assistant",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getAssistant ();
      }

      // associate
      //
      if (i.getAssociate ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "associate",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getAssociate ();
      }

      // family
      //
      if (i.getFamily ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "family",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getFamily ();
      }

      // friend
      //
      if (i.getFriend ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "friend",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getFriend ();
      }

      // other
      //
      if (i.getOther ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "other",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getOther ();
      }

      // self
      //
      if (i.getSelf ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "self",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getSelf ();
      }

      // supervisor
      //
      if (i.getSupervisor ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "supervisor",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getSupervisor ();
      }

      // unknown
      //
      if (i.getUnknown ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "unknown",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getUnknown ();
      }

      // any
      //
      for (Relationship::AnyConstIterator
           b (i.getAny ().begin ()), n (i.getAny ().end ());
           b != n; ++b)
      {
        e.appendChild (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMElement* > (&(*b)), true));
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ServiceClass& i)
    {
      e << static_cast< const ::Xsd::XmlSchema::Type& > (i);

      // note
      //
      for (ServiceClass::NoteConstIterator
           b (i.getNote ().begin ()), n (i.getNote ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "note",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *b;
      }

      // courier
      //
      if (i.getCourier ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "courier",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getCourier ();
      }

      // electronic
      //
      if (i.getElectronic ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "electronic",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getElectronic ();
      }

      // freight
      //
      if (i.getFreight ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "freight",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getFreight ();
      }

      // in-person
      //
      if (i.getInPerson ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "in-person",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getInPerson ();
      }

      // postal
      //
      if (i.getPostal ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "postal",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getPostal ();
      }

      // unknown
      //
      if (i.getUnknown ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "unknown",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getUnknown ();
      }

      // any
      //
      for (ServiceClass::AnyConstIterator
           b (i.getAny ().begin ()), n (i.getAny ().end ());
           b != n; ++b)
      {
        e.appendChild (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMElement* > (&(*b)), true));
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const Sphere& i)
    {
      e << static_cast< const ::Xsd::XmlSchema::Type& > (i);

      // any_attribute
      //
      for (Sphere::AnyAttributeConstIterator
           b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // home
      //
      if (i.getHome ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "home",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getHome ();
      }

      // work
      //
      if (i.getWork ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "work",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getWork ();
      }

      // unknown
      //
      if (i.getUnknown ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "unknown",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getUnknown ();
      }

      // any
      //
      for (Sphere::AnyConstIterator
           b (i.getAny ().begin ()), n (i.getAny ().end ());
           b != n; ++b)
      {
        e.appendChild (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMElement* > (&(*b)), true));
      }

      // from
      //
      if (i.getFrom ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "from",
            e));

        a << *i.getFrom ();
      }

      // until
      //
      if (i.getUntil ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "until",
            e));

        a << *i.getUntil ();
      }

      // id
      //
      if (i.getId ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << *i.getId ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const StatusIcon& i)
    {
      e << static_cast< const ::Xsd::XmlSchema::Uri& > (i);

      // any_attribute
      //
      for (StatusIcon::AnyAttributeConstIterator
           b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // from
      //
      if (i.getFrom ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "from",
            e));

        a << *i.getFrom ();
      }

      // until
      //
      if (i.getUntil ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "until",
            e));

        a << *i.getUntil ();
      }

      // id
      //
      if (i.getId ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << *i.getId ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TimeOffset& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::Xsd::XmlSchema::Integer, char, ::Xsd::XmlSchema::SimpleType >& > (i);

      // any_attribute
      //
      for (TimeOffset::AnyAttributeConstIterator
           b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // from
      //
      if (i.getFrom ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "from",
            e));

        a << *i.getFrom ();
      }

      // until
      //
      if (i.getUntil ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "until",
            e));

        a << *i.getUntil ();
      }

      // description
      //
      if (i.getDescription ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "description",
            e));

        a << *i.getDescription ();
      }

      // id
      //
      if (i.getId ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << *i.getId ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const UserInput& i)
    {
      e << static_cast< const ::Xsd::Rpid::ActiveIdle& > (i);

      // any_attribute
      //
      for (UserInput::AnyAttributeConstIterator
           b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // idle-threshold
      //
      if (i.getIdleThreshold ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "idle-threshold",
            e));

        a << *i.getIdleThreshold ();
      }

      // last-input
      //
      if (i.getLastInput ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "last-input",
            e));

        a << *i.getLastInput ();
      }

      // id
      //
      if (i.getId ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << *i.getId ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const Audio& i)
    {
      e << static_cast< const ::Xsd::XmlSchema::Type& > (i);

      // noisy
      //
      if (i.getNoisy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "noisy",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getNoisy ();
      }

      // ok
      //
      if (i.getOk ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ok",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getOk ();
      }

      // quiet
      //
      if (i.getQuiet ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "quiet",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getQuiet ();
      }

      // unknown
      //
      if (i.getUnknown ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "unknown",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getUnknown ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const Video& i)
    {
      e << static_cast< const ::Xsd::XmlSchema::Type& > (i);

      // toobright
      //
      if (i.getToobright ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "toobright",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getToobright ();
      }

      // ok
      //
      if (i.getOk ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ok",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getOk ();
      }

      // dark
      //
      if (i.getDark ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "dark",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getDark ();
      }

      // unknown
      //
      if (i.getUnknown ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "unknown",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getUnknown ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const Text& i)
    {
      e << static_cast< const ::Xsd::XmlSchema::Type& > (i);

      // uncomfortable
      //
      if (i.getUncomfortable ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "uncomfortable",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getUncomfortable ();
      }

      // inappropriate
      //
      if (i.getInappropriate ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "inappropriate",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getInappropriate ();
      }

      // ok
      //
      if (i.getOk ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ok",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getOk ();
      }

      // unknown
      //
      if (i.getUnknown ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "unknown",
            "urn:ietf:params:xml:ns:pidf:rpid",
            e));

        s << *i.getUnknown ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
#if __clang__ || __GNUC__ >= 4
	#pragma GCC diagnostic pop
#endif
//
// End epilogue.

