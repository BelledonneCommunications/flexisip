/*
    Flexisip, a flexible SIP proxy server with media capabilities.
    Copyright (C) 2010-2025 Belledonne Communications SARL, All rights reserved.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

#include "sofia-sip/msg_addr.h"
#include "sofia-sip/msg_mclass.h"
#include "sofia-sip/msg_mclass_hash.h"
#include "sofia-sip/sdp.h"
#include "sofia-sip/sip_parser.h"
#include "sofia-sip/su_types.h"
#include "sofia-sip/tport.h"

#include "tester.hh"
#include "utils/test-patterns/test.hh"
#include "utils/test-suite.hh"

using namespace std;
namespace flexisip::tester::sofia_tester_suite {
namespace {

void testCVE_2022_47516() {
	// We removed an assert(self)
	auto result = tport_tsend(nullptr, nullptr, nullptr, 0, 0);
	BC_ASSERT_PTR_NULL(result);
}

void testCVE_2022_31001() {
	char cStr[] = "MNIN";
	size_t len = sizeof(cStr);
	auto copy = static_cast<char*>(malloc(len));
	memcpy(copy, cStr, len);
	auto original = copy;

	sip_method_d(&copy, nullptr);

	free(original);
}

msg_t* read_message(const char* buffer) {
	size_t n;
	msg_t* msg;
	msg_iovec_t iovec[2];
	auto testMclass = msg_mclass_clone(sip_default_mclass(), 0, 0);
	n = strlen(buffer);
	if (n == 0) return nullptr;

	msg = msg_create(testMclass, MSG_DO_EXTRACT_COPY);
	if (msg_recv_iovec(msg, iovec, 2, n, 1) < 0) {
		BC_HARD_FAIL("msg_recv_iovec failed");
	}
	memcpy(iovec->mv_base, buffer, n);
	msg_recv_commit(msg, n, 1);
	msg_extract(msg);

	free(testMclass);
	return msg;
}

void testCVE_2022_31002() {
	char cStr[] = "INVITE sip:{ips%3A?ser%40ep:%\r\n"
	              "????e?ia: SIP/2.0/UDP hosanchet;rporbContact:\r\n"
	              "61Me=vC6  =1lue%25=z9hGGGGGGGGGGGGGGGGGGGGGGGGGGGGGCo[tac~:\r\n"
	              "Vxam????co%6?72;n%61Me=vC6  =1lue%25060;%6C%72;nent-Length: 120\r\n\r\n"
	              "[v=er%40exomple.co%6C%]() 72t: taV2939 IN IP4 192 /2.1\r\n"
	              "s=\r\n"
	              "c=IN IP4 192.=.2.1\r\n"
	              "t=0 0\r\n"
	              "mCaudio 49217 RTP?AVP 0 12\r\n"
	              "m????eo E22= RTP/AVP 31a=rtpmap:31 LPC\r\n\r\n";
	size_t len = sizeof(cStr);
	char* data = static_cast<char*>(malloc(len));
	memcpy(data, cStr, len);
	auto msg = read_message(data);
	msg_destroy(msg);
	free(data);
}

void testCVE_2022_31003() {
	char cStr[] = "v=0\r\n"
	              "o=fa 289527 27 IN IP4 ifm\r\n"
	              "s=SDP\r\n"
	              "c=IN IP4 ift\r\n"
	              "t=0 0\r\n"
	              "m=image 4 udptl t38\r\n"
	              "a\x00";
	size_t len = sizeof(cStr);
	char* data = static_cast<char*>(malloc(len));
	memcpy(data, cStr, len);
	su_home_t* home = su_home_create();
	su_home_check(home);
	auto parser = sdp_parse(home, data, strlen(data), sdp_f_config);
	sdp_parser_free(parser);
	su_home_check(home);
	su_home_unref(home);
	free(data);
}

TestSuite _{
    "sofia::cve",
    {
        CLASSY_TEST(testCVE_2022_47516),
        CLASSY_TEST(testCVE_2022_31001),
        CLASSY_TEST(testCVE_2022_31002),
        CLASSY_TEST(testCVE_2022_31003),
    },
};
} // namespace
} // namespace flexisip::tester::sofia_tester_suite