// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
#if __clang__ || __GNUC__ >= 4
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wfloat-equal"
  #pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
#ifndef __ANDROID__
  #pragma GCC diagnostic ignored "-Wsuggest-override"
#endif
#endif
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "pidf-oma-pres.hh"

namespace oma_pres
{
  // BasicType
  //

  BasicType::
  BasicType (Value v)
  : ::Xsd::XmlSchema::String (_xsd_BasicType_literals_[v])
  {
  }

  BasicType::
  BasicType (const char* v)
  : ::Xsd::XmlSchema::String (v)
  {
  }

  BasicType::
  BasicType (const ::std::string& v)
  : ::Xsd::XmlSchema::String (v)
  {
  }

  BasicType::
  BasicType (const ::Xsd::XmlSchema::String& v)
  : ::Xsd::XmlSchema::String (v)
  {
  }

  BasicType::
  BasicType (const BasicType& v,
             ::Xsd::XmlSchema::Flags f,
             ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::String (v, f, c)
  {
  }

  BasicType& BasicType::
  operator= (Value v)
  {
    static_cast< ::Xsd::XmlSchema::String& > (*this) =
    ::Xsd::XmlSchema::String (_xsd_BasicType_literals_[v]);

    return *this;
  }


  // EmptyType
  //


  // RegistrationType
  //

  RegistrationType::
  RegistrationType (Value v)
  : ::Xsd::XmlSchema::String (_xsd_RegistrationType_literals_[v])
  {
  }

  RegistrationType::
  RegistrationType (const char* v)
  : ::Xsd::XmlSchema::String (v)
  {
  }

  RegistrationType::
  RegistrationType (const ::std::string& v)
  : ::Xsd::XmlSchema::String (v)
  {
  }

  RegistrationType::
  RegistrationType (const ::Xsd::XmlSchema::String& v)
  : ::Xsd::XmlSchema::String (v)
  {
  }

  RegistrationType::
  RegistrationType (const RegistrationType& v,
                    ::Xsd::XmlSchema::Flags f,
                    ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::String (v, f, c)
  {
  }

  RegistrationType& RegistrationType::
  operator= (Value v)
  {
    static_cast< ::Xsd::XmlSchema::String& > (*this) =
    ::Xsd::XmlSchema::String (_xsd_RegistrationType_literals_[v]);

    return *this;
  }


  // BarringType
  //

  BarringType::
  BarringType (Value v)
  : ::Xsd::XmlSchema::String (_xsd_BarringType_literals_[v])
  {
  }

  BarringType::
  BarringType (const char* v)
  : ::Xsd::XmlSchema::String (v)
  {
  }

  BarringType::
  BarringType (const ::std::string& v)
  : ::Xsd::XmlSchema::String (v)
  {
  }

  BarringType::
  BarringType (const ::Xsd::XmlSchema::String& v)
  : ::Xsd::XmlSchema::String (v)
  {
  }

  BarringType::
  BarringType (const BarringType& v,
               ::Xsd::XmlSchema::Flags f,
               ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::String (v, f, c)
  {
  }

  BarringType& BarringType::
  operator= (Value v)
  {
    static_cast< ::Xsd::XmlSchema::String& > (*this) =
    ::Xsd::XmlSchema::String (_xsd_BarringType_literals_[v]);

    return *this;
  }


  // ServiceDescription
  //

  const ServiceDescription::ServiceIdType& ServiceDescription::
  getServiceId () const
  {
    return this->service_id_.get ();
  }

  ServiceDescription::ServiceIdType& ServiceDescription::
  getServiceId ()
  {
    return this->service_id_.get ();
  }

  void ServiceDescription::
  setServiceId (const ServiceIdType& x)
  {
    this->service_id_.set (x);
  }

  void ServiceDescription::
  setServiceId (::std::unique_ptr< ServiceIdType > x)
  {
    this->service_id_.set (std::move (x));
  }

  ::std::unique_ptr< ServiceDescription::ServiceIdType > ServiceDescription::
  setDetachService_id ()
  {
    return this->service_id_.detach ();
  }

  const ServiceDescription::VersionType& ServiceDescription::
  getVersion () const
  {
    return this->version_.get ();
  }

  ServiceDescription::VersionType& ServiceDescription::
  getVersion ()
  {
    return this->version_.get ();
  }

  void ServiceDescription::
  setVersion (const VersionType& x)
  {
    this->version_.set (x);
  }

  void ServiceDescription::
  setVersion (::std::unique_ptr< VersionType > x)
  {
    this->version_.set (std::move (x));
  }

  ::std::unique_ptr< ServiceDescription::VersionType > ServiceDescription::
  setDetachVersion ()
  {
    return this->version_.detach ();
  }

  const ServiceDescription::DescriptionOptional& ServiceDescription::
  getDescription () const
  {
    return this->description_;
  }

  ServiceDescription::DescriptionOptional& ServiceDescription::
  getDescription ()
  {
    return this->description_;
  }

  void ServiceDescription::
  setDescription (const DescriptionType& x)
  {
    this->description_.set (x);
  }

  void ServiceDescription::
  setDescription (const DescriptionOptional& x)
  {
    this->description_ = x;
  }

  void ServiceDescription::
  setDescription (::std::unique_ptr< DescriptionType > x)
  {
    this->description_.set (std::move (x));
  }

  const ServiceDescription::AnySequence& ServiceDescription::
  getAny () const
  {
    return this->any_;
  }

  ServiceDescription::AnySequence& ServiceDescription::
  getAny ()
  {
    return this->any_;
  }

  void ServiceDescription::
  setAny (const AnySequence& s)
  {
    this->any_ = s;
  }

  const ServiceDescription::AnyAttributeSet& ServiceDescription::
  getAnyAttribute () const
  {
    return this->any_attribute_;
  }

  ServiceDescription::AnyAttributeSet& ServiceDescription::
  getAnyAttribute ()
  {
    return this->any_attribute_;
  }

  void ServiceDescription::
  setAnyAttribute (const AnyAttributeSet& s)
  {
    this->any_attribute_ = s;
  }

  const ::xercesc::DOMDocument& ServiceDescription::
  getDomDocument () const
  {
    return *this->dom_document_;
  }

  ::xercesc::DOMDocument& ServiceDescription::
  getDomDocument ()
  {
    return *this->dom_document_;
  }


  // Willingness
  //

  const Willingness::BasicOptional& Willingness::
  getBasic () const
  {
    return this->basic_;
  }

  Willingness::BasicOptional& Willingness::
  getBasic ()
  {
    return this->basic_;
  }

  void Willingness::
  setBasic (const BasicType& x)
  {
    this->basic_.set (x);
  }

  void Willingness::
  setBasic (const BasicOptional& x)
  {
    this->basic_ = x;
  }

  void Willingness::
  setBasic (::std::unique_ptr< BasicType > x)
  {
    this->basic_.set (std::move (x));
  }

  const Willingness::AnySequence& Willingness::
  getAny () const
  {
    return this->any_;
  }

  Willingness::AnySequence& Willingness::
  getAny ()
  {
    return this->any_;
  }

  void Willingness::
  setAny (const AnySequence& s)
  {
    this->any_ = s;
  }

  const Willingness::AnyAttributeSet& Willingness::
  getAnyAttribute () const
  {
    return this->any_attribute_;
  }

  Willingness::AnyAttributeSet& Willingness::
  getAnyAttribute ()
  {
    return this->any_attribute_;
  }

  void Willingness::
  setAnyAttribute (const AnyAttributeSet& s)
  {
    this->any_attribute_ = s;
  }

  const ::xercesc::DOMDocument& Willingness::
  getDomDocument () const
  {
    return *this->dom_document_;
  }

  ::xercesc::DOMDocument& Willingness::
  getDomDocument ()
  {
    return *this->dom_document_;
  }


  // SessionParticipation
  //

  const SessionParticipation::BasicOptional& SessionParticipation::
  getBasic () const
  {
    return this->basic_;
  }

  SessionParticipation::BasicOptional& SessionParticipation::
  getBasic ()
  {
    return this->basic_;
  }

  void SessionParticipation::
  setBasic (const BasicType& x)
  {
    this->basic_.set (x);
  }

  void SessionParticipation::
  setBasic (const BasicOptional& x)
  {
    this->basic_ = x;
  }

  void SessionParticipation::
  setBasic (::std::unique_ptr< BasicType > x)
  {
    this->basic_.set (std::move (x));
  }

  const SessionParticipation::AnySequence& SessionParticipation::
  getAny () const
  {
    return this->any_;
  }

  SessionParticipation::AnySequence& SessionParticipation::
  getAny ()
  {
    return this->any_;
  }

  void SessionParticipation::
  setAny (const AnySequence& s)
  {
    this->any_ = s;
  }

  const SessionParticipation::AnyAttributeSet& SessionParticipation::
  getAnyAttribute () const
  {
    return this->any_attribute_;
  }

  SessionParticipation::AnyAttributeSet& SessionParticipation::
  getAnyAttribute ()
  {
    return this->any_attribute_;
  }

  void SessionParticipation::
  setAnyAttribute (const AnyAttributeSet& s)
  {
    this->any_attribute_ = s;
  }

  const ::xercesc::DOMDocument& SessionParticipation::
  getDomDocument () const
  {
    return *this->dom_document_;
  }

  ::xercesc::DOMDocument& SessionParticipation::
  getDomDocument ()
  {
    return *this->dom_document_;
  }


  // RegistrationState
  //

  const RegistrationState::AnyAttributeSet& RegistrationState::
  getAnyAttribute () const
  {
    return this->any_attribute_;
  }

  RegistrationState::AnyAttributeSet& RegistrationState::
  getAnyAttribute ()
  {
    return this->any_attribute_;
  }

  void RegistrationState::
  setAnyAttribute (const AnyAttributeSet& s)
  {
    this->any_attribute_ = s;
  }

  const ::xercesc::DOMDocument& RegistrationState::
  getDomDocument () const
  {
    return *this->dom_document_;
  }

  ::xercesc::DOMDocument& RegistrationState::
  getDomDocument ()
  {
    return *this->dom_document_;
  }


  // BarringState
  //

  const BarringState::AnyAttributeSet& BarringState::
  getAnyAttribute () const
  {
    return this->any_attribute_;
  }

  BarringState::AnyAttributeSet& BarringState::
  getAnyAttribute ()
  {
    return this->any_attribute_;
  }

  void BarringState::
  setAnyAttribute (const AnyAttributeSet& s)
  {
    this->any_attribute_ = s;
  }

  const ::xercesc::DOMDocument& BarringState::
  getDomDocument () const
  {
    return *this->dom_document_;
  }

  ::xercesc::DOMDocument& BarringState::
  getDomDocument ()
  {
    return *this->dom_document_;
  }


  // OverridingWillingness
  //

  const OverridingWillingness::BasicOptional& OverridingWillingness::
  getBasic () const
  {
    return this->basic_;
  }

  OverridingWillingness::BasicOptional& OverridingWillingness::
  getBasic ()
  {
    return this->basic_;
  }

  void OverridingWillingness::
  setBasic (const BasicType& x)
  {
    this->basic_.set (x);
  }

  void OverridingWillingness::
  setBasic (const BasicOptional& x)
  {
    this->basic_ = x;
  }

  void OverridingWillingness::
  setBasic (::std::unique_ptr< BasicType > x)
  {
    this->basic_.set (std::move (x));
  }

  const OverridingWillingness::AnySequence& OverridingWillingness::
  getAny () const
  {
    return this->any_;
  }

  OverridingWillingness::AnySequence& OverridingWillingness::
  getAny ()
  {
    return this->any_;
  }

  void OverridingWillingness::
  setAny (const AnySequence& s)
  {
    this->any_ = s;
  }

  const OverridingWillingness::AnyAttributeSet& OverridingWillingness::
  getAnyAttribute () const
  {
    return this->any_attribute_;
  }

  OverridingWillingness::AnyAttributeSet& OverridingWillingness::
  getAnyAttribute ()
  {
    return this->any_attribute_;
  }

  void OverridingWillingness::
  setAnyAttribute (const AnyAttributeSet& s)
  {
    this->any_attribute_ = s;
  }

  const ::xercesc::DOMDocument& OverridingWillingness::
  getDomDocument () const
  {
    return *this->dom_document_;
  }

  ::xercesc::DOMDocument& OverridingWillingness::
  getDomDocument ()
  {
    return *this->dom_document_;
  }


  // NetworkAvailability
  //

  const NetworkAvailability::NetworkSequence& NetworkAvailability::
  getNetwork () const
  {
    return this->network_;
  }

  NetworkAvailability::NetworkSequence& NetworkAvailability::
  getNetwork ()
  {
    return this->network_;
  }

  void NetworkAvailability::
  setNetwork (const NetworkSequence& s)
  {
    this->network_ = s;
  }

  const NetworkAvailability::AnySequence& NetworkAvailability::
  getAny () const
  {
    return this->any_;
  }

  NetworkAvailability::AnySequence& NetworkAvailability::
  getAny ()
  {
    return this->any_;
  }

  void NetworkAvailability::
  setAny (const AnySequence& s)
  {
    this->any_ = s;
  }

  const NetworkAvailability::AnyAttributeSet& NetworkAvailability::
  getAnyAttribute () const
  {
    return this->any_attribute_;
  }

  NetworkAvailability::AnyAttributeSet& NetworkAvailability::
  getAnyAttribute ()
  {
    return this->any_attribute_;
  }

  void NetworkAvailability::
  setAnyAttribute (const AnyAttributeSet& s)
  {
    this->any_attribute_ = s;
  }

  const ::xercesc::DOMDocument& NetworkAvailability::
  getDomDocument () const
  {
    return *this->dom_document_;
  }

  ::xercesc::DOMDocument& NetworkAvailability::
  getDomDocument ()
  {
    return *this->dom_document_;
  }


  // Network
  //

  const Network::ActiveOptional& Network::
  getActive () const
  {
    return this->active_;
  }

  Network::ActiveOptional& Network::
  getActive ()
  {
    return this->active_;
  }

  void Network::
  setActive (const ActiveType& x)
  {
    this->active_.set (x);
  }

  void Network::
  setActive (const ActiveOptional& x)
  {
    this->active_ = x;
  }

  void Network::
  setActive (::std::unique_ptr< ActiveType > x)
  {
    this->active_.set (std::move (x));
  }

  const Network::TerminatedOptional& Network::
  getTerminated () const
  {
    return this->terminated_;
  }

  Network::TerminatedOptional& Network::
  getTerminated ()
  {
    return this->terminated_;
  }

  void Network::
  setTerminated (const TerminatedType& x)
  {
    this->terminated_.set (x);
  }

  void Network::
  setTerminated (const TerminatedOptional& x)
  {
    this->terminated_ = x;
  }

  void Network::
  setTerminated (::std::unique_ptr< TerminatedType > x)
  {
    this->terminated_.set (std::move (x));
  }

  const Network::AnySequence& Network::
  getAny () const
  {
    return this->any_;
  }

  Network::AnySequence& Network::
  getAny ()
  {
    return this->any_;
  }

  void Network::
  setAny (const AnySequence& s)
  {
    this->any_ = s;
  }

  const Network::IdType& Network::
  getId () const
  {
    return this->id_.get ();
  }

  Network::IdType& Network::
  getId ()
  {
    return this->id_.get ();
  }

  void Network::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void Network::
  setId (::std::unique_ptr< IdType > x)
  {
    this->id_.set (std::move (x));
  }

  ::std::unique_ptr< Network::IdType > Network::
  setDetachId ()
  {
    return this->id_.detach ();
  }

  const Network::AnyAttributeSet& Network::
  getAnyAttribute () const
  {
    return this->any_attribute_;
  }

  Network::AnyAttributeSet& Network::
  getAnyAttribute ()
  {
    return this->any_attribute_;
  }

  void Network::
  setAnyAttribute (const AnyAttributeSet& s)
  {
    this->any_attribute_ = s;
  }

  const ::xercesc::DOMDocument& Network::
  getDomDocument () const
  {
    return *this->dom_document_;
  }

  ::xercesc::DOMDocument& Network::
  getDomDocument ()
  {
    return *this->dom_document_;
  }
}

#include <xsd/cxx/xml/dom/wildcard-source.hxx>

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace oma_pres
{
  // BasicType
  //

  BasicType::
  BasicType (const ::xercesc::DOMElement& e,
             ::Xsd::XmlSchema::Flags f,
             ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::String (e, f, c)
  {
    _xsd_BasicType_convert ();
  }

  BasicType::
  BasicType (const ::xercesc::DOMAttr& a,
             ::Xsd::XmlSchema::Flags f,
             ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::String (a, f, c)
  {
    _xsd_BasicType_convert ();
  }

  BasicType::
  BasicType (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::Xsd::XmlSchema::Flags f,
             ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::String (s, e, f, c)
  {
    _xsd_BasicType_convert ();
  }

  BasicType* BasicType::
  _clone (::Xsd::XmlSchema::Flags f,
          ::Xsd::XmlSchema::Container* c) const
  {
    return new class BasicType (*this, f, c);
  }

  BasicType::Value BasicType::
  _xsd_BasicType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_BasicType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_BasicType_indexes_,
                      _xsd_BasicType_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_BasicType_indexes_ + 2 || _xsd_BasicType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const BasicType::
  _xsd_BasicType_literals_[2] =
  {
    "open",
    "closed"
  };

  const BasicType::Value BasicType::
  _xsd_BasicType_indexes_[2] =
  {
    ::oma_pres::BasicType::closed,
    ::oma_pres::BasicType::open
  };

  // EmptyType
  //

  EmptyType::
  EmptyType ()
  : ::Xsd::XmlSchema::Type ()
  {
  }

  EmptyType::
  EmptyType (const EmptyType& x,
             ::Xsd::XmlSchema::Flags f,
             ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::Type (x, f, c)
  {
  }

  EmptyType::
  EmptyType (const ::xercesc::DOMElement& e,
             ::Xsd::XmlSchema::Flags f,
             ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::Type (e, f, c)
  {
  }

  EmptyType::
  EmptyType (const ::xercesc::DOMAttr& a,
             ::Xsd::XmlSchema::Flags f,
             ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::Type (a, f, c)
  {
  }

  EmptyType::
  EmptyType (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::Xsd::XmlSchema::Flags f,
             ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::Type (s, e, f, c)
  {
  }

  EmptyType* EmptyType::
  _clone (::Xsd::XmlSchema::Flags f,
          ::Xsd::XmlSchema::Container* c) const
  {
    return new class EmptyType (*this, f, c);
  }

  EmptyType::
  ~EmptyType ()
  {
  }

  // RegistrationType
  //

  RegistrationType::
  RegistrationType (const ::xercesc::DOMElement& e,
                    ::Xsd::XmlSchema::Flags f,
                    ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::String (e, f, c)
  {
    _xsd_RegistrationType_convert ();
  }

  RegistrationType::
  RegistrationType (const ::xercesc::DOMAttr& a,
                    ::Xsd::XmlSchema::Flags f,
                    ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::String (a, f, c)
  {
    _xsd_RegistrationType_convert ();
  }

  RegistrationType::
  RegistrationType (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::Xsd::XmlSchema::Flags f,
                    ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::String (s, e, f, c)
  {
    _xsd_RegistrationType_convert ();
  }

  RegistrationType* RegistrationType::
  _clone (::Xsd::XmlSchema::Flags f,
          ::Xsd::XmlSchema::Container* c) const
  {
    return new class RegistrationType (*this, f, c);
  }

  RegistrationType::Value RegistrationType::
  _xsd_RegistrationType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RegistrationType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_RegistrationType_indexes_,
                      _xsd_RegistrationType_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_RegistrationType_indexes_ + 2 || _xsd_RegistrationType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const RegistrationType::
  _xsd_RegistrationType_literals_[2] =
  {
    "active",
    "terminated"
  };

  const RegistrationType::Value RegistrationType::
  _xsd_RegistrationType_indexes_[2] =
  {
    ::oma_pres::RegistrationType::active,
    ::oma_pres::RegistrationType::terminated
  };

  // BarringType
  //

  BarringType::
  BarringType (const ::xercesc::DOMElement& e,
               ::Xsd::XmlSchema::Flags f,
               ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::String (e, f, c)
  {
    _xsd_BarringType_convert ();
  }

  BarringType::
  BarringType (const ::xercesc::DOMAttr& a,
               ::Xsd::XmlSchema::Flags f,
               ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::String (a, f, c)
  {
    _xsd_BarringType_convert ();
  }

  BarringType::
  BarringType (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::Xsd::XmlSchema::Flags f,
               ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::String (s, e, f, c)
  {
    _xsd_BarringType_convert ();
  }

  BarringType* BarringType::
  _clone (::Xsd::XmlSchema::Flags f,
          ::Xsd::XmlSchema::Container* c) const
  {
    return new class BarringType (*this, f, c);
  }

  BarringType::Value BarringType::
  _xsd_BarringType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_BarringType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_BarringType_indexes_,
                      _xsd_BarringType_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_BarringType_indexes_ + 2 || _xsd_BarringType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const BarringType::
  _xsd_BarringType_literals_[2] =
  {
    "active",
    "terminated"
  };

  const BarringType::Value BarringType::
  _xsd_BarringType_indexes_[2] =
  {
    ::oma_pres::BarringType::active,
    ::oma_pres::BarringType::terminated
  };

  // ServiceDescription
  //

  ServiceDescription::
  ServiceDescription (const ServiceIdType& service_id,
                      const VersionType& version)
  : ::Xsd::XmlSchema::Type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    service_id_ (service_id, this),
    version_ (version, this),
    description_ (this),
    any_ (this->getDomDocument ()),
    any_attribute_ (this->getDomDocument ())
  {
  }

  ServiceDescription::
  ServiceDescription (const ServiceDescription& x,
                      ::Xsd::XmlSchema::Flags f,
                      ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::Type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    service_id_ (x.service_id_, f, this),
    version_ (x.version_, f, this),
    description_ (x.description_, f, this),
    any_ (x.any_, this->getDomDocument ()),
    any_attribute_ (x.any_attribute_, this->getDomDocument ())
  {
  }

  ServiceDescription::
  ServiceDescription (const ::xercesc::DOMElement& e,
                      ::Xsd::XmlSchema::Flags f,
                      ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::Type (e, f | ::Xsd::XmlSchema::Flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    service_id_ (this),
    version_ (this),
    description_ (this),
    any_ (this->getDomDocument ()),
    any_attribute_ (this->getDomDocument ())
  {
    if ((f & ::Xsd::XmlSchema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ServiceDescription::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::Xsd::XmlSchema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // service-id
      //
      if (n.name () == "service-id" && n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
      {
        ::std::unique_ptr< ServiceIdType > r (
          ServiceIdTraits::create (i, f, this));

        if (!service_id_.present ())
        {
          this->service_id_.set (::std::move (r));
          continue;
        }
      }

      // version
      //
      if (n.name () == "version" && n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
      {
        ::std::unique_ptr< VersionType > r (
          VersionTraits::create (i, f, this));

        if (!version_.present ())
        {
          this->version_.set (::std::move (r));
          continue;
        }
      }

      // description
      //
      if (n.name () == "description" && n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
      {
        ::std::unique_ptr< DescriptionType > r (
          DescriptionTraits::create (i, f, this));

        if (!this->description_)
        {
          this->description_.set (::std::move (r));
          continue;
        }
      }

      // any
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "urn:oma:xml:prs:pidf:oma-pres"))
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_.push_back (r);
        continue;
      }

      break;
    }

    if (!service_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "service-id",
        "urn:oma:xml:prs:pidf:oma-pres");
    }

    if (!version_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "version",
        "urn:oma:xml:prs:pidf:oma-pres");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // any_attribute
      //
      if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
           n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
      {
        ::xercesc::DOMAttr* r (
          static_cast< ::xercesc::DOMAttr* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMAttr* > (&i), true)));
        this->any_attribute_ .insert (r);
        continue;
      }
    }
  }

  ServiceDescription* ServiceDescription::
  _clone (::Xsd::XmlSchema::Flags f,
          ::Xsd::XmlSchema::Container* c) const
  {
    return new class ServiceDescription (*this, f, c);
  }

  ServiceDescription& ServiceDescription::
  operator= (const ServiceDescription& x)
  {
    if (this != &x)
    {
      static_cast< ::Xsd::XmlSchema::Type& > (*this) = x;
      this->service_id_ = x.service_id_;
      this->version_ = x.version_;
      this->description_ = x.description_;
      this->any_ = x.any_;
      this->any_attribute_ = x.any_attribute_;
    }

    return *this;
  }

  ServiceDescription::
  ~ServiceDescription ()
  {
  }

  // Willingness
  //

  Willingness::
  Willingness ()
  : ::Xsd::XmlSchema::Type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    basic_ (this),
    any_ (this->getDomDocument ()),
    any_attribute_ (this->getDomDocument ())
  {
  }

  Willingness::
  Willingness (const Willingness& x,
               ::Xsd::XmlSchema::Flags f,
               ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::Type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    basic_ (x.basic_, f, this),
    any_ (x.any_, this->getDomDocument ()),
    any_attribute_ (x.any_attribute_, this->getDomDocument ())
  {
  }

  Willingness::
  Willingness (const ::xercesc::DOMElement& e,
               ::Xsd::XmlSchema::Flags f,
               ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::Type (e, f | ::Xsd::XmlSchema::Flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    basic_ (this),
    any_ (this->getDomDocument ()),
    any_attribute_ (this->getDomDocument ())
  {
    if ((f & ::Xsd::XmlSchema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Willingness::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::Xsd::XmlSchema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // basic
      //
      if (n.name () == "basic" && n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
      {
        ::std::unique_ptr< BasicType > r (
          BasicTraits::create (i, f, this));

        if (!this->basic_)
        {
          this->basic_.set (::std::move (r));
          continue;
        }
      }

      // any
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "urn:oma:xml:prs:pidf:oma-pres"))
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // any_attribute
      //
      if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
           n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
      {
        ::xercesc::DOMAttr* r (
          static_cast< ::xercesc::DOMAttr* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMAttr* > (&i), true)));
        this->any_attribute_ .insert (r);
        continue;
      }
    }
  }

  Willingness* Willingness::
  _clone (::Xsd::XmlSchema::Flags f,
          ::Xsd::XmlSchema::Container* c) const
  {
    return new class Willingness (*this, f, c);
  }

  Willingness& Willingness::
  operator= (const Willingness& x)
  {
    if (this != &x)
    {
      static_cast< ::Xsd::XmlSchema::Type& > (*this) = x;
      this->basic_ = x.basic_;
      this->any_ = x.any_;
      this->any_attribute_ = x.any_attribute_;
    }

    return *this;
  }

  Willingness::
  ~Willingness ()
  {
  }

  // SessionParticipation
  //

  SessionParticipation::
  SessionParticipation ()
  : ::Xsd::XmlSchema::Type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    basic_ (this),
    any_ (this->getDomDocument ()),
    any_attribute_ (this->getDomDocument ())
  {
  }

  SessionParticipation::
  SessionParticipation (const SessionParticipation& x,
                        ::Xsd::XmlSchema::Flags f,
                        ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::Type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    basic_ (x.basic_, f, this),
    any_ (x.any_, this->getDomDocument ()),
    any_attribute_ (x.any_attribute_, this->getDomDocument ())
  {
  }

  SessionParticipation::
  SessionParticipation (const ::xercesc::DOMElement& e,
                        ::Xsd::XmlSchema::Flags f,
                        ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::Type (e, f | ::Xsd::XmlSchema::Flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    basic_ (this),
    any_ (this->getDomDocument ()),
    any_attribute_ (this->getDomDocument ())
  {
    if ((f & ::Xsd::XmlSchema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SessionParticipation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::Xsd::XmlSchema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // basic
      //
      if (n.name () == "basic" && n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
      {
        ::std::unique_ptr< BasicType > r (
          BasicTraits::create (i, f, this));

        if (!this->basic_)
        {
          this->basic_.set (::std::move (r));
          continue;
        }
      }

      // any
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "urn:oma:xml:prs:pidf:oma-pres"))
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // any_attribute
      //
      if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
           n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
      {
        ::xercesc::DOMAttr* r (
          static_cast< ::xercesc::DOMAttr* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMAttr* > (&i), true)));
        this->any_attribute_ .insert (r);
        continue;
      }
    }
  }

  SessionParticipation* SessionParticipation::
  _clone (::Xsd::XmlSchema::Flags f,
          ::Xsd::XmlSchema::Container* c) const
  {
    return new class SessionParticipation (*this, f, c);
  }

  SessionParticipation& SessionParticipation::
  operator= (const SessionParticipation& x)
  {
    if (this != &x)
    {
      static_cast< ::Xsd::XmlSchema::Type& > (*this) = x;
      this->basic_ = x.basic_;
      this->any_ = x.any_;
      this->any_attribute_ = x.any_attribute_;
    }

    return *this;
  }

  SessionParticipation::
  ~SessionParticipation ()
  {
  }

  // RegistrationState
  //

  RegistrationState::
  RegistrationState (::oma_pres::RegistrationType::Value _xsd_RegistrationType_base)
  : ::oma_pres::RegistrationType (_xsd_RegistrationType_base),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_attribute_ (this->getDomDocument ())
  {
  }

  RegistrationState::
  RegistrationState (const char* _xsd_String_base)
  : ::oma_pres::RegistrationType (_xsd_String_base),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_attribute_ (this->getDomDocument ())
  {
  }

  RegistrationState::
  RegistrationState (const ::std::string& _xsd_String_base)
  : ::oma_pres::RegistrationType (_xsd_String_base),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_attribute_ (this->getDomDocument ())
  {
  }

  RegistrationState::
  RegistrationState (const ::oma_pres::RegistrationType& _xsd_RegistrationType_base)
  : ::oma_pres::RegistrationType (_xsd_RegistrationType_base),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_attribute_ (this->getDomDocument ())
  {
  }

  RegistrationState::
  RegistrationState (const RegistrationState& x,
                     ::Xsd::XmlSchema::Flags f,
                     ::Xsd::XmlSchema::Container* c)
  : ::oma_pres::RegistrationType (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_attribute_ (x.any_attribute_, this->getDomDocument ())
  {
  }

  RegistrationState::
  RegistrationState (const ::xercesc::DOMElement& e,
                     ::Xsd::XmlSchema::Flags f,
                     ::Xsd::XmlSchema::Container* c)
  : ::oma_pres::RegistrationType (e, f | ::Xsd::XmlSchema::Flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_attribute_ (this->getDomDocument ())
  {
    if ((f & ::Xsd::XmlSchema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void RegistrationState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::Xsd::XmlSchema::Flags)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // any_attribute
      //
      if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
           n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
      {
        ::xercesc::DOMAttr* r (
          static_cast< ::xercesc::DOMAttr* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMAttr* > (&i), true)));
        this->any_attribute_ .insert (r);
        continue;
      }
    }
  }

  RegistrationState* RegistrationState::
  _clone (::Xsd::XmlSchema::Flags f,
          ::Xsd::XmlSchema::Container* c) const
  {
    return new class RegistrationState (*this, f, c);
  }

  RegistrationState& RegistrationState::
  operator= (const RegistrationState& x)
  {
    if (this != &x)
    {
      static_cast< ::oma_pres::RegistrationType& > (*this) = x;
      this->any_attribute_ = x.any_attribute_;
    }

    return *this;
  }

  RegistrationState::
  ~RegistrationState ()
  {
  }

  // BarringState
  //

  BarringState::
  BarringState (::oma_pres::BarringType::Value _xsd_BarringType_base)
  : ::oma_pres::BarringType (_xsd_BarringType_base),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_attribute_ (this->getDomDocument ())
  {
  }

  BarringState::
  BarringState (const char* _xsd_String_base)
  : ::oma_pres::BarringType (_xsd_String_base),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_attribute_ (this->getDomDocument ())
  {
  }

  BarringState::
  BarringState (const ::std::string& _xsd_String_base)
  : ::oma_pres::BarringType (_xsd_String_base),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_attribute_ (this->getDomDocument ())
  {
  }

  BarringState::
  BarringState (const ::oma_pres::BarringType& _xsd_BarringType_base)
  : ::oma_pres::BarringType (_xsd_BarringType_base),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_attribute_ (this->getDomDocument ())
  {
  }

  BarringState::
  BarringState (const BarringState& x,
                ::Xsd::XmlSchema::Flags f,
                ::Xsd::XmlSchema::Container* c)
  : ::oma_pres::BarringType (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_attribute_ (x.any_attribute_, this->getDomDocument ())
  {
  }

  BarringState::
  BarringState (const ::xercesc::DOMElement& e,
                ::Xsd::XmlSchema::Flags f,
                ::Xsd::XmlSchema::Container* c)
  : ::oma_pres::BarringType (e, f | ::Xsd::XmlSchema::Flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_attribute_ (this->getDomDocument ())
  {
    if ((f & ::Xsd::XmlSchema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void BarringState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::Xsd::XmlSchema::Flags)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // any_attribute
      //
      if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
           n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
      {
        ::xercesc::DOMAttr* r (
          static_cast< ::xercesc::DOMAttr* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMAttr* > (&i), true)));
        this->any_attribute_ .insert (r);
        continue;
      }
    }
  }

  BarringState* BarringState::
  _clone (::Xsd::XmlSchema::Flags f,
          ::Xsd::XmlSchema::Container* c) const
  {
    return new class BarringState (*this, f, c);
  }

  BarringState& BarringState::
  operator= (const BarringState& x)
  {
    if (this != &x)
    {
      static_cast< ::oma_pres::BarringType& > (*this) = x;
      this->any_attribute_ = x.any_attribute_;
    }

    return *this;
  }

  BarringState::
  ~BarringState ()
  {
  }

  // OverridingWillingness
  //

  OverridingWillingness::
  OverridingWillingness ()
  : ::Xsd::XmlSchema::Type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    basic_ (this),
    any_ (this->getDomDocument ()),
    any_attribute_ (this->getDomDocument ())
  {
  }

  OverridingWillingness::
  OverridingWillingness (const OverridingWillingness& x,
                         ::Xsd::XmlSchema::Flags f,
                         ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::Type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    basic_ (x.basic_, f, this),
    any_ (x.any_, this->getDomDocument ()),
    any_attribute_ (x.any_attribute_, this->getDomDocument ())
  {
  }

  OverridingWillingness::
  OverridingWillingness (const ::xercesc::DOMElement& e,
                         ::Xsd::XmlSchema::Flags f,
                         ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::Type (e, f | ::Xsd::XmlSchema::Flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    basic_ (this),
    any_ (this->getDomDocument ()),
    any_attribute_ (this->getDomDocument ())
  {
    if ((f & ::Xsd::XmlSchema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void OverridingWillingness::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::Xsd::XmlSchema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // basic
      //
      if (n.name () == "basic" && n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
      {
        ::std::unique_ptr< BasicType > r (
          BasicTraits::create (i, f, this));

        if (!this->basic_)
        {
          this->basic_.set (::std::move (r));
          continue;
        }
      }

      // any
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "urn:oma:xml:prs:pidf:oma-pres"))
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // any_attribute
      //
      if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
           n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
      {
        ::xercesc::DOMAttr* r (
          static_cast< ::xercesc::DOMAttr* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMAttr* > (&i), true)));
        this->any_attribute_ .insert (r);
        continue;
      }
    }
  }

  OverridingWillingness* OverridingWillingness::
  _clone (::Xsd::XmlSchema::Flags f,
          ::Xsd::XmlSchema::Container* c) const
  {
    return new class OverridingWillingness (*this, f, c);
  }

  OverridingWillingness& OverridingWillingness::
  operator= (const OverridingWillingness& x)
  {
    if (this != &x)
    {
      static_cast< ::Xsd::XmlSchema::Type& > (*this) = x;
      this->basic_ = x.basic_;
      this->any_ = x.any_;
      this->any_attribute_ = x.any_attribute_;
    }

    return *this;
  }

  OverridingWillingness::
  ~OverridingWillingness ()
  {
  }

  // NetworkAvailability
  //

  NetworkAvailability::
  NetworkAvailability ()
  : ::Xsd::XmlSchema::Type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    network_ (this),
    any_ (this->getDomDocument ()),
    any_attribute_ (this->getDomDocument ())
  {
  }

  NetworkAvailability::
  NetworkAvailability (const NetworkAvailability& x,
                       ::Xsd::XmlSchema::Flags f,
                       ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::Type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    network_ (x.network_, f, this),
    any_ (x.any_, this->getDomDocument ()),
    any_attribute_ (x.any_attribute_, this->getDomDocument ())
  {
  }

  NetworkAvailability::
  NetworkAvailability (const ::xercesc::DOMElement& e,
                       ::Xsd::XmlSchema::Flags f,
                       ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::Type (e, f | ::Xsd::XmlSchema::Flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    network_ (this),
    any_ (this->getDomDocument ()),
    any_attribute_ (this->getDomDocument ())
  {
    if ((f & ::Xsd::XmlSchema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void NetworkAvailability::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::Xsd::XmlSchema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // network
      //
      if (n.name () == "network" && n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
      {
        ::std::unique_ptr< NetworkType > r (
          NetworkTraits::create (i, f, this));

        this->network_.push_back (::std::move (r));
        continue;
      }

      // any
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "urn:oma:xml:prs:pidf:oma-pres"))
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // any_attribute
      //
      if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
           n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
      {
        ::xercesc::DOMAttr* r (
          static_cast< ::xercesc::DOMAttr* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMAttr* > (&i), true)));
        this->any_attribute_ .insert (r);
        continue;
      }
    }
  }

  NetworkAvailability* NetworkAvailability::
  _clone (::Xsd::XmlSchema::Flags f,
          ::Xsd::XmlSchema::Container* c) const
  {
    return new class NetworkAvailability (*this, f, c);
  }

  NetworkAvailability& NetworkAvailability::
  operator= (const NetworkAvailability& x)
  {
    if (this != &x)
    {
      static_cast< ::Xsd::XmlSchema::Type& > (*this) = x;
      this->network_ = x.network_;
      this->any_ = x.any_;
      this->any_attribute_ = x.any_attribute_;
    }

    return *this;
  }

  NetworkAvailability::
  ~NetworkAvailability ()
  {
  }

  // Network
  //

  Network::
  Network (const IdType& id)
  : ::Xsd::XmlSchema::Type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    active_ (this),
    terminated_ (this),
    any_ (this->getDomDocument ()),
    id_ (id, this),
    any_attribute_ (this->getDomDocument ())
  {
  }

  Network::
  Network (const Network& x,
           ::Xsd::XmlSchema::Flags f,
           ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::Type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    active_ (x.active_, f, this),
    terminated_ (x.terminated_, f, this),
    any_ (x.any_, this->getDomDocument ()),
    id_ (x.id_, f, this),
    any_attribute_ (x.any_attribute_, this->getDomDocument ())
  {
  }

  Network::
  Network (const ::xercesc::DOMElement& e,
           ::Xsd::XmlSchema::Flags f,
           ::Xsd::XmlSchema::Container* c)
  : ::Xsd::XmlSchema::Type (e, f | ::Xsd::XmlSchema::Flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    active_ (this),
    terminated_ (this),
    any_ (this->getDomDocument ()),
    id_ (this),
    any_attribute_ (this->getDomDocument ())
  {
    if ((f & ::Xsd::XmlSchema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Network::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::Xsd::XmlSchema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // active
      //
      if (n.name () == "active" && n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
      {
        ::std::unique_ptr< ActiveType > r (
          ActiveTraits::create (i, f, this));

        if (!this->active_)
        {
          this->active_.set (::std::move (r));
          continue;
        }
      }

      // terminated
      //
      if (n.name () == "terminated" && n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
      {
        ::std::unique_ptr< TerminatedType > r (
          TerminatedTraits::create (i, f, this));

        if (!this->terminated_)
        {
          this->terminated_.set (::std::move (r));
          continue;
        }
      }

      // any
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "urn:oma:xml:prs:pidf:oma-pres"))
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (IdTraits::create (i, f, this));
        continue;
      }

      // any_attribute
      //
      if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
           n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
      {
        ::xercesc::DOMAttr* r (
          static_cast< ::xercesc::DOMAttr* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMAttr* > (&i), true)));
        this->any_attribute_ .insert (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  Network* Network::
  _clone (::Xsd::XmlSchema::Flags f,
          ::Xsd::XmlSchema::Container* c) const
  {
    return new class Network (*this, f, c);
  }

  Network& Network::
  operator= (const Network& x)
  {
    if (this != &x)
    {
      static_cast< ::Xsd::XmlSchema::Type& > (*this) = x;
      this->active_ = x.active_;
      this->terminated_ = x.terminated_;
      this->any_ = x.any_;
      this->id_ = x.id_;
      this->any_attribute_ = x.any_attribute_;
    }

    return *this;
  }

  Network::
  ~Network ()
  {
  }
}

#include <ostream>

namespace oma_pres
{
  ::std::ostream&
  operator<< (::std::ostream& o, BasicType::Value i)
  {
    return o << BasicType::_xsd_BasicType_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const BasicType& i)
  {
    return o << static_cast< const ::Xsd::XmlSchema::String& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const EmptyType&)
  {
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, RegistrationType::Value i)
  {
    return o << RegistrationType::_xsd_RegistrationType_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const RegistrationType& i)
  {
    return o << static_cast< const ::Xsd::XmlSchema::String& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, BarringType::Value i)
  {
    return o << BarringType::_xsd_BarringType_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const BarringType& i)
  {
    return o << static_cast< const ::Xsd::XmlSchema::String& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ServiceDescription& i)
  {
    o << ::std::endl << "service-id: " << i.getServiceId ();
    o << ::std::endl << "version: " << i.getVersion ();
    if (i.getDescription ())
    {
      o << ::std::endl << "description: " << *i.getDescription ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Willingness& i)
  {
    if (i.getBasic ())
    {
      o << ::std::endl << "basic: " << *i.getBasic ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SessionParticipation& i)
  {
    if (i.getBasic ())
    {
      o << ::std::endl << "basic: " << *i.getBasic ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const RegistrationState& i)
  {
    o << static_cast< const ::oma_pres::RegistrationType& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const BarringState& i)
  {
    o << static_cast< const ::oma_pres::BarringType& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const OverridingWillingness& i)
  {
    if (i.getBasic ())
    {
      o << ::std::endl << "basic: " << *i.getBasic ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const NetworkAvailability& i)
  {
    for (NetworkAvailability::NetworkConstIterator
         b (i.getNetwork ().begin ()), e (i.getNetwork ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "network: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Network& i)
  {
    if (i.getActive ())
    {
      o << ::std::endl << "active: " << *i.getActive ();
    }

    if (i.getTerminated ())
    {
      o << ::std::endl << "terminated: " << *i.getTerminated ();
    }

    o << ::std::endl << "id: " << i.getId ();
    return o;
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace oma_pres
{
  ::std::unique_ptr< ::oma_pres::ServiceDescription >
  parseServiceDescription (const ::std::string& u,
                           ::Xsd::XmlSchema::Flags f,
                           const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::oma_pres::ServiceDescription > (
      ::oma_pres::parseServiceDescription (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::ServiceDescription >
  parseServiceDescription (const ::std::string& u,
                           ::Xsd::XmlSchema::ErrorHandler& h,
                           ::Xsd::XmlSchema::Flags f,
                           const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::ServiceDescription > (
      ::oma_pres::parseServiceDescription (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::ServiceDescription >
  parseServiceDescription (const ::std::string& u,
                           ::xercesc::DOMErrorHandler& h,
                           ::Xsd::XmlSchema::Flags f,
                           const ::Xsd::XmlSchema::Properties& p)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::ServiceDescription > (
      ::oma_pres::parseServiceDescription (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::ServiceDescription >
  parseServiceDescription (::std::istream& is,
                           ::Xsd::XmlSchema::Flags f,
                           const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::oma_pres::parseServiceDescription (isrc, f, p);
  }

  ::std::unique_ptr< ::oma_pres::ServiceDescription >
  parseServiceDescription (::std::istream& is,
                           ::Xsd::XmlSchema::ErrorHandler& h,
                           ::Xsd::XmlSchema::Flags f,
                           const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::oma_pres::parseServiceDescription (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::ServiceDescription >
  parseServiceDescription (::std::istream& is,
                           ::xercesc::DOMErrorHandler& h,
                           ::Xsd::XmlSchema::Flags f,
                           const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::oma_pres::parseServiceDescription (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::ServiceDescription >
  parseServiceDescription (::std::istream& is,
                           const ::std::string& sid,
                           ::Xsd::XmlSchema::Flags f,
                           const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::oma_pres::parseServiceDescription (isrc, f, p);
  }

  ::std::unique_ptr< ::oma_pres::ServiceDescription >
  parseServiceDescription (::std::istream& is,
                           const ::std::string& sid,
                           ::Xsd::XmlSchema::ErrorHandler& h,
                           ::Xsd::XmlSchema::Flags f,
                           const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::oma_pres::parseServiceDescription (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::ServiceDescription >
  parseServiceDescription (::std::istream& is,
                           const ::std::string& sid,
                           ::xercesc::DOMErrorHandler& h,
                           ::Xsd::XmlSchema::Flags f,
                           const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::oma_pres::parseServiceDescription (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::ServiceDescription >
  parseServiceDescription (::xercesc::InputSource& i,
                           ::Xsd::XmlSchema::Flags f,
                           const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::oma_pres::ServiceDescription > (
      ::oma_pres::parseServiceDescription (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::ServiceDescription >
  parseServiceDescription (::xercesc::InputSource& i,
                           ::Xsd::XmlSchema::ErrorHandler& h,
                           ::Xsd::XmlSchema::Flags f,
                           const ::Xsd::XmlSchema::Properties& p)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::ServiceDescription > (
      ::oma_pres::parseServiceDescription (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::ServiceDescription >
  parseServiceDescription (::xercesc::InputSource& i,
                           ::xercesc::DOMErrorHandler& h,
                           ::Xsd::XmlSchema::Flags f,
                           const ::Xsd::XmlSchema::Properties& p)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::ServiceDescription > (
      ::oma_pres::parseServiceDescription (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::ServiceDescription >
  parseServiceDescription (const ::xercesc::DOMDocument& doc,
                           ::Xsd::XmlSchema::Flags f,
                           const ::Xsd::XmlSchema::Properties& p)
  {
    if (f & ::Xsd::XmlSchema::Flags::keep_dom)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::oma_pres::ServiceDescription > (
        ::oma_pres::parseServiceDescription (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "service-description" &&
        n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
    {
      ::std::unique_ptr< ::oma_pres::ServiceDescription > r (
        ::xsd::cxx::tree::traits< ::oma_pres::ServiceDescription, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "service-description",
      "urn:oma:xml:prs:pidf:oma-pres");
  }

  ::std::unique_ptr< ::oma_pres::ServiceDescription >
  parseServiceDescription (::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                           ::Xsd::XmlSchema::Flags f,
                           const ::Xsd::XmlSchema::Properties&)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::Xsd::XmlSchema::Flags::keep_dom) &&
       !(f & ::Xsd::XmlSchema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::Xsd::XmlSchema::Flags::keep_dom)
      doc.setUserData (::Xsd::XmlSchema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "service-description" &&
        n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
    {
      ::std::unique_ptr< ::oma_pres::ServiceDescription > r (
        ::xsd::cxx::tree::traits< ::oma_pres::ServiceDescription, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "service-description",
      "urn:oma:xml:prs:pidf:oma-pres");
  }

  ::std::unique_ptr< ::oma_pres::Willingness >
  parseWillingness (const ::std::string& u,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::oma_pres::Willingness > (
      ::oma_pres::parseWillingness (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::Willingness >
  parseWillingness (const ::std::string& u,
                    ::Xsd::XmlSchema::ErrorHandler& h,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::Willingness > (
      ::oma_pres::parseWillingness (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::Willingness >
  parseWillingness (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::Willingness > (
      ::oma_pres::parseWillingness (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::Willingness >
  parseWillingness (::std::istream& is,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::oma_pres::parseWillingness (isrc, f, p);
  }

  ::std::unique_ptr< ::oma_pres::Willingness >
  parseWillingness (::std::istream& is,
                    ::Xsd::XmlSchema::ErrorHandler& h,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::oma_pres::parseWillingness (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::Willingness >
  parseWillingness (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::oma_pres::parseWillingness (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::Willingness >
  parseWillingness (::std::istream& is,
                    const ::std::string& sid,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::oma_pres::parseWillingness (isrc, f, p);
  }

  ::std::unique_ptr< ::oma_pres::Willingness >
  parseWillingness (::std::istream& is,
                    const ::std::string& sid,
                    ::Xsd::XmlSchema::ErrorHandler& h,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::oma_pres::parseWillingness (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::Willingness >
  parseWillingness (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::oma_pres::parseWillingness (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::Willingness >
  parseWillingness (::xercesc::InputSource& i,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::oma_pres::Willingness > (
      ::oma_pres::parseWillingness (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::Willingness >
  parseWillingness (::xercesc::InputSource& i,
                    ::Xsd::XmlSchema::ErrorHandler& h,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::Willingness > (
      ::oma_pres::parseWillingness (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::Willingness >
  parseWillingness (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::Willingness > (
      ::oma_pres::parseWillingness (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::Willingness >
  parseWillingness (const ::xercesc::DOMDocument& doc,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties& p)
  {
    if (f & ::Xsd::XmlSchema::Flags::keep_dom)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::oma_pres::Willingness > (
        ::oma_pres::parseWillingness (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "willingness" &&
        n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
    {
      ::std::unique_ptr< ::oma_pres::Willingness > r (
        ::xsd::cxx::tree::traits< ::oma_pres::Willingness, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "willingness",
      "urn:oma:xml:prs:pidf:oma-pres");
  }

  ::std::unique_ptr< ::oma_pres::Willingness >
  parseWillingness (::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                    ::Xsd::XmlSchema::Flags f,
                    const ::Xsd::XmlSchema::Properties&)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::Xsd::XmlSchema::Flags::keep_dom) &&
       !(f & ::Xsd::XmlSchema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::Xsd::XmlSchema::Flags::keep_dom)
      doc.setUserData (::Xsd::XmlSchema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "willingness" &&
        n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
    {
      ::std::unique_ptr< ::oma_pres::Willingness > r (
        ::xsd::cxx::tree::traits< ::oma_pres::Willingness, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "willingness",
      "urn:oma:xml:prs:pidf:oma-pres");
  }

  ::std::unique_ptr< ::oma_pres::SessionParticipation >
  parseSessionParticipation (const ::std::string& u,
                             ::Xsd::XmlSchema::Flags f,
                             const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::oma_pres::SessionParticipation > (
      ::oma_pres::parseSessionParticipation (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::SessionParticipation >
  parseSessionParticipation (const ::std::string& u,
                             ::Xsd::XmlSchema::ErrorHandler& h,
                             ::Xsd::XmlSchema::Flags f,
                             const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::SessionParticipation > (
      ::oma_pres::parseSessionParticipation (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::SessionParticipation >
  parseSessionParticipation (const ::std::string& u,
                             ::xercesc::DOMErrorHandler& h,
                             ::Xsd::XmlSchema::Flags f,
                             const ::Xsd::XmlSchema::Properties& p)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::SessionParticipation > (
      ::oma_pres::parseSessionParticipation (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::SessionParticipation >
  parseSessionParticipation (::std::istream& is,
                             ::Xsd::XmlSchema::Flags f,
                             const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::oma_pres::parseSessionParticipation (isrc, f, p);
  }

  ::std::unique_ptr< ::oma_pres::SessionParticipation >
  parseSessionParticipation (::std::istream& is,
                             ::Xsd::XmlSchema::ErrorHandler& h,
                             ::Xsd::XmlSchema::Flags f,
                             const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::oma_pres::parseSessionParticipation (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::SessionParticipation >
  parseSessionParticipation (::std::istream& is,
                             ::xercesc::DOMErrorHandler& h,
                             ::Xsd::XmlSchema::Flags f,
                             const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::oma_pres::parseSessionParticipation (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::SessionParticipation >
  parseSessionParticipation (::std::istream& is,
                             const ::std::string& sid,
                             ::Xsd::XmlSchema::Flags f,
                             const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::oma_pres::parseSessionParticipation (isrc, f, p);
  }

  ::std::unique_ptr< ::oma_pres::SessionParticipation >
  parseSessionParticipation (::std::istream& is,
                             const ::std::string& sid,
                             ::Xsd::XmlSchema::ErrorHandler& h,
                             ::Xsd::XmlSchema::Flags f,
                             const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::oma_pres::parseSessionParticipation (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::SessionParticipation >
  parseSessionParticipation (::std::istream& is,
                             const ::std::string& sid,
                             ::xercesc::DOMErrorHandler& h,
                             ::Xsd::XmlSchema::Flags f,
                             const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::oma_pres::parseSessionParticipation (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::SessionParticipation >
  parseSessionParticipation (::xercesc::InputSource& i,
                             ::Xsd::XmlSchema::Flags f,
                             const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::oma_pres::SessionParticipation > (
      ::oma_pres::parseSessionParticipation (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::SessionParticipation >
  parseSessionParticipation (::xercesc::InputSource& i,
                             ::Xsd::XmlSchema::ErrorHandler& h,
                             ::Xsd::XmlSchema::Flags f,
                             const ::Xsd::XmlSchema::Properties& p)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::SessionParticipation > (
      ::oma_pres::parseSessionParticipation (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::SessionParticipation >
  parseSessionParticipation (::xercesc::InputSource& i,
                             ::xercesc::DOMErrorHandler& h,
                             ::Xsd::XmlSchema::Flags f,
                             const ::Xsd::XmlSchema::Properties& p)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::SessionParticipation > (
      ::oma_pres::parseSessionParticipation (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::SessionParticipation >
  parseSessionParticipation (const ::xercesc::DOMDocument& doc,
                             ::Xsd::XmlSchema::Flags f,
                             const ::Xsd::XmlSchema::Properties& p)
  {
    if (f & ::Xsd::XmlSchema::Flags::keep_dom)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::oma_pres::SessionParticipation > (
        ::oma_pres::parseSessionParticipation (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "session-participation" &&
        n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
    {
      ::std::unique_ptr< ::oma_pres::SessionParticipation > r (
        ::xsd::cxx::tree::traits< ::oma_pres::SessionParticipation, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "session-participation",
      "urn:oma:xml:prs:pidf:oma-pres");
  }

  ::std::unique_ptr< ::oma_pres::SessionParticipation >
  parseSessionParticipation (::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                             ::Xsd::XmlSchema::Flags f,
                             const ::Xsd::XmlSchema::Properties&)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::Xsd::XmlSchema::Flags::keep_dom) &&
       !(f & ::Xsd::XmlSchema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::Xsd::XmlSchema::Flags::keep_dom)
      doc.setUserData (::Xsd::XmlSchema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "session-participation" &&
        n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
    {
      ::std::unique_ptr< ::oma_pres::SessionParticipation > r (
        ::xsd::cxx::tree::traits< ::oma_pres::SessionParticipation, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "session-participation",
      "urn:oma:xml:prs:pidf:oma-pres");
  }

  ::std::unique_ptr< ::oma_pres::RegistrationState >
  parseRegistrationState (const ::std::string& u,
                          ::Xsd::XmlSchema::Flags f,
                          const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::oma_pres::RegistrationState > (
      ::oma_pres::parseRegistrationState (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::RegistrationState >
  parseRegistrationState (const ::std::string& u,
                          ::Xsd::XmlSchema::ErrorHandler& h,
                          ::Xsd::XmlSchema::Flags f,
                          const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::RegistrationState > (
      ::oma_pres::parseRegistrationState (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::RegistrationState >
  parseRegistrationState (const ::std::string& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::Xsd::XmlSchema::Flags f,
                          const ::Xsd::XmlSchema::Properties& p)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::RegistrationState > (
      ::oma_pres::parseRegistrationState (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::RegistrationState >
  parseRegistrationState (::std::istream& is,
                          ::Xsd::XmlSchema::Flags f,
                          const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::oma_pres::parseRegistrationState (isrc, f, p);
  }

  ::std::unique_ptr< ::oma_pres::RegistrationState >
  parseRegistrationState (::std::istream& is,
                          ::Xsd::XmlSchema::ErrorHandler& h,
                          ::Xsd::XmlSchema::Flags f,
                          const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::oma_pres::parseRegistrationState (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::RegistrationState >
  parseRegistrationState (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::Xsd::XmlSchema::Flags f,
                          const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::oma_pres::parseRegistrationState (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::RegistrationState >
  parseRegistrationState (::std::istream& is,
                          const ::std::string& sid,
                          ::Xsd::XmlSchema::Flags f,
                          const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::oma_pres::parseRegistrationState (isrc, f, p);
  }

  ::std::unique_ptr< ::oma_pres::RegistrationState >
  parseRegistrationState (::std::istream& is,
                          const ::std::string& sid,
                          ::Xsd::XmlSchema::ErrorHandler& h,
                          ::Xsd::XmlSchema::Flags f,
                          const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::oma_pres::parseRegistrationState (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::RegistrationState >
  parseRegistrationState (::std::istream& is,
                          const ::std::string& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::Xsd::XmlSchema::Flags f,
                          const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::oma_pres::parseRegistrationState (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::RegistrationState >
  parseRegistrationState (::xercesc::InputSource& i,
                          ::Xsd::XmlSchema::Flags f,
                          const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::oma_pres::RegistrationState > (
      ::oma_pres::parseRegistrationState (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::RegistrationState >
  parseRegistrationState (::xercesc::InputSource& i,
                          ::Xsd::XmlSchema::ErrorHandler& h,
                          ::Xsd::XmlSchema::Flags f,
                          const ::Xsd::XmlSchema::Properties& p)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::RegistrationState > (
      ::oma_pres::parseRegistrationState (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::RegistrationState >
  parseRegistrationState (::xercesc::InputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::Xsd::XmlSchema::Flags f,
                          const ::Xsd::XmlSchema::Properties& p)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::RegistrationState > (
      ::oma_pres::parseRegistrationState (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::RegistrationState >
  parseRegistrationState (const ::xercesc::DOMDocument& doc,
                          ::Xsd::XmlSchema::Flags f,
                          const ::Xsd::XmlSchema::Properties& p)
  {
    if (f & ::Xsd::XmlSchema::Flags::keep_dom)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::oma_pres::RegistrationState > (
        ::oma_pres::parseRegistrationState (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "registration-state" &&
        n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
    {
      ::std::unique_ptr< ::oma_pres::RegistrationState > r (
        ::xsd::cxx::tree::traits< ::oma_pres::RegistrationState, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "registration-state",
      "urn:oma:xml:prs:pidf:oma-pres");
  }

  ::std::unique_ptr< ::oma_pres::RegistrationState >
  parseRegistrationState (::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                          ::Xsd::XmlSchema::Flags f,
                          const ::Xsd::XmlSchema::Properties&)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::Xsd::XmlSchema::Flags::keep_dom) &&
       !(f & ::Xsd::XmlSchema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::Xsd::XmlSchema::Flags::keep_dom)
      doc.setUserData (::Xsd::XmlSchema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "registration-state" &&
        n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
    {
      ::std::unique_ptr< ::oma_pres::RegistrationState > r (
        ::xsd::cxx::tree::traits< ::oma_pres::RegistrationState, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "registration-state",
      "urn:oma:xml:prs:pidf:oma-pres");
  }

  ::std::unique_ptr< ::oma_pres::BarringState >
  parseBarringState (const ::std::string& u,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::oma_pres::BarringState > (
      ::oma_pres::parseBarringState (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::BarringState >
  parseBarringState (const ::std::string& u,
                     ::Xsd::XmlSchema::ErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::BarringState > (
      ::oma_pres::parseBarringState (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::BarringState >
  parseBarringState (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::BarringState > (
      ::oma_pres::parseBarringState (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::BarringState >
  parseBarringState (::std::istream& is,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::oma_pres::parseBarringState (isrc, f, p);
  }

  ::std::unique_ptr< ::oma_pres::BarringState >
  parseBarringState (::std::istream& is,
                     ::Xsd::XmlSchema::ErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::oma_pres::parseBarringState (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::BarringState >
  parseBarringState (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::oma_pres::parseBarringState (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::BarringState >
  parseBarringState (::std::istream& is,
                     const ::std::string& sid,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::oma_pres::parseBarringState (isrc, f, p);
  }

  ::std::unique_ptr< ::oma_pres::BarringState >
  parseBarringState (::std::istream& is,
                     const ::std::string& sid,
                     ::Xsd::XmlSchema::ErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::oma_pres::parseBarringState (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::BarringState >
  parseBarringState (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::oma_pres::parseBarringState (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::BarringState >
  parseBarringState (::xercesc::InputSource& i,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::oma_pres::BarringState > (
      ::oma_pres::parseBarringState (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::BarringState >
  parseBarringState (::xercesc::InputSource& i,
                     ::Xsd::XmlSchema::ErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::BarringState > (
      ::oma_pres::parseBarringState (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::BarringState >
  parseBarringState (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::BarringState > (
      ::oma_pres::parseBarringState (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::BarringState >
  parseBarringState (const ::xercesc::DOMDocument& doc,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties& p)
  {
    if (f & ::Xsd::XmlSchema::Flags::keep_dom)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::oma_pres::BarringState > (
        ::oma_pres::parseBarringState (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "barring-state" &&
        n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
    {
      ::std::unique_ptr< ::oma_pres::BarringState > r (
        ::xsd::cxx::tree::traits< ::oma_pres::BarringState, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "barring-state",
      "urn:oma:xml:prs:pidf:oma-pres");
  }

  ::std::unique_ptr< ::oma_pres::BarringState >
  parseBarringState (::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                     ::Xsd::XmlSchema::Flags f,
                     const ::Xsd::XmlSchema::Properties&)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::Xsd::XmlSchema::Flags::keep_dom) &&
       !(f & ::Xsd::XmlSchema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::Xsd::XmlSchema::Flags::keep_dom)
      doc.setUserData (::Xsd::XmlSchema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "barring-state" &&
        n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
    {
      ::std::unique_ptr< ::oma_pres::BarringState > r (
        ::xsd::cxx::tree::traits< ::oma_pres::BarringState, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "barring-state",
      "urn:oma:xml:prs:pidf:oma-pres");
  }

  ::std::unique_ptr< ::oma_pres::OverridingWillingness >
  parseOverridingWillingness (const ::std::string& u,
                              ::Xsd::XmlSchema::Flags f,
                              const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::oma_pres::OverridingWillingness > (
      ::oma_pres::parseOverridingWillingness (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::OverridingWillingness >
  parseOverridingWillingness (const ::std::string& u,
                              ::Xsd::XmlSchema::ErrorHandler& h,
                              ::Xsd::XmlSchema::Flags f,
                              const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::OverridingWillingness > (
      ::oma_pres::parseOverridingWillingness (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::OverridingWillingness >
  parseOverridingWillingness (const ::std::string& u,
                              ::xercesc::DOMErrorHandler& h,
                              ::Xsd::XmlSchema::Flags f,
                              const ::Xsd::XmlSchema::Properties& p)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::OverridingWillingness > (
      ::oma_pres::parseOverridingWillingness (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::OverridingWillingness >
  parseOverridingWillingness (::std::istream& is,
                              ::Xsd::XmlSchema::Flags f,
                              const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::oma_pres::parseOverridingWillingness (isrc, f, p);
  }

  ::std::unique_ptr< ::oma_pres::OverridingWillingness >
  parseOverridingWillingness (::std::istream& is,
                              ::Xsd::XmlSchema::ErrorHandler& h,
                              ::Xsd::XmlSchema::Flags f,
                              const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::oma_pres::parseOverridingWillingness (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::OverridingWillingness >
  parseOverridingWillingness (::std::istream& is,
                              ::xercesc::DOMErrorHandler& h,
                              ::Xsd::XmlSchema::Flags f,
                              const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::oma_pres::parseOverridingWillingness (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::OverridingWillingness >
  parseOverridingWillingness (::std::istream& is,
                              const ::std::string& sid,
                              ::Xsd::XmlSchema::Flags f,
                              const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::oma_pres::parseOverridingWillingness (isrc, f, p);
  }

  ::std::unique_ptr< ::oma_pres::OverridingWillingness >
  parseOverridingWillingness (::std::istream& is,
                              const ::std::string& sid,
                              ::Xsd::XmlSchema::ErrorHandler& h,
                              ::Xsd::XmlSchema::Flags f,
                              const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::oma_pres::parseOverridingWillingness (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::OverridingWillingness >
  parseOverridingWillingness (::std::istream& is,
                              const ::std::string& sid,
                              ::xercesc::DOMErrorHandler& h,
                              ::Xsd::XmlSchema::Flags f,
                              const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::oma_pres::parseOverridingWillingness (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::OverridingWillingness >
  parseOverridingWillingness (::xercesc::InputSource& i,
                              ::Xsd::XmlSchema::Flags f,
                              const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::oma_pres::OverridingWillingness > (
      ::oma_pres::parseOverridingWillingness (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::OverridingWillingness >
  parseOverridingWillingness (::xercesc::InputSource& i,
                              ::Xsd::XmlSchema::ErrorHandler& h,
                              ::Xsd::XmlSchema::Flags f,
                              const ::Xsd::XmlSchema::Properties& p)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::OverridingWillingness > (
      ::oma_pres::parseOverridingWillingness (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::OverridingWillingness >
  parseOverridingWillingness (::xercesc::InputSource& i,
                              ::xercesc::DOMErrorHandler& h,
                              ::Xsd::XmlSchema::Flags f,
                              const ::Xsd::XmlSchema::Properties& p)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::OverridingWillingness > (
      ::oma_pres::parseOverridingWillingness (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::OverridingWillingness >
  parseOverridingWillingness (const ::xercesc::DOMDocument& doc,
                              ::Xsd::XmlSchema::Flags f,
                              const ::Xsd::XmlSchema::Properties& p)
  {
    if (f & ::Xsd::XmlSchema::Flags::keep_dom)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::oma_pres::OverridingWillingness > (
        ::oma_pres::parseOverridingWillingness (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "overriding-willingness" &&
        n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
    {
      ::std::unique_ptr< ::oma_pres::OverridingWillingness > r (
        ::xsd::cxx::tree::traits< ::oma_pres::OverridingWillingness, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "overriding-willingness",
      "urn:oma:xml:prs:pidf:oma-pres");
  }

  ::std::unique_ptr< ::oma_pres::OverridingWillingness >
  parseOverridingWillingness (::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                              ::Xsd::XmlSchema::Flags f,
                              const ::Xsd::XmlSchema::Properties&)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::Xsd::XmlSchema::Flags::keep_dom) &&
       !(f & ::Xsd::XmlSchema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::Xsd::XmlSchema::Flags::keep_dom)
      doc.setUserData (::Xsd::XmlSchema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "overriding-willingness" &&
        n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
    {
      ::std::unique_ptr< ::oma_pres::OverridingWillingness > r (
        ::xsd::cxx::tree::traits< ::oma_pres::OverridingWillingness, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "overriding-willingness",
      "urn:oma:xml:prs:pidf:oma-pres");
  }

  ::std::unique_ptr< ::oma_pres::NetworkAvailability >
  parseNetworkAvailability (const ::std::string& u,
                            ::Xsd::XmlSchema::Flags f,
                            const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::oma_pres::NetworkAvailability > (
      ::oma_pres::parseNetworkAvailability (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::NetworkAvailability >
  parseNetworkAvailability (const ::std::string& u,
                            ::Xsd::XmlSchema::ErrorHandler& h,
                            ::Xsd::XmlSchema::Flags f,
                            const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::NetworkAvailability > (
      ::oma_pres::parseNetworkAvailability (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::NetworkAvailability >
  parseNetworkAvailability (const ::std::string& u,
                            ::xercesc::DOMErrorHandler& h,
                            ::Xsd::XmlSchema::Flags f,
                            const ::Xsd::XmlSchema::Properties& p)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::NetworkAvailability > (
      ::oma_pres::parseNetworkAvailability (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::NetworkAvailability >
  parseNetworkAvailability (::std::istream& is,
                            ::Xsd::XmlSchema::Flags f,
                            const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::oma_pres::parseNetworkAvailability (isrc, f, p);
  }

  ::std::unique_ptr< ::oma_pres::NetworkAvailability >
  parseNetworkAvailability (::std::istream& is,
                            ::Xsd::XmlSchema::ErrorHandler& h,
                            ::Xsd::XmlSchema::Flags f,
                            const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::oma_pres::parseNetworkAvailability (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::NetworkAvailability >
  parseNetworkAvailability (::std::istream& is,
                            ::xercesc::DOMErrorHandler& h,
                            ::Xsd::XmlSchema::Flags f,
                            const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::oma_pres::parseNetworkAvailability (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::NetworkAvailability >
  parseNetworkAvailability (::std::istream& is,
                            const ::std::string& sid,
                            ::Xsd::XmlSchema::Flags f,
                            const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::oma_pres::parseNetworkAvailability (isrc, f, p);
  }

  ::std::unique_ptr< ::oma_pres::NetworkAvailability >
  parseNetworkAvailability (::std::istream& is,
                            const ::std::string& sid,
                            ::Xsd::XmlSchema::ErrorHandler& h,
                            ::Xsd::XmlSchema::Flags f,
                            const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0,
      (f & ::Xsd::XmlSchema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::oma_pres::parseNetworkAvailability (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::NetworkAvailability >
  parseNetworkAvailability (::std::istream& is,
                            const ::std::string& sid,
                            ::xercesc::DOMErrorHandler& h,
                            ::Xsd::XmlSchema::Flags f,
                            const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::oma_pres::parseNetworkAvailability (isrc, h, f, p);
  }

  ::std::unique_ptr< ::oma_pres::NetworkAvailability >
  parseNetworkAvailability (::xercesc::InputSource& i,
                            ::Xsd::XmlSchema::Flags f,
                            const ::Xsd::XmlSchema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::oma_pres::NetworkAvailability > (
      ::oma_pres::parseNetworkAvailability (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::NetworkAvailability >
  parseNetworkAvailability (::xercesc::InputSource& i,
                            ::Xsd::XmlSchema::ErrorHandler& h,
                            ::Xsd::XmlSchema::Flags f,
                            const ::Xsd::XmlSchema::Properties& p)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::NetworkAvailability > (
      ::oma_pres::parseNetworkAvailability (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::NetworkAvailability >
  parseNetworkAvailability (::xercesc::InputSource& i,
                            ::xercesc::DOMErrorHandler& h,
                            ::Xsd::XmlSchema::Flags f,
                            const ::Xsd::XmlSchema::Properties& p)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::oma_pres::NetworkAvailability > (
      ::oma_pres::parseNetworkAvailability (
        std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::oma_pres::NetworkAvailability >
  parseNetworkAvailability (const ::xercesc::DOMDocument& doc,
                            ::Xsd::XmlSchema::Flags f,
                            const ::Xsd::XmlSchema::Properties& p)
  {
    if (f & ::Xsd::XmlSchema::Flags::keep_dom)
    {
      ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::oma_pres::NetworkAvailability > (
        ::oma_pres::parseNetworkAvailability (
          std::move (d), f | ::Xsd::XmlSchema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "network-availability" &&
        n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
    {
      ::std::unique_ptr< ::oma_pres::NetworkAvailability > r (
        ::xsd::cxx::tree::traits< ::oma_pres::NetworkAvailability, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "network-availability",
      "urn:oma:xml:prs:pidf:oma-pres");
  }

  ::std::unique_ptr< ::oma_pres::NetworkAvailability >
  parseNetworkAvailability (::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                            ::Xsd::XmlSchema::Flags f,
                            const ::Xsd::XmlSchema::Properties&)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::Xsd::XmlSchema::Flags::keep_dom) &&
       !(f & ::Xsd::XmlSchema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::Xsd::XmlSchema::Flags::keep_dom)
      doc.setUserData (::Xsd::XmlSchema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "network-availability" &&
        n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
    {
      ::std::unique_ptr< ::oma_pres::NetworkAvailability > r (
        ::xsd::cxx::tree::traits< ::oma_pres::NetworkAvailability, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "network-availability",
      "urn:oma:xml:prs:pidf:oma-pres");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace oma_pres
{
  void
  operator<< (::xercesc::DOMElement& e, const BasicType& i)
  {
    e << static_cast< const ::Xsd::XmlSchema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const BasicType& i)
  {
    a << static_cast< const ::Xsd::XmlSchema::String& > (i);
  }

  void
  operator<< (::Xsd::XmlSchema::ListStream& l,
              const BasicType& i)
  {
    l << static_cast< const ::Xsd::XmlSchema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const EmptyType& i)
  {
    e << static_cast< const ::Xsd::XmlSchema::Type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const EmptyType&)
  {
  }

  void
  operator<< (::Xsd::XmlSchema::ListStream&,
              const EmptyType&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e, const RegistrationType& i)
  {
    e << static_cast< const ::Xsd::XmlSchema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const RegistrationType& i)
  {
    a << static_cast< const ::Xsd::XmlSchema::String& > (i);
  }

  void
  operator<< (::Xsd::XmlSchema::ListStream& l,
              const RegistrationType& i)
  {
    l << static_cast< const ::Xsd::XmlSchema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const BarringType& i)
  {
    e << static_cast< const ::Xsd::XmlSchema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const BarringType& i)
  {
    a << static_cast< const ::Xsd::XmlSchema::String& > (i);
  }

  void
  operator<< (::Xsd::XmlSchema::ListStream& l,
              const BarringType& i)
  {
    l << static_cast< const ::Xsd::XmlSchema::String& > (i);
  }

  void
  serializeServiceDescription (::std::ostream& o,
                               const ::oma_pres::ServiceDescription& s,
                               const ::Xsd::XmlSchema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::Xsd::XmlSchema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeServiceDescription (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeServiceDescription (::std::ostream& o,
                               const ::oma_pres::ServiceDescription& s,
                               ::Xsd::XmlSchema::ErrorHandler& h,
                               const ::Xsd::XmlSchema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::Xsd::XmlSchema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeServiceDescription (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeServiceDescription (::std::ostream& o,
                               const ::oma_pres::ServiceDescription& s,
                               ::xercesc::DOMErrorHandler& h,
                               const ::Xsd::XmlSchema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeServiceDescription (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeServiceDescription (::xercesc::XMLFormatTarget& t,
                               const ::oma_pres::ServiceDescription& s,
                               const ::Xsd::XmlSchema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeServiceDescription (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeServiceDescription (::xercesc::XMLFormatTarget& t,
                               const ::oma_pres::ServiceDescription& s,
                               ::Xsd::XmlSchema::ErrorHandler& h,
                               const ::Xsd::XmlSchema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeServiceDescription (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeServiceDescription (::xercesc::XMLFormatTarget& t,
                               const ::oma_pres::ServiceDescription& s,
                               ::xercesc::DOMErrorHandler& h,
                               const ::Xsd::XmlSchema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeServiceDescription (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeServiceDescription (::xercesc::DOMDocument& d,
                               const ::oma_pres::ServiceDescription& s,
                               ::Xsd::XmlSchema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "service-description" &&
        n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "service-description",
        "urn:oma:xml:prs:pidf:oma-pres");
    }
  }

  ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeServiceDescription (const ::oma_pres::ServiceDescription& s,
                               const ::Xsd::XmlSchema::NamespaceInfomap& m,
                               ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "service-description",
        "urn:oma:xml:prs:pidf:oma-pres",
        m, f));

    ::oma_pres::serializeServiceDescription (*d, s, f);
    return d;
  }

  void
  serializeWillingness (::std::ostream& o,
                        const ::oma_pres::Willingness& s,
                        const ::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::Xsd::XmlSchema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeWillingness (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeWillingness (::std::ostream& o,
                        const ::oma_pres::Willingness& s,
                        ::Xsd::XmlSchema::ErrorHandler& h,
                        const ::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::Xsd::XmlSchema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeWillingness (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeWillingness (::std::ostream& o,
                        const ::oma_pres::Willingness& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeWillingness (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeWillingness (::xercesc::XMLFormatTarget& t,
                        const ::oma_pres::Willingness& s,
                        const ::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeWillingness (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeWillingness (::xercesc::XMLFormatTarget& t,
                        const ::oma_pres::Willingness& s,
                        ::Xsd::XmlSchema::ErrorHandler& h,
                        const ::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeWillingness (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeWillingness (::xercesc::XMLFormatTarget& t,
                        const ::oma_pres::Willingness& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeWillingness (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeWillingness (::xercesc::DOMDocument& d,
                        const ::oma_pres::Willingness& s,
                        ::Xsd::XmlSchema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "willingness" &&
        n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "willingness",
        "urn:oma:xml:prs:pidf:oma-pres");
    }
  }

  ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeWillingness (const ::oma_pres::Willingness& s,
                        const ::Xsd::XmlSchema::NamespaceInfomap& m,
                        ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "willingness",
        "urn:oma:xml:prs:pidf:oma-pres",
        m, f));

    ::oma_pres::serializeWillingness (*d, s, f);
    return d;
  }

  void
  serializeSessionParticipation (::std::ostream& o,
                                 const ::oma_pres::SessionParticipation& s,
                                 const ::Xsd::XmlSchema::NamespaceInfomap& m,
                                 const ::std::string& e,
                                 ::Xsd::XmlSchema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeSessionParticipation (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeSessionParticipation (::std::ostream& o,
                                 const ::oma_pres::SessionParticipation& s,
                                 ::Xsd::XmlSchema::ErrorHandler& h,
                                 const ::Xsd::XmlSchema::NamespaceInfomap& m,
                                 const ::std::string& e,
                                 ::Xsd::XmlSchema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeSessionParticipation (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeSessionParticipation (::std::ostream& o,
                                 const ::oma_pres::SessionParticipation& s,
                                 ::xercesc::DOMErrorHandler& h,
                                 const ::Xsd::XmlSchema::NamespaceInfomap& m,
                                 const ::std::string& e,
                                 ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeSessionParticipation (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeSessionParticipation (::xercesc::XMLFormatTarget& t,
                                 const ::oma_pres::SessionParticipation& s,
                                 const ::Xsd::XmlSchema::NamespaceInfomap& m,
                                 const ::std::string& e,
                                 ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeSessionParticipation (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeSessionParticipation (::xercesc::XMLFormatTarget& t,
                                 const ::oma_pres::SessionParticipation& s,
                                 ::Xsd::XmlSchema::ErrorHandler& h,
                                 const ::Xsd::XmlSchema::NamespaceInfomap& m,
                                 const ::std::string& e,
                                 ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeSessionParticipation (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeSessionParticipation (::xercesc::XMLFormatTarget& t,
                                 const ::oma_pres::SessionParticipation& s,
                                 ::xercesc::DOMErrorHandler& h,
                                 const ::Xsd::XmlSchema::NamespaceInfomap& m,
                                 const ::std::string& e,
                                 ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeSessionParticipation (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeSessionParticipation (::xercesc::DOMDocument& d,
                                 const ::oma_pres::SessionParticipation& s,
                                 ::Xsd::XmlSchema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "session-participation" &&
        n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "session-participation",
        "urn:oma:xml:prs:pidf:oma-pres");
    }
  }

  ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeSessionParticipation (const ::oma_pres::SessionParticipation& s,
                                 const ::Xsd::XmlSchema::NamespaceInfomap& m,
                                 ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "session-participation",
        "urn:oma:xml:prs:pidf:oma-pres",
        m, f));

    ::oma_pres::serializeSessionParticipation (*d, s, f);
    return d;
  }

  void
  serializeRegistrationState (::std::ostream& o,
                              const ::oma_pres::RegistrationState& s,
                              const ::Xsd::XmlSchema::NamespaceInfomap& m,
                              const ::std::string& e,
                              ::Xsd::XmlSchema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeRegistrationState (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeRegistrationState (::std::ostream& o,
                              const ::oma_pres::RegistrationState& s,
                              ::Xsd::XmlSchema::ErrorHandler& h,
                              const ::Xsd::XmlSchema::NamespaceInfomap& m,
                              const ::std::string& e,
                              ::Xsd::XmlSchema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeRegistrationState (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeRegistrationState (::std::ostream& o,
                              const ::oma_pres::RegistrationState& s,
                              ::xercesc::DOMErrorHandler& h,
                              const ::Xsd::XmlSchema::NamespaceInfomap& m,
                              const ::std::string& e,
                              ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeRegistrationState (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeRegistrationState (::xercesc::XMLFormatTarget& t,
                              const ::oma_pres::RegistrationState& s,
                              const ::Xsd::XmlSchema::NamespaceInfomap& m,
                              const ::std::string& e,
                              ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeRegistrationState (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeRegistrationState (::xercesc::XMLFormatTarget& t,
                              const ::oma_pres::RegistrationState& s,
                              ::Xsd::XmlSchema::ErrorHandler& h,
                              const ::Xsd::XmlSchema::NamespaceInfomap& m,
                              const ::std::string& e,
                              ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeRegistrationState (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeRegistrationState (::xercesc::XMLFormatTarget& t,
                              const ::oma_pres::RegistrationState& s,
                              ::xercesc::DOMErrorHandler& h,
                              const ::Xsd::XmlSchema::NamespaceInfomap& m,
                              const ::std::string& e,
                              ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeRegistrationState (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeRegistrationState (::xercesc::DOMDocument& d,
                              const ::oma_pres::RegistrationState& s,
                              ::Xsd::XmlSchema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "registration-state" &&
        n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "registration-state",
        "urn:oma:xml:prs:pidf:oma-pres");
    }
  }

  ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeRegistrationState (const ::oma_pres::RegistrationState& s,
                              const ::Xsd::XmlSchema::NamespaceInfomap& m,
                              ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "registration-state",
        "urn:oma:xml:prs:pidf:oma-pres",
        m, f));

    ::oma_pres::serializeRegistrationState (*d, s, f);
    return d;
  }

  void
  serializeBarringState (::std::ostream& o,
                         const ::oma_pres::BarringState& s,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::Xsd::XmlSchema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeBarringState (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeBarringState (::std::ostream& o,
                         const ::oma_pres::BarringState& s,
                         ::Xsd::XmlSchema::ErrorHandler& h,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::Xsd::XmlSchema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeBarringState (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeBarringState (::std::ostream& o,
                         const ::oma_pres::BarringState& s,
                         ::xercesc::DOMErrorHandler& h,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeBarringState (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeBarringState (::xercesc::XMLFormatTarget& t,
                         const ::oma_pres::BarringState& s,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeBarringState (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeBarringState (::xercesc::XMLFormatTarget& t,
                         const ::oma_pres::BarringState& s,
                         ::Xsd::XmlSchema::ErrorHandler& h,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeBarringState (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeBarringState (::xercesc::XMLFormatTarget& t,
                         const ::oma_pres::BarringState& s,
                         ::xercesc::DOMErrorHandler& h,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeBarringState (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeBarringState (::xercesc::DOMDocument& d,
                         const ::oma_pres::BarringState& s,
                         ::Xsd::XmlSchema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "barring-state" &&
        n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "barring-state",
        "urn:oma:xml:prs:pidf:oma-pres");
    }
  }

  ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeBarringState (const ::oma_pres::BarringState& s,
                         const ::Xsd::XmlSchema::NamespaceInfomap& m,
                         ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "barring-state",
        "urn:oma:xml:prs:pidf:oma-pres",
        m, f));

    ::oma_pres::serializeBarringState (*d, s, f);
    return d;
  }

  void
  serializeOverridingWillingness (::std::ostream& o,
                                  const ::oma_pres::OverridingWillingness& s,
                                  const ::Xsd::XmlSchema::NamespaceInfomap& m,
                                  const ::std::string& e,
                                  ::Xsd::XmlSchema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeOverridingWillingness (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeOverridingWillingness (::std::ostream& o,
                                  const ::oma_pres::OverridingWillingness& s,
                                  ::Xsd::XmlSchema::ErrorHandler& h,
                                  const ::Xsd::XmlSchema::NamespaceInfomap& m,
                                  const ::std::string& e,
                                  ::Xsd::XmlSchema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeOverridingWillingness (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeOverridingWillingness (::std::ostream& o,
                                  const ::oma_pres::OverridingWillingness& s,
                                  ::xercesc::DOMErrorHandler& h,
                                  const ::Xsd::XmlSchema::NamespaceInfomap& m,
                                  const ::std::string& e,
                                  ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeOverridingWillingness (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeOverridingWillingness (::xercesc::XMLFormatTarget& t,
                                  const ::oma_pres::OverridingWillingness& s,
                                  const ::Xsd::XmlSchema::NamespaceInfomap& m,
                                  const ::std::string& e,
                                  ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeOverridingWillingness (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeOverridingWillingness (::xercesc::XMLFormatTarget& t,
                                  const ::oma_pres::OverridingWillingness& s,
                                  ::Xsd::XmlSchema::ErrorHandler& h,
                                  const ::Xsd::XmlSchema::NamespaceInfomap& m,
                                  const ::std::string& e,
                                  ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeOverridingWillingness (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeOverridingWillingness (::xercesc::XMLFormatTarget& t,
                                  const ::oma_pres::OverridingWillingness& s,
                                  ::xercesc::DOMErrorHandler& h,
                                  const ::Xsd::XmlSchema::NamespaceInfomap& m,
                                  const ::std::string& e,
                                  ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeOverridingWillingness (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeOverridingWillingness (::xercesc::DOMDocument& d,
                                  const ::oma_pres::OverridingWillingness& s,
                                  ::Xsd::XmlSchema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "overriding-willingness" &&
        n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "overriding-willingness",
        "urn:oma:xml:prs:pidf:oma-pres");
    }
  }

  ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeOverridingWillingness (const ::oma_pres::OverridingWillingness& s,
                                  const ::Xsd::XmlSchema::NamespaceInfomap& m,
                                  ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "overriding-willingness",
        "urn:oma:xml:prs:pidf:oma-pres",
        m, f));

    ::oma_pres::serializeOverridingWillingness (*d, s, f);
    return d;
  }

  void
  serializeNetworkAvailability (::std::ostream& o,
                                const ::oma_pres::NetworkAvailability& s,
                                const ::Xsd::XmlSchema::NamespaceInfomap& m,
                                const ::std::string& e,
                                ::Xsd::XmlSchema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeNetworkAvailability (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeNetworkAvailability (::std::ostream& o,
                                const ::oma_pres::NetworkAvailability& s,
                                ::Xsd::XmlSchema::ErrorHandler& h,
                                const ::Xsd::XmlSchema::NamespaceInfomap& m,
                                const ::std::string& e,
                                ::Xsd::XmlSchema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::Xsd::XmlSchema::Flags::dont_initialize) == 0);

    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeNetworkAvailability (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeNetworkAvailability (::std::ostream& o,
                                const ::oma_pres::NetworkAvailability& s,
                                ::xercesc::DOMErrorHandler& h,
                                const ::Xsd::XmlSchema::NamespaceInfomap& m,
                                const ::std::string& e,
                                ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeNetworkAvailability (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeNetworkAvailability (::xercesc::XMLFormatTarget& t,
                                const ::oma_pres::NetworkAvailability& s,
                                const ::Xsd::XmlSchema::NamespaceInfomap& m,
                                const ::std::string& e,
                                ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeNetworkAvailability (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeNetworkAvailability (::xercesc::XMLFormatTarget& t,
                                const ::oma_pres::NetworkAvailability& s,
                                ::Xsd::XmlSchema::ErrorHandler& h,
                                const ::Xsd::XmlSchema::NamespaceInfomap& m,
                                const ::std::string& e,
                                ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeNetworkAvailability (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeNetworkAvailability (::xercesc::XMLFormatTarget& t,
                                const ::oma_pres::NetworkAvailability& s,
                                ::xercesc::DOMErrorHandler& h,
                                const ::Xsd::XmlSchema::NamespaceInfomap& m,
                                const ::std::string& e,
                                ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::oma_pres::serializeNetworkAvailability (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeNetworkAvailability (::xercesc::DOMDocument& d,
                                const ::oma_pres::NetworkAvailability& s,
                                ::Xsd::XmlSchema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "network-availability" &&
        n.namespace_ () == "urn:oma:xml:prs:pidf:oma-pres")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "network-availability",
        "urn:oma:xml:prs:pidf:oma-pres");
    }
  }

  ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeNetworkAvailability (const ::oma_pres::NetworkAvailability& s,
                                const ::Xsd::XmlSchema::NamespaceInfomap& m,
                                ::Xsd::XmlSchema::Flags f)
  {
    ::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "network-availability",
        "urn:oma:xml:prs:pidf:oma-pres",
        m, f));

    ::oma_pres::serializeNetworkAvailability (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const ServiceDescription& i)
  {
    e << static_cast< const ::Xsd::XmlSchema::Type& > (i);

    // any_attribute
    //
    for (ServiceDescription::AnyAttributeConstIterator
         b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMAttr* a (
        static_cast< ::xercesc::DOMAttr* > (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

      if (a->getLocalName () == 0)
        e.setAttributeNode (a);
      else
        e.setAttributeNodeNS (a);
    }

    // service-id
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "service-id",
          "urn:oma:xml:prs:pidf:oma-pres",
          e));

      s << i.getServiceId ();
    }

    // version
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "version",
          "urn:oma:xml:prs:pidf:oma-pres",
          e));

      s << i.getVersion ();
    }

    // description
    //
    if (i.getDescription ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "description",
          "urn:oma:xml:prs:pidf:oma-pres",
          e));

      s << *i.getDescription ();
    }

    // any
    //
    for (ServiceDescription::AnyConstIterator
         b (i.getAny ().begin ()), n (i.getAny ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Willingness& i)
  {
    e << static_cast< const ::Xsd::XmlSchema::Type& > (i);

    // any_attribute
    //
    for (Willingness::AnyAttributeConstIterator
         b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMAttr* a (
        static_cast< ::xercesc::DOMAttr* > (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

      if (a->getLocalName () == 0)
        e.setAttributeNode (a);
      else
        e.setAttributeNodeNS (a);
    }

    // basic
    //
    if (i.getBasic ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "basic",
          "urn:oma:xml:prs:pidf:oma-pres",
          e));

      s << *i.getBasic ();
    }

    // any
    //
    for (Willingness::AnyConstIterator
         b (i.getAny ().begin ()), n (i.getAny ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SessionParticipation& i)
  {
    e << static_cast< const ::Xsd::XmlSchema::Type& > (i);

    // any_attribute
    //
    for (SessionParticipation::AnyAttributeConstIterator
         b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMAttr* a (
        static_cast< ::xercesc::DOMAttr* > (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

      if (a->getLocalName () == 0)
        e.setAttributeNode (a);
      else
        e.setAttributeNodeNS (a);
    }

    // basic
    //
    if (i.getBasic ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "basic",
          "urn:oma:xml:prs:pidf:oma-pres",
          e));

      s << *i.getBasic ();
    }

    // any
    //
    for (SessionParticipation::AnyConstIterator
         b (i.getAny ().begin ()), n (i.getAny ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RegistrationState& i)
  {
    e << static_cast< const ::oma_pres::RegistrationType& > (i);

    // any_attribute
    //
    for (RegistrationState::AnyAttributeConstIterator
         b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMAttr* a (
        static_cast< ::xercesc::DOMAttr* > (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

      if (a->getLocalName () == 0)
        e.setAttributeNode (a);
      else
        e.setAttributeNodeNS (a);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BarringState& i)
  {
    e << static_cast< const ::oma_pres::BarringType& > (i);

    // any_attribute
    //
    for (BarringState::AnyAttributeConstIterator
         b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMAttr* a (
        static_cast< ::xercesc::DOMAttr* > (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

      if (a->getLocalName () == 0)
        e.setAttributeNode (a);
      else
        e.setAttributeNodeNS (a);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const OverridingWillingness& i)
  {
    e << static_cast< const ::Xsd::XmlSchema::Type& > (i);

    // any_attribute
    //
    for (OverridingWillingness::AnyAttributeConstIterator
         b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMAttr* a (
        static_cast< ::xercesc::DOMAttr* > (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

      if (a->getLocalName () == 0)
        e.setAttributeNode (a);
      else
        e.setAttributeNodeNS (a);
    }

    // basic
    //
    if (i.getBasic ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "basic",
          "urn:oma:xml:prs:pidf:oma-pres",
          e));

      s << *i.getBasic ();
    }

    // any
    //
    for (OverridingWillingness::AnyConstIterator
         b (i.getAny ().begin ()), n (i.getAny ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const NetworkAvailability& i)
  {
    e << static_cast< const ::Xsd::XmlSchema::Type& > (i);

    // any_attribute
    //
    for (NetworkAvailability::AnyAttributeConstIterator
         b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMAttr* a (
        static_cast< ::xercesc::DOMAttr* > (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

      if (a->getLocalName () == 0)
        e.setAttributeNode (a);
      else
        e.setAttributeNodeNS (a);
    }

    // network
    //
    for (NetworkAvailability::NetworkConstIterator
         b (i.getNetwork ().begin ()), n (i.getNetwork ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "network",
          "urn:oma:xml:prs:pidf:oma-pres",
          e));

      s << *b;
    }

    // any
    //
    for (NetworkAvailability::AnyConstIterator
         b (i.getAny ().begin ()), n (i.getAny ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Network& i)
  {
    e << static_cast< const ::Xsd::XmlSchema::Type& > (i);

    // any_attribute
    //
    for (Network::AnyAttributeConstIterator
         b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMAttr* a (
        static_cast< ::xercesc::DOMAttr* > (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

      if (a->getLocalName () == 0)
        e.setAttributeNode (a);
      else
        e.setAttributeNodeNS (a);
    }

    // active
    //
    if (i.getActive ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "active",
          "urn:oma:xml:prs:pidf:oma-pres",
          e));

      s << *i.getActive ();
    }

    // terminated
    //
    if (i.getTerminated ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "terminated",
          "urn:oma:xml:prs:pidf:oma-pres",
          e));

      s << *i.getTerminated ();
    }

    // any
    //
    for (Network::AnyConstIterator
         b (i.getAny ().begin ()), n (i.getAny ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.getId ();
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
#if __clang__ || __GNUC__ >= 4
  #pragma GCC diagnostic pop
#endif
//
// End epilogue.
