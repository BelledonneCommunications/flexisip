// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
#if __clang__ || __GNUC__ >= 4
	#pragma GCC diagnostic push
	#pragma GCC diagnostic ignored "-Wfloat-equal"
	#pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
#ifndef __ANDROID__
	#pragma GCC diagnostic ignored "-Wsuggest-override"
#endif
#endif
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "rpid.hh"

namespace flexisip
{
  namespace Xsd
  {
    namespace Rpid
    {
      // Timestamp_t
      // 


      // DeviceID_t
      // 


      // Note_t
      // 

      const Note_t::LangOptional& Note_t::
      getLang () const
      {
        return this->lang_;
      }

      Note_t::LangOptional& Note_t::
      getLang ()
      {
        return this->lang_;
      }

      void Note_t::
      setLang (const LangType& x)
      {
        this->lang_.set (x);
      }

      void Note_t::
      setLang (const LangOptional& x)
      {
        this->lang_ = x;
      }

      void Note_t::
      setLang (::std::unique_ptr< LangType > x)
      {
        this->lang_.set (std::move (x));
      }


      // Empty
      // 
    }
  }
}

namespace flexisip
{
  namespace Xsd
  {
    namespace Rpid
    {
      // ActiveIdle
      // 

      ActiveIdle::
      ActiveIdle (Value v)
      : ::flexisip::Xsd::XmlSchema::String (_xsd_ActiveIdle_literals_[v])
      {
      }

      ActiveIdle::
      ActiveIdle (const char* v)
      : ::flexisip::Xsd::XmlSchema::String (v)
      {
      }

      ActiveIdle::
      ActiveIdle (const ::std::string& v)
      : ::flexisip::Xsd::XmlSchema::String (v)
      {
      }

      ActiveIdle::
      ActiveIdle (const ::flexisip::Xsd::XmlSchema::String& v)
      : ::flexisip::Xsd::XmlSchema::String (v)
      {
      }

      ActiveIdle::
      ActiveIdle (const ActiveIdle& v,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::String (v, f, c)
      {
      }

      ActiveIdle& ActiveIdle::
      operator= (Value v)
      {
        static_cast< ::flexisip::Xsd::XmlSchema::String& > (*this) = 
        ::flexisip::Xsd::XmlSchema::String (_xsd_ActiveIdle_literals_[v]);

        return *this;
      }


      // Activities
      // 

      const Activities::NoteSequence& Activities::
      getNote () const
      {
        return this->note_;
      }

      Activities::NoteSequence& Activities::
      getNote ()
      {
        return this->note_;
      }

      void Activities::
      setNote (const NoteSequence& s)
      {
        this->note_ = s;
      }

      const Activities::UnknownOptional& Activities::
      getUnknown () const
      {
        return this->unknown_;
      }

      Activities::UnknownOptional& Activities::
      getUnknown ()
      {
        return this->unknown_;
      }

      void Activities::
      setUnknown (const UnknownType& x)
      {
        this->unknown_.set (x);
      }

      void Activities::
      setUnknown (const UnknownOptional& x)
      {
        this->unknown_ = x;
      }

      void Activities::
      setUnknown (::std::unique_ptr< UnknownType > x)
      {
        this->unknown_.set (std::move (x));
      }

      const Activities::AppointmentSequence& Activities::
      getAppointment () const
      {
        return this->appointment_;
      }

      Activities::AppointmentSequence& Activities::
      getAppointment ()
      {
        return this->appointment_;
      }

      void Activities::
      setAppointment (const AppointmentSequence& s)
      {
        this->appointment_ = s;
      }

      const Activities::AwaySequence& Activities::
      getAway () const
      {
        return this->away_;
      }

      Activities::AwaySequence& Activities::
      getAway ()
      {
        return this->away_;
      }

      void Activities::
      setAway (const AwaySequence& s)
      {
        this->away_ = s;
      }

      const Activities::BreakfastSequence& Activities::
      getBreakfast () const
      {
        return this->breakfast_;
      }

      Activities::BreakfastSequence& Activities::
      getBreakfast ()
      {
        return this->breakfast_;
      }

      void Activities::
      setBreakfast (const BreakfastSequence& s)
      {
        this->breakfast_ = s;
      }

      const Activities::BusySequence& Activities::
      getBusy () const
      {
        return this->busy_;
      }

      Activities::BusySequence& Activities::
      getBusy ()
      {
        return this->busy_;
      }

      void Activities::
      setBusy (const BusySequence& s)
      {
        this->busy_ = s;
      }

      const Activities::DinnerSequence& Activities::
      getDinner () const
      {
        return this->dinner_;
      }

      Activities::DinnerSequence& Activities::
      getDinner ()
      {
        return this->dinner_;
      }

      void Activities::
      setDinner (const DinnerSequence& s)
      {
        this->dinner_ = s;
      }

      const Activities::HolidaySequence& Activities::
      getHoliday () const
      {
        return this->holiday_;
      }

      Activities::HolidaySequence& Activities::
      getHoliday ()
      {
        return this->holiday_;
      }

      void Activities::
      setHoliday (const HolidaySequence& s)
      {
        this->holiday_ = s;
      }

      const Activities::InTransitSequence& Activities::
      getInTransit () const
      {
        return this->in_transit_;
      }

      Activities::InTransitSequence& Activities::
      getInTransit ()
      {
        return this->in_transit_;
      }

      void Activities::
      setInTransit (const InTransitSequence& s)
      {
        this->in_transit_ = s;
      }

      const Activities::LookingForWorkSequence& Activities::
      getLookingForWork () const
      {
        return this->looking_for_work_;
      }

      Activities::LookingForWorkSequence& Activities::
      getLookingForWork ()
      {
        return this->looking_for_work_;
      }

      void Activities::
      setLookingForWork (const LookingForWorkSequence& s)
      {
        this->looking_for_work_ = s;
      }

      const Activities::MealSequence& Activities::
      getMeal () const
      {
        return this->meal_;
      }

      Activities::MealSequence& Activities::
      getMeal ()
      {
        return this->meal_;
      }

      void Activities::
      setMeal (const MealSequence& s)
      {
        this->meal_ = s;
      }

      const Activities::MeetingSequence& Activities::
      getMeeting () const
      {
        return this->meeting_;
      }

      Activities::MeetingSequence& Activities::
      getMeeting ()
      {
        return this->meeting_;
      }

      void Activities::
      setMeeting (const MeetingSequence& s)
      {
        this->meeting_ = s;
      }

      const Activities::OnThePhoneSequence& Activities::
      getOnThePhone () const
      {
        return this->on_the_phone_;
      }

      Activities::OnThePhoneSequence& Activities::
      getOnThePhone ()
      {
        return this->on_the_phone_;
      }

      void Activities::
      setOnThePhone (const OnThePhoneSequence& s)
      {
        this->on_the_phone_ = s;
      }

      const Activities::PerformanceSequence& Activities::
      getPerformance () const
      {
        return this->performance_;
      }

      Activities::PerformanceSequence& Activities::
      getPerformance ()
      {
        return this->performance_;
      }

      void Activities::
      setPerformance (const PerformanceSequence& s)
      {
        this->performance_ = s;
      }

      const Activities::PermanentAbsenceSequence& Activities::
      getPermanentAbsence () const
      {
        return this->permanent_absence_;
      }

      Activities::PermanentAbsenceSequence& Activities::
      getPermanentAbsence ()
      {
        return this->permanent_absence_;
      }

      void Activities::
      setPermanentAbsence (const PermanentAbsenceSequence& s)
      {
        this->permanent_absence_ = s;
      }

      const Activities::PlayingSequence& Activities::
      getPlaying () const
      {
        return this->playing_;
      }

      Activities::PlayingSequence& Activities::
      getPlaying ()
      {
        return this->playing_;
      }

      void Activities::
      setPlaying (const PlayingSequence& s)
      {
        this->playing_ = s;
      }

      const Activities::PresentationSequence& Activities::
      getPresentation () const
      {
        return this->presentation_;
      }

      Activities::PresentationSequence& Activities::
      getPresentation ()
      {
        return this->presentation_;
      }

      void Activities::
      setPresentation (const PresentationSequence& s)
      {
        this->presentation_ = s;
      }

      const Activities::ShoppingSequence& Activities::
      getShopping () const
      {
        return this->shopping_;
      }

      Activities::ShoppingSequence& Activities::
      getShopping ()
      {
        return this->shopping_;
      }

      void Activities::
      setShopping (const ShoppingSequence& s)
      {
        this->shopping_ = s;
      }

      const Activities::SleepingSequence& Activities::
      getSleeping () const
      {
        return this->sleeping_;
      }

      Activities::SleepingSequence& Activities::
      getSleeping ()
      {
        return this->sleeping_;
      }

      void Activities::
      setSleeping (const SleepingSequence& s)
      {
        this->sleeping_ = s;
      }

      const Activities::SpectatorSequence& Activities::
      getSpectator () const
      {
        return this->spectator_;
      }

      Activities::SpectatorSequence& Activities::
      getSpectator ()
      {
        return this->spectator_;
      }

      void Activities::
      setSpectator (const SpectatorSequence& s)
      {
        this->spectator_ = s;
      }

      const Activities::SteeringSequence& Activities::
      getSteering () const
      {
        return this->steering_;
      }

      Activities::SteeringSequence& Activities::
      getSteering ()
      {
        return this->steering_;
      }

      void Activities::
      setSteering (const SteeringSequence& s)
      {
        this->steering_ = s;
      }

      const Activities::TravelSequence& Activities::
      getTravel () const
      {
        return this->travel_;
      }

      Activities::TravelSequence& Activities::
      getTravel ()
      {
        return this->travel_;
      }

      void Activities::
      setTravel (const TravelSequence& s)
      {
        this->travel_ = s;
      }

      const Activities::TvSequence& Activities::
      getTv () const
      {
        return this->tv_;
      }

      Activities::TvSequence& Activities::
      getTv ()
      {
        return this->tv_;
      }

      void Activities::
      setTv (const TvSequence& s)
      {
        this->tv_ = s;
      }

      const Activities::VacationSequence& Activities::
      getVacation () const
      {
        return this->vacation_;
      }

      Activities::VacationSequence& Activities::
      getVacation ()
      {
        return this->vacation_;
      }

      void Activities::
      setVacation (const VacationSequence& s)
      {
        this->vacation_ = s;
      }

      const Activities::WorkingSequence& Activities::
      getWorking () const
      {
        return this->working_;
      }

      Activities::WorkingSequence& Activities::
      getWorking ()
      {
        return this->working_;
      }

      void Activities::
      setWorking (const WorkingSequence& s)
      {
        this->working_ = s;
      }

      const Activities::WorshipSequence& Activities::
      getWorship () const
      {
        return this->worship_;
      }

      Activities::WorshipSequence& Activities::
      getWorship ()
      {
        return this->worship_;
      }

      void Activities::
      setWorship (const WorshipSequence& s)
      {
        this->worship_ = s;
      }

      const Activities::OtherSequence& Activities::
      getOther () const
      {
        return this->other_;
      }

      Activities::OtherSequence& Activities::
      getOther ()
      {
        return this->other_;
      }

      void Activities::
      setOther (const OtherSequence& s)
      {
        this->other_ = s;
      }

      const Activities::AnySequence& Activities::
      getAny () const
      {
        return this->any_;
      }

      Activities::AnySequence& Activities::
      getAny ()
      {
        return this->any_;
      }

      void Activities::
      setAny (const AnySequence& s)
      {
        this->any_ = s;
      }

      const Activities::FromOptional& Activities::
      getFrom () const
      {
        return this->from_;
      }

      Activities::FromOptional& Activities::
      getFrom ()
      {
        return this->from_;
      }

      void Activities::
      setFrom (const FromType& x)
      {
        this->from_.set (x);
      }

      void Activities::
      setFrom (const FromOptional& x)
      {
        this->from_ = x;
      }

      void Activities::
      setFrom (::std::unique_ptr< FromType > x)
      {
        this->from_.set (std::move (x));
      }

      const Activities::UntilOptional& Activities::
      getUntil () const
      {
        return this->until_;
      }

      Activities::UntilOptional& Activities::
      getUntil ()
      {
        return this->until_;
      }

      void Activities::
      setUntil (const UntilType& x)
      {
        this->until_.set (x);
      }

      void Activities::
      setUntil (const UntilOptional& x)
      {
        this->until_ = x;
      }

      void Activities::
      setUntil (::std::unique_ptr< UntilType > x)
      {
        this->until_.set (std::move (x));
      }

      const Activities::IdOptional& Activities::
      getId () const
      {
        return this->id_;
      }

      Activities::IdOptional& Activities::
      getId ()
      {
        return this->id_;
      }

      void Activities::
      setId (const IdType& x)
      {
        this->id_.set (x);
      }

      void Activities::
      setId (const IdOptional& x)
      {
        this->id_ = x;
      }

      void Activities::
      setId (::std::unique_ptr< IdType > x)
      {
        this->id_.set (std::move (x));
      }

      const Activities::AnyAttributeSet& Activities::
      getAnyAttribute () const
      {
        return this->any_attribute_;
      }

      Activities::AnyAttributeSet& Activities::
      getAnyAttribute ()
      {
        return this->any_attribute_;
      }

      void Activities::
      setAnyAttribute (const AnyAttributeSet& s)
      {
        this->any_attribute_ = s;
      }

      const ::xercesc::DOMDocument& Activities::
      getDomDocument () const
      {
        return *this->dom_document_;
      }

      ::xercesc::DOMDocument& Activities::
      getDomDocument ()
      {
        return *this->dom_document_;
      }


      // Mood
      // 

      const Mood::NoteSequence& Mood::
      getNote () const
      {
        return this->note_;
      }

      Mood::NoteSequence& Mood::
      getNote ()
      {
        return this->note_;
      }

      void Mood::
      setNote (const NoteSequence& s)
      {
        this->note_ = s;
      }

      const Mood::UnknownOptional& Mood::
      getUnknown () const
      {
        return this->unknown_;
      }

      Mood::UnknownOptional& Mood::
      getUnknown ()
      {
        return this->unknown_;
      }

      void Mood::
      setUnknown (const UnknownType& x)
      {
        this->unknown_.set (x);
      }

      void Mood::
      setUnknown (const UnknownOptional& x)
      {
        this->unknown_ = x;
      }

      void Mood::
      setUnknown (::std::unique_ptr< UnknownType > x)
      {
        this->unknown_.set (std::move (x));
      }

      const Mood::AfraidSequence& Mood::
      getAfraid () const
      {
        return this->afraid_;
      }

      Mood::AfraidSequence& Mood::
      getAfraid ()
      {
        return this->afraid_;
      }

      void Mood::
      setAfraid (const AfraidSequence& s)
      {
        this->afraid_ = s;
      }

      const Mood::AmazedSequence& Mood::
      getAmazed () const
      {
        return this->amazed_;
      }

      Mood::AmazedSequence& Mood::
      getAmazed ()
      {
        return this->amazed_;
      }

      void Mood::
      setAmazed (const AmazedSequence& s)
      {
        this->amazed_ = s;
      }

      const Mood::AngrySequence& Mood::
      getAngry () const
      {
        return this->angry_;
      }

      Mood::AngrySequence& Mood::
      getAngry ()
      {
        return this->angry_;
      }

      void Mood::
      setAngry (const AngrySequence& s)
      {
        this->angry_ = s;
      }

      const Mood::AnnoyedSequence& Mood::
      getAnnoyed () const
      {
        return this->annoyed_;
      }

      Mood::AnnoyedSequence& Mood::
      getAnnoyed ()
      {
        return this->annoyed_;
      }

      void Mood::
      setAnnoyed (const AnnoyedSequence& s)
      {
        this->annoyed_ = s;
      }

      const Mood::AnxiousSequence& Mood::
      getAnxious () const
      {
        return this->anxious_;
      }

      Mood::AnxiousSequence& Mood::
      getAnxious ()
      {
        return this->anxious_;
      }

      void Mood::
      setAnxious (const AnxiousSequence& s)
      {
        this->anxious_ = s;
      }

      const Mood::AshamedSequence& Mood::
      getAshamed () const
      {
        return this->ashamed_;
      }

      Mood::AshamedSequence& Mood::
      getAshamed ()
      {
        return this->ashamed_;
      }

      void Mood::
      setAshamed (const AshamedSequence& s)
      {
        this->ashamed_ = s;
      }

      const Mood::BoredSequence& Mood::
      getBored () const
      {
        return this->bored_;
      }

      Mood::BoredSequence& Mood::
      getBored ()
      {
        return this->bored_;
      }

      void Mood::
      setBored (const BoredSequence& s)
      {
        this->bored_ = s;
      }

      const Mood::BraveSequence& Mood::
      getBrave () const
      {
        return this->brave_;
      }

      Mood::BraveSequence& Mood::
      getBrave ()
      {
        return this->brave_;
      }

      void Mood::
      setBrave (const BraveSequence& s)
      {
        this->brave_ = s;
      }

      const Mood::CalmSequence& Mood::
      getCalm () const
      {
        return this->calm_;
      }

      Mood::CalmSequence& Mood::
      getCalm ()
      {
        return this->calm_;
      }

      void Mood::
      setCalm (const CalmSequence& s)
      {
        this->calm_ = s;
      }

      const Mood::ColdSequence& Mood::
      getCold () const
      {
        return this->cold_;
      }

      Mood::ColdSequence& Mood::
      getCold ()
      {
        return this->cold_;
      }

      void Mood::
      setCold (const ColdSequence& s)
      {
        this->cold_ = s;
      }

      const Mood::ConfusedSequence& Mood::
      getConfused () const
      {
        return this->confused_;
      }

      Mood::ConfusedSequence& Mood::
      getConfused ()
      {
        return this->confused_;
      }

      void Mood::
      setConfused (const ConfusedSequence& s)
      {
        this->confused_ = s;
      }

      const Mood::ContentedSequence& Mood::
      getContented () const
      {
        return this->contented_;
      }

      Mood::ContentedSequence& Mood::
      getContented ()
      {
        return this->contented_;
      }

      void Mood::
      setContented (const ContentedSequence& s)
      {
        this->contented_ = s;
      }

      const Mood::CrankySequence& Mood::
      getCranky () const
      {
        return this->cranky_;
      }

      Mood::CrankySequence& Mood::
      getCranky ()
      {
        return this->cranky_;
      }

      void Mood::
      setCranky (const CrankySequence& s)
      {
        this->cranky_ = s;
      }

      const Mood::CuriousSequence& Mood::
      getCurious () const
      {
        return this->curious_;
      }

      Mood::CuriousSequence& Mood::
      getCurious ()
      {
        return this->curious_;
      }

      void Mood::
      setCurious (const CuriousSequence& s)
      {
        this->curious_ = s;
      }

      const Mood::DepressedSequence& Mood::
      getDepressed () const
      {
        return this->depressed_;
      }

      Mood::DepressedSequence& Mood::
      getDepressed ()
      {
        return this->depressed_;
      }

      void Mood::
      setDepressed (const DepressedSequence& s)
      {
        this->depressed_ = s;
      }

      const Mood::DisappointedSequence& Mood::
      getDisappointed () const
      {
        return this->disappointed_;
      }

      Mood::DisappointedSequence& Mood::
      getDisappointed ()
      {
        return this->disappointed_;
      }

      void Mood::
      setDisappointed (const DisappointedSequence& s)
      {
        this->disappointed_ = s;
      }

      const Mood::DisgustedSequence& Mood::
      getDisgusted () const
      {
        return this->disgusted_;
      }

      Mood::DisgustedSequence& Mood::
      getDisgusted ()
      {
        return this->disgusted_;
      }

      void Mood::
      setDisgusted (const DisgustedSequence& s)
      {
        this->disgusted_ = s;
      }

      const Mood::DistractedSequence& Mood::
      getDistracted () const
      {
        return this->distracted_;
      }

      Mood::DistractedSequence& Mood::
      getDistracted ()
      {
        return this->distracted_;
      }

      void Mood::
      setDistracted (const DistractedSequence& s)
      {
        this->distracted_ = s;
      }

      const Mood::EmbarrassedSequence& Mood::
      getEmbarrassed () const
      {
        return this->embarrassed_;
      }

      Mood::EmbarrassedSequence& Mood::
      getEmbarrassed ()
      {
        return this->embarrassed_;
      }

      void Mood::
      setEmbarrassed (const EmbarrassedSequence& s)
      {
        this->embarrassed_ = s;
      }

      const Mood::ExcitedSequence& Mood::
      getExcited () const
      {
        return this->excited_;
      }

      Mood::ExcitedSequence& Mood::
      getExcited ()
      {
        return this->excited_;
      }

      void Mood::
      setExcited (const ExcitedSequence& s)
      {
        this->excited_ = s;
      }

      const Mood::FlirtatiousSequence& Mood::
      getFlirtatious () const
      {
        return this->flirtatious_;
      }

      Mood::FlirtatiousSequence& Mood::
      getFlirtatious ()
      {
        return this->flirtatious_;
      }

      void Mood::
      setFlirtatious (const FlirtatiousSequence& s)
      {
        this->flirtatious_ = s;
      }

      const Mood::FrustratedSequence& Mood::
      getFrustrated () const
      {
        return this->frustrated_;
      }

      Mood::FrustratedSequence& Mood::
      getFrustrated ()
      {
        return this->frustrated_;
      }

      void Mood::
      setFrustrated (const FrustratedSequence& s)
      {
        this->frustrated_ = s;
      }

      const Mood::GrumpySequence& Mood::
      getGrumpy () const
      {
        return this->grumpy_;
      }

      Mood::GrumpySequence& Mood::
      getGrumpy ()
      {
        return this->grumpy_;
      }

      void Mood::
      setGrumpy (const GrumpySequence& s)
      {
        this->grumpy_ = s;
      }

      const Mood::GuiltySequence& Mood::
      getGuilty () const
      {
        return this->guilty_;
      }

      Mood::GuiltySequence& Mood::
      getGuilty ()
      {
        return this->guilty_;
      }

      void Mood::
      setGuilty (const GuiltySequence& s)
      {
        this->guilty_ = s;
      }

      const Mood::HappySequence& Mood::
      getHappy () const
      {
        return this->happy_;
      }

      Mood::HappySequence& Mood::
      getHappy ()
      {
        return this->happy_;
      }

      void Mood::
      setHappy (const HappySequence& s)
      {
        this->happy_ = s;
      }

      const Mood::HotSequence& Mood::
      getHot () const
      {
        return this->hot_;
      }

      Mood::HotSequence& Mood::
      getHot ()
      {
        return this->hot_;
      }

      void Mood::
      setHot (const HotSequence& s)
      {
        this->hot_ = s;
      }

      const Mood::HumbledSequence& Mood::
      getHumbled () const
      {
        return this->humbled_;
      }

      Mood::HumbledSequence& Mood::
      getHumbled ()
      {
        return this->humbled_;
      }

      void Mood::
      setHumbled (const HumbledSequence& s)
      {
        this->humbled_ = s;
      }

      const Mood::HumiliatedSequence& Mood::
      getHumiliated () const
      {
        return this->humiliated_;
      }

      Mood::HumiliatedSequence& Mood::
      getHumiliated ()
      {
        return this->humiliated_;
      }

      void Mood::
      setHumiliated (const HumiliatedSequence& s)
      {
        this->humiliated_ = s;
      }

      const Mood::HungrySequence& Mood::
      getHungry () const
      {
        return this->hungry_;
      }

      Mood::HungrySequence& Mood::
      getHungry ()
      {
        return this->hungry_;
      }

      void Mood::
      setHungry (const HungrySequence& s)
      {
        this->hungry_ = s;
      }

      const Mood::HurtSequence& Mood::
      getHurt () const
      {
        return this->hurt_;
      }

      Mood::HurtSequence& Mood::
      getHurt ()
      {
        return this->hurt_;
      }

      void Mood::
      setHurt (const HurtSequence& s)
      {
        this->hurt_ = s;
      }

      const Mood::ImpressedSequence& Mood::
      getImpressed () const
      {
        return this->impressed_;
      }

      Mood::ImpressedSequence& Mood::
      getImpressed ()
      {
        return this->impressed_;
      }

      void Mood::
      setImpressed (const ImpressedSequence& s)
      {
        this->impressed_ = s;
      }

      const Mood::In_aweSequence& Mood::
      getIn_awe () const
      {
        return this->in_awe_;
      }

      Mood::In_aweSequence& Mood::
      getIn_awe ()
      {
        return this->in_awe_;
      }

      void Mood::
      setIn_awe (const In_aweSequence& s)
      {
        this->in_awe_ = s;
      }

      const Mood::In_loveSequence& Mood::
      getIn_love () const
      {
        return this->in_love_;
      }

      Mood::In_loveSequence& Mood::
      getIn_love ()
      {
        return this->in_love_;
      }

      void Mood::
      setIn_love (const In_loveSequence& s)
      {
        this->in_love_ = s;
      }

      const Mood::IndignantSequence& Mood::
      getIndignant () const
      {
        return this->indignant_;
      }

      Mood::IndignantSequence& Mood::
      getIndignant ()
      {
        return this->indignant_;
      }

      void Mood::
      setIndignant (const IndignantSequence& s)
      {
        this->indignant_ = s;
      }

      const Mood::InterestedSequence& Mood::
      getInterested () const
      {
        return this->interested_;
      }

      Mood::InterestedSequence& Mood::
      getInterested ()
      {
        return this->interested_;
      }

      void Mood::
      setInterested (const InterestedSequence& s)
      {
        this->interested_ = s;
      }

      const Mood::InvincibleSequence& Mood::
      getInvincible () const
      {
        return this->invincible_;
      }

      Mood::InvincibleSequence& Mood::
      getInvincible ()
      {
        return this->invincible_;
      }

      void Mood::
      setInvincible (const InvincibleSequence& s)
      {
        this->invincible_ = s;
      }

      const Mood::JealousSequence& Mood::
      getJealous () const
      {
        return this->jealous_;
      }

      Mood::JealousSequence& Mood::
      getJealous ()
      {
        return this->jealous_;
      }

      void Mood::
      setJealous (const JealousSequence& s)
      {
        this->jealous_ = s;
      }

      const Mood::LonelySequence& Mood::
      getLonely () const
      {
        return this->lonely_;
      }

      Mood::LonelySequence& Mood::
      getLonely ()
      {
        return this->lonely_;
      }

      void Mood::
      setLonely (const LonelySequence& s)
      {
        this->lonely_ = s;
      }

      const Mood::MeanSequence& Mood::
      getMean () const
      {
        return this->mean_;
      }

      Mood::MeanSequence& Mood::
      getMean ()
      {
        return this->mean_;
      }

      void Mood::
      setMean (const MeanSequence& s)
      {
        this->mean_ = s;
      }

      const Mood::MoodySequence& Mood::
      getMoody () const
      {
        return this->moody_;
      }

      Mood::MoodySequence& Mood::
      getMoody ()
      {
        return this->moody_;
      }

      void Mood::
      setMoody (const MoodySequence& s)
      {
        this->moody_ = s;
      }

      const Mood::NervousSequence& Mood::
      getNervous () const
      {
        return this->nervous_;
      }

      Mood::NervousSequence& Mood::
      getNervous ()
      {
        return this->nervous_;
      }

      void Mood::
      setNervous (const NervousSequence& s)
      {
        this->nervous_ = s;
      }

      const Mood::NeutralSequence& Mood::
      getNeutral () const
      {
        return this->neutral_;
      }

      Mood::NeutralSequence& Mood::
      getNeutral ()
      {
        return this->neutral_;
      }

      void Mood::
      setNeutral (const NeutralSequence& s)
      {
        this->neutral_ = s;
      }

      const Mood::OffendedSequence& Mood::
      getOffended () const
      {
        return this->offended_;
      }

      Mood::OffendedSequence& Mood::
      getOffended ()
      {
        return this->offended_;
      }

      void Mood::
      setOffended (const OffendedSequence& s)
      {
        this->offended_ = s;
      }

      const Mood::PlayfulSequence& Mood::
      getPlayful () const
      {
        return this->playful_;
      }

      Mood::PlayfulSequence& Mood::
      getPlayful ()
      {
        return this->playful_;
      }

      void Mood::
      setPlayful (const PlayfulSequence& s)
      {
        this->playful_ = s;
      }

      const Mood::ProudSequence& Mood::
      getProud () const
      {
        return this->proud_;
      }

      Mood::ProudSequence& Mood::
      getProud ()
      {
        return this->proud_;
      }

      void Mood::
      setProud (const ProudSequence& s)
      {
        this->proud_ = s;
      }

      const Mood::RelievedSequence& Mood::
      getRelieved () const
      {
        return this->relieved_;
      }

      Mood::RelievedSequence& Mood::
      getRelieved ()
      {
        return this->relieved_;
      }

      void Mood::
      setRelieved (const RelievedSequence& s)
      {
        this->relieved_ = s;
      }

      const Mood::RemorsefulSequence& Mood::
      getRemorseful () const
      {
        return this->remorseful_;
      }

      Mood::RemorsefulSequence& Mood::
      getRemorseful ()
      {
        return this->remorseful_;
      }

      void Mood::
      setRemorseful (const RemorsefulSequence& s)
      {
        this->remorseful_ = s;
      }

      const Mood::RestlessSequence& Mood::
      getRestless () const
      {
        return this->restless_;
      }

      Mood::RestlessSequence& Mood::
      getRestless ()
      {
        return this->restless_;
      }

      void Mood::
      setRestless (const RestlessSequence& s)
      {
        this->restless_ = s;
      }

      const Mood::SadSequence& Mood::
      getSad () const
      {
        return this->sad_;
      }

      Mood::SadSequence& Mood::
      getSad ()
      {
        return this->sad_;
      }

      void Mood::
      setSad (const SadSequence& s)
      {
        this->sad_ = s;
      }

      const Mood::SarcasticSequence& Mood::
      getSarcastic () const
      {
        return this->sarcastic_;
      }

      Mood::SarcasticSequence& Mood::
      getSarcastic ()
      {
        return this->sarcastic_;
      }

      void Mood::
      setSarcastic (const SarcasticSequence& s)
      {
        this->sarcastic_ = s;
      }

      const Mood::SeriousSequence& Mood::
      getSerious () const
      {
        return this->serious_;
      }

      Mood::SeriousSequence& Mood::
      getSerious ()
      {
        return this->serious_;
      }

      void Mood::
      setSerious (const SeriousSequence& s)
      {
        this->serious_ = s;
      }

      const Mood::ShockedSequence& Mood::
      getShocked () const
      {
        return this->shocked_;
      }

      Mood::ShockedSequence& Mood::
      getShocked ()
      {
        return this->shocked_;
      }

      void Mood::
      setShocked (const ShockedSequence& s)
      {
        this->shocked_ = s;
      }

      const Mood::ShySequence& Mood::
      getShy () const
      {
        return this->shy_;
      }

      Mood::ShySequence& Mood::
      getShy ()
      {
        return this->shy_;
      }

      void Mood::
      setShy (const ShySequence& s)
      {
        this->shy_ = s;
      }

      const Mood::SickSequence& Mood::
      getSick () const
      {
        return this->sick_;
      }

      Mood::SickSequence& Mood::
      getSick ()
      {
        return this->sick_;
      }

      void Mood::
      setSick (const SickSequence& s)
      {
        this->sick_ = s;
      }

      const Mood::SleepySequence& Mood::
      getSleepy () const
      {
        return this->sleepy_;
      }

      Mood::SleepySequence& Mood::
      getSleepy ()
      {
        return this->sleepy_;
      }

      void Mood::
      setSleepy (const SleepySequence& s)
      {
        this->sleepy_ = s;
      }

      const Mood::StressedSequence& Mood::
      getStressed () const
      {
        return this->stressed_;
      }

      Mood::StressedSequence& Mood::
      getStressed ()
      {
        return this->stressed_;
      }

      void Mood::
      setStressed (const StressedSequence& s)
      {
        this->stressed_ = s;
      }

      const Mood::SurprisedSequence& Mood::
      getSurprised () const
      {
        return this->surprised_;
      }

      Mood::SurprisedSequence& Mood::
      getSurprised ()
      {
        return this->surprised_;
      }

      void Mood::
      setSurprised (const SurprisedSequence& s)
      {
        this->surprised_ = s;
      }

      const Mood::ThirstySequence& Mood::
      getThirsty () const
      {
        return this->thirsty_;
      }

      Mood::ThirstySequence& Mood::
      getThirsty ()
      {
        return this->thirsty_;
      }

      void Mood::
      setThirsty (const ThirstySequence& s)
      {
        this->thirsty_ = s;
      }

      const Mood::WorriedSequence& Mood::
      getWorried () const
      {
        return this->worried_;
      }

      Mood::WorriedSequence& Mood::
      getWorried ()
      {
        return this->worried_;
      }

      void Mood::
      setWorried (const WorriedSequence& s)
      {
        this->worried_ = s;
      }

      const Mood::OtherSequence& Mood::
      getOther () const
      {
        return this->other_;
      }

      Mood::OtherSequence& Mood::
      getOther ()
      {
        return this->other_;
      }

      void Mood::
      setOther (const OtherSequence& s)
      {
        this->other_ = s;
      }

      const Mood::AnySequence& Mood::
      getAny () const
      {
        return this->any_;
      }

      Mood::AnySequence& Mood::
      getAny ()
      {
        return this->any_;
      }

      void Mood::
      setAny (const AnySequence& s)
      {
        this->any_ = s;
      }

      const Mood::FromOptional& Mood::
      getFrom () const
      {
        return this->from_;
      }

      Mood::FromOptional& Mood::
      getFrom ()
      {
        return this->from_;
      }

      void Mood::
      setFrom (const FromType& x)
      {
        this->from_.set (x);
      }

      void Mood::
      setFrom (const FromOptional& x)
      {
        this->from_ = x;
      }

      void Mood::
      setFrom (::std::unique_ptr< FromType > x)
      {
        this->from_.set (std::move (x));
      }

      const Mood::UntilOptional& Mood::
      getUntil () const
      {
        return this->until_;
      }

      Mood::UntilOptional& Mood::
      getUntil ()
      {
        return this->until_;
      }

      void Mood::
      setUntil (const UntilType& x)
      {
        this->until_.set (x);
      }

      void Mood::
      setUntil (const UntilOptional& x)
      {
        this->until_ = x;
      }

      void Mood::
      setUntil (::std::unique_ptr< UntilType > x)
      {
        this->until_.set (std::move (x));
      }

      const Mood::IdOptional& Mood::
      getId () const
      {
        return this->id_;
      }

      Mood::IdOptional& Mood::
      getId ()
      {
        return this->id_;
      }

      void Mood::
      setId (const IdType& x)
      {
        this->id_.set (x);
      }

      void Mood::
      setId (const IdOptional& x)
      {
        this->id_ = x;
      }

      void Mood::
      setId (::std::unique_ptr< IdType > x)
      {
        this->id_.set (std::move (x));
      }

      const Mood::AnyAttributeSet& Mood::
      getAnyAttribute () const
      {
        return this->any_attribute_;
      }

      Mood::AnyAttributeSet& Mood::
      getAnyAttribute ()
      {
        return this->any_attribute_;
      }

      void Mood::
      setAnyAttribute (const AnyAttributeSet& s)
      {
        this->any_attribute_ = s;
      }

      const ::xercesc::DOMDocument& Mood::
      getDomDocument () const
      {
        return *this->dom_document_;
      }

      ::xercesc::DOMDocument& Mood::
      getDomDocument ()
      {
        return *this->dom_document_;
      }


      // PlaceIs
      // 

      const PlaceIs::NoteSequence& PlaceIs::
      getNote () const
      {
        return this->note_;
      }

      PlaceIs::NoteSequence& PlaceIs::
      getNote ()
      {
        return this->note_;
      }

      void PlaceIs::
      setNote (const NoteSequence& s)
      {
        this->note_ = s;
      }

      const PlaceIs::AudioOptional& PlaceIs::
      getAudio () const
      {
        return this->audio_;
      }

      PlaceIs::AudioOptional& PlaceIs::
      getAudio ()
      {
        return this->audio_;
      }

      void PlaceIs::
      setAudio (const AudioType& x)
      {
        this->audio_.set (x);
      }

      void PlaceIs::
      setAudio (const AudioOptional& x)
      {
        this->audio_ = x;
      }

      void PlaceIs::
      setAudio (::std::unique_ptr< AudioType > x)
      {
        this->audio_.set (std::move (x));
      }

      const PlaceIs::VideoOptional& PlaceIs::
      getVideo () const
      {
        return this->video_;
      }

      PlaceIs::VideoOptional& PlaceIs::
      getVideo ()
      {
        return this->video_;
      }

      void PlaceIs::
      setVideo (const VideoType& x)
      {
        this->video_.set (x);
      }

      void PlaceIs::
      setVideo (const VideoOptional& x)
      {
        this->video_ = x;
      }

      void PlaceIs::
      setVideo (::std::unique_ptr< VideoType > x)
      {
        this->video_.set (std::move (x));
      }

      const PlaceIs::TextOptional& PlaceIs::
      getText () const
      {
        return this->text_;
      }

      PlaceIs::TextOptional& PlaceIs::
      getText ()
      {
        return this->text_;
      }

      void PlaceIs::
      setText (const TextType& x)
      {
        this->text_.set (x);
      }

      void PlaceIs::
      setText (const TextOptional& x)
      {
        this->text_ = x;
      }

      void PlaceIs::
      setText (::std::unique_ptr< TextType > x)
      {
        this->text_.set (std::move (x));
      }

      const PlaceIs::FromOptional& PlaceIs::
      getFrom () const
      {
        return this->from_;
      }

      PlaceIs::FromOptional& PlaceIs::
      getFrom ()
      {
        return this->from_;
      }

      void PlaceIs::
      setFrom (const FromType& x)
      {
        this->from_.set (x);
      }

      void PlaceIs::
      setFrom (const FromOptional& x)
      {
        this->from_ = x;
      }

      void PlaceIs::
      setFrom (::std::unique_ptr< FromType > x)
      {
        this->from_.set (std::move (x));
      }

      const PlaceIs::UntilOptional& PlaceIs::
      getUntil () const
      {
        return this->until_;
      }

      PlaceIs::UntilOptional& PlaceIs::
      getUntil ()
      {
        return this->until_;
      }

      void PlaceIs::
      setUntil (const UntilType& x)
      {
        this->until_.set (x);
      }

      void PlaceIs::
      setUntil (const UntilOptional& x)
      {
        this->until_ = x;
      }

      void PlaceIs::
      setUntil (::std::unique_ptr< UntilType > x)
      {
        this->until_.set (std::move (x));
      }

      const PlaceIs::IdOptional& PlaceIs::
      getId () const
      {
        return this->id_;
      }

      PlaceIs::IdOptional& PlaceIs::
      getId ()
      {
        return this->id_;
      }

      void PlaceIs::
      setId (const IdType& x)
      {
        this->id_.set (x);
      }

      void PlaceIs::
      setId (const IdOptional& x)
      {
        this->id_ = x;
      }

      void PlaceIs::
      setId (::std::unique_ptr< IdType > x)
      {
        this->id_.set (std::move (x));
      }

      const PlaceIs::AnyAttributeSet& PlaceIs::
      getAnyAttribute () const
      {
        return this->any_attribute_;
      }

      PlaceIs::AnyAttributeSet& PlaceIs::
      getAnyAttribute ()
      {
        return this->any_attribute_;
      }

      void PlaceIs::
      setAnyAttribute (const AnyAttributeSet& s)
      {
        this->any_attribute_ = s;
      }

      const ::xercesc::DOMDocument& PlaceIs::
      getDomDocument () const
      {
        return *this->dom_document_;
      }

      ::xercesc::DOMDocument& PlaceIs::
      getDomDocument ()
      {
        return *this->dom_document_;
      }


      // PlaceType
      // 

      const PlaceType::NoteSequence& PlaceType::
      getNote () const
      {
        return this->note_;
      }

      PlaceType::NoteSequence& PlaceType::
      getNote ()
      {
        return this->note_;
      }

      void PlaceType::
      setNote (const NoteSequence& s)
      {
        this->note_ = s;
      }

      const PlaceType::OtherOptional& PlaceType::
      getOther () const
      {
        return this->other_;
      }

      PlaceType::OtherOptional& PlaceType::
      getOther ()
      {
        return this->other_;
      }

      void PlaceType::
      setOther (const OtherType& x)
      {
        this->other_.set (x);
      }

      void PlaceType::
      setOther (const OtherOptional& x)
      {
        this->other_ = x;
      }

      void PlaceType::
      setOther (::std::unique_ptr< OtherType > x)
      {
        this->other_.set (std::move (x));
      }

      const PlaceType::AnySequence& PlaceType::
      getAny () const
      {
        return this->any_;
      }

      PlaceType::AnySequence& PlaceType::
      getAny ()
      {
        return this->any_;
      }

      void PlaceType::
      setAny (const AnySequence& s)
      {
        this->any_ = s;
      }

      const PlaceType::FromOptional& PlaceType::
      getFrom () const
      {
        return this->from_;
      }

      PlaceType::FromOptional& PlaceType::
      getFrom ()
      {
        return this->from_;
      }

      void PlaceType::
      setFrom (const FromType& x)
      {
        this->from_.set (x);
      }

      void PlaceType::
      setFrom (const FromOptional& x)
      {
        this->from_ = x;
      }

      void PlaceType::
      setFrom (::std::unique_ptr< FromType > x)
      {
        this->from_.set (std::move (x));
      }

      const PlaceType::UntilOptional& PlaceType::
      getUntil () const
      {
        return this->until_;
      }

      PlaceType::UntilOptional& PlaceType::
      getUntil ()
      {
        return this->until_;
      }

      void PlaceType::
      setUntil (const UntilType& x)
      {
        this->until_.set (x);
      }

      void PlaceType::
      setUntil (const UntilOptional& x)
      {
        this->until_ = x;
      }

      void PlaceType::
      setUntil (::std::unique_ptr< UntilType > x)
      {
        this->until_.set (std::move (x));
      }

      const PlaceType::IdOptional& PlaceType::
      getId () const
      {
        return this->id_;
      }

      PlaceType::IdOptional& PlaceType::
      getId ()
      {
        return this->id_;
      }

      void PlaceType::
      setId (const IdType& x)
      {
        this->id_.set (x);
      }

      void PlaceType::
      setId (const IdOptional& x)
      {
        this->id_ = x;
      }

      void PlaceType::
      setId (::std::unique_ptr< IdType > x)
      {
        this->id_.set (std::move (x));
      }

      const PlaceType::AnyAttributeSet& PlaceType::
      getAnyAttribute () const
      {
        return this->any_attribute_;
      }

      PlaceType::AnyAttributeSet& PlaceType::
      getAnyAttribute ()
      {
        return this->any_attribute_;
      }

      void PlaceType::
      setAnyAttribute (const AnyAttributeSet& s)
      {
        this->any_attribute_ = s;
      }

      const ::xercesc::DOMDocument& PlaceType::
      getDomDocument () const
      {
        return *this->dom_document_;
      }

      ::xercesc::DOMDocument& PlaceType::
      getDomDocument ()
      {
        return *this->dom_document_;
      }


      // Privacy
      // 

      const Privacy::NoteSequence& Privacy::
      getNote () const
      {
        return this->note_;
      }

      Privacy::NoteSequence& Privacy::
      getNote ()
      {
        return this->note_;
      }

      void Privacy::
      setNote (const NoteSequence& s)
      {
        this->note_ = s;
      }

      const Privacy::UnknownOptional& Privacy::
      getUnknown () const
      {
        return this->unknown_;
      }

      Privacy::UnknownOptional& Privacy::
      getUnknown ()
      {
        return this->unknown_;
      }

      void Privacy::
      setUnknown (const UnknownType& x)
      {
        this->unknown_.set (x);
      }

      void Privacy::
      setUnknown (const UnknownOptional& x)
      {
        this->unknown_ = x;
      }

      void Privacy::
      setUnknown (::std::unique_ptr< UnknownType > x)
      {
        this->unknown_.set (std::move (x));
      }

      const Privacy::AudioOptional& Privacy::
      getAudio () const
      {
        return this->audio_;
      }

      Privacy::AudioOptional& Privacy::
      getAudio ()
      {
        return this->audio_;
      }

      void Privacy::
      setAudio (const AudioType& x)
      {
        this->audio_.set (x);
      }

      void Privacy::
      setAudio (const AudioOptional& x)
      {
        this->audio_ = x;
      }

      void Privacy::
      setAudio (::std::unique_ptr< AudioType > x)
      {
        this->audio_.set (std::move (x));
      }

      const Privacy::TextOptional& Privacy::
      getText () const
      {
        return this->text_;
      }

      Privacy::TextOptional& Privacy::
      getText ()
      {
        return this->text_;
      }

      void Privacy::
      setText (const TextType& x)
      {
        this->text_.set (x);
      }

      void Privacy::
      setText (const TextOptional& x)
      {
        this->text_ = x;
      }

      void Privacy::
      setText (::std::unique_ptr< TextType > x)
      {
        this->text_.set (std::move (x));
      }

      const Privacy::VideoOptional& Privacy::
      getVideo () const
      {
        return this->video_;
      }

      Privacy::VideoOptional& Privacy::
      getVideo ()
      {
        return this->video_;
      }

      void Privacy::
      setVideo (const VideoType& x)
      {
        this->video_.set (x);
      }

      void Privacy::
      setVideo (const VideoOptional& x)
      {
        this->video_ = x;
      }

      void Privacy::
      setVideo (::std::unique_ptr< VideoType > x)
      {
        this->video_.set (std::move (x));
      }

      const Privacy::AnySequence& Privacy::
      getAny () const
      {
        return this->any_;
      }

      Privacy::AnySequence& Privacy::
      getAny ()
      {
        return this->any_;
      }

      void Privacy::
      setAny (const AnySequence& s)
      {
        this->any_ = s;
      }

      const Privacy::FromOptional& Privacy::
      getFrom () const
      {
        return this->from_;
      }

      Privacy::FromOptional& Privacy::
      getFrom ()
      {
        return this->from_;
      }

      void Privacy::
      setFrom (const FromType& x)
      {
        this->from_.set (x);
      }

      void Privacy::
      setFrom (const FromOptional& x)
      {
        this->from_ = x;
      }

      void Privacy::
      setFrom (::std::unique_ptr< FromType > x)
      {
        this->from_.set (std::move (x));
      }

      const Privacy::UntilOptional& Privacy::
      getUntil () const
      {
        return this->until_;
      }

      Privacy::UntilOptional& Privacy::
      getUntil ()
      {
        return this->until_;
      }

      void Privacy::
      setUntil (const UntilType& x)
      {
        this->until_.set (x);
      }

      void Privacy::
      setUntil (const UntilOptional& x)
      {
        this->until_ = x;
      }

      void Privacy::
      setUntil (::std::unique_ptr< UntilType > x)
      {
        this->until_.set (std::move (x));
      }

      const Privacy::IdOptional& Privacy::
      getId () const
      {
        return this->id_;
      }

      Privacy::IdOptional& Privacy::
      getId ()
      {
        return this->id_;
      }

      void Privacy::
      setId (const IdType& x)
      {
        this->id_.set (x);
      }

      void Privacy::
      setId (const IdOptional& x)
      {
        this->id_ = x;
      }

      void Privacy::
      setId (::std::unique_ptr< IdType > x)
      {
        this->id_.set (std::move (x));
      }

      const Privacy::AnyAttributeSet& Privacy::
      getAnyAttribute () const
      {
        return this->any_attribute_;
      }

      Privacy::AnyAttributeSet& Privacy::
      getAnyAttribute ()
      {
        return this->any_attribute_;
      }

      void Privacy::
      setAnyAttribute (const AnyAttributeSet& s)
      {
        this->any_attribute_ = s;
      }

      const ::xercesc::DOMDocument& Privacy::
      getDomDocument () const
      {
        return *this->dom_document_;
      }

      ::xercesc::DOMDocument& Privacy::
      getDomDocument ()
      {
        return *this->dom_document_;
      }


      // Relationship
      // 

      const Relationship::NoteSequence& Relationship::
      getNote () const
      {
        return this->note_;
      }

      Relationship::NoteSequence& Relationship::
      getNote ()
      {
        return this->note_;
      }

      void Relationship::
      setNote (const NoteSequence& s)
      {
        this->note_ = s;
      }

      const Relationship::AssistantOptional& Relationship::
      getAssistant () const
      {
        return this->assistant_;
      }

      Relationship::AssistantOptional& Relationship::
      getAssistant ()
      {
        return this->assistant_;
      }

      void Relationship::
      setAssistant (const AssistantType& x)
      {
        this->assistant_.set (x);
      }

      void Relationship::
      setAssistant (const AssistantOptional& x)
      {
        this->assistant_ = x;
      }

      void Relationship::
      setAssistant (::std::unique_ptr< AssistantType > x)
      {
        this->assistant_.set (std::move (x));
      }

      const Relationship::AssociateOptional& Relationship::
      getAssociate () const
      {
        return this->associate_;
      }

      Relationship::AssociateOptional& Relationship::
      getAssociate ()
      {
        return this->associate_;
      }

      void Relationship::
      setAssociate (const AssociateType& x)
      {
        this->associate_.set (x);
      }

      void Relationship::
      setAssociate (const AssociateOptional& x)
      {
        this->associate_ = x;
      }

      void Relationship::
      setAssociate (::std::unique_ptr< AssociateType > x)
      {
        this->associate_.set (std::move (x));
      }

      const Relationship::FamilyOptional& Relationship::
      getFamily () const
      {
        return this->family_;
      }

      Relationship::FamilyOptional& Relationship::
      getFamily ()
      {
        return this->family_;
      }

      void Relationship::
      setFamily (const FamilyType& x)
      {
        this->family_.set (x);
      }

      void Relationship::
      setFamily (const FamilyOptional& x)
      {
        this->family_ = x;
      }

      void Relationship::
      setFamily (::std::unique_ptr< FamilyType > x)
      {
        this->family_.set (std::move (x));
      }

      const Relationship::FriendOptional& Relationship::
      getFriend () const
      {
        return this->friend__;
      }

      Relationship::FriendOptional& Relationship::
      getFriend ()
      {
        return this->friend__;
      }

      void Relationship::
      setFriend (const FriendType& x)
      {
        this->friend__.set (x);
      }

      void Relationship::
      setFriend (const FriendOptional& x)
      {
        this->friend__ = x;
      }

      void Relationship::
      setFriend (::std::unique_ptr< FriendType > x)
      {
        this->friend__.set (std::move (x));
      }

      const Relationship::OtherOptional& Relationship::
      getOther () const
      {
        return this->other_;
      }

      Relationship::OtherOptional& Relationship::
      getOther ()
      {
        return this->other_;
      }

      void Relationship::
      setOther (const OtherType& x)
      {
        this->other_.set (x);
      }

      void Relationship::
      setOther (const OtherOptional& x)
      {
        this->other_ = x;
      }

      void Relationship::
      setOther (::std::unique_ptr< OtherType > x)
      {
        this->other_.set (std::move (x));
      }

      const Relationship::SelfOptional& Relationship::
      getSelf () const
      {
        return this->self_;
      }

      Relationship::SelfOptional& Relationship::
      getSelf ()
      {
        return this->self_;
      }

      void Relationship::
      setSelf (const SelfType& x)
      {
        this->self_.set (x);
      }

      void Relationship::
      setSelf (const SelfOptional& x)
      {
        this->self_ = x;
      }

      void Relationship::
      setSelf (::std::unique_ptr< SelfType > x)
      {
        this->self_.set (std::move (x));
      }

      const Relationship::SupervisorOptional& Relationship::
      getSupervisor () const
      {
        return this->supervisor_;
      }

      Relationship::SupervisorOptional& Relationship::
      getSupervisor ()
      {
        return this->supervisor_;
      }

      void Relationship::
      setSupervisor (const SupervisorType& x)
      {
        this->supervisor_.set (x);
      }

      void Relationship::
      setSupervisor (const SupervisorOptional& x)
      {
        this->supervisor_ = x;
      }

      void Relationship::
      setSupervisor (::std::unique_ptr< SupervisorType > x)
      {
        this->supervisor_.set (std::move (x));
      }

      const Relationship::UnknownOptional& Relationship::
      getUnknown () const
      {
        return this->unknown_;
      }

      Relationship::UnknownOptional& Relationship::
      getUnknown ()
      {
        return this->unknown_;
      }

      void Relationship::
      setUnknown (const UnknownType& x)
      {
        this->unknown_.set (x);
      }

      void Relationship::
      setUnknown (const UnknownOptional& x)
      {
        this->unknown_ = x;
      }

      void Relationship::
      setUnknown (::std::unique_ptr< UnknownType > x)
      {
        this->unknown_.set (std::move (x));
      }

      const Relationship::AnySequence& Relationship::
      getAny () const
      {
        return this->any_;
      }

      Relationship::AnySequence& Relationship::
      getAny ()
      {
        return this->any_;
      }

      void Relationship::
      setAny (const AnySequence& s)
      {
        this->any_ = s;
      }

      const ::xercesc::DOMDocument& Relationship::
      getDomDocument () const
      {
        return *this->dom_document_;
      }

      ::xercesc::DOMDocument& Relationship::
      getDomDocument ()
      {
        return *this->dom_document_;
      }


      // ServiceClass
      // 

      const ServiceClass::NoteSequence& ServiceClass::
      getNote () const
      {
        return this->note_;
      }

      ServiceClass::NoteSequence& ServiceClass::
      getNote ()
      {
        return this->note_;
      }

      void ServiceClass::
      setNote (const NoteSequence& s)
      {
        this->note_ = s;
      }

      const ServiceClass::CourierOptional& ServiceClass::
      getCourier () const
      {
        return this->courier_;
      }

      ServiceClass::CourierOptional& ServiceClass::
      getCourier ()
      {
        return this->courier_;
      }

      void ServiceClass::
      setCourier (const CourierType& x)
      {
        this->courier_.set (x);
      }

      void ServiceClass::
      setCourier (const CourierOptional& x)
      {
        this->courier_ = x;
      }

      void ServiceClass::
      setCourier (::std::unique_ptr< CourierType > x)
      {
        this->courier_.set (std::move (x));
      }

      const ServiceClass::ElectronicOptional& ServiceClass::
      getElectronic () const
      {
        return this->electronic_;
      }

      ServiceClass::ElectronicOptional& ServiceClass::
      getElectronic ()
      {
        return this->electronic_;
      }

      void ServiceClass::
      setElectronic (const ElectronicType& x)
      {
        this->electronic_.set (x);
      }

      void ServiceClass::
      setElectronic (const ElectronicOptional& x)
      {
        this->electronic_ = x;
      }

      void ServiceClass::
      setElectronic (::std::unique_ptr< ElectronicType > x)
      {
        this->electronic_.set (std::move (x));
      }

      const ServiceClass::FreightOptional& ServiceClass::
      getFreight () const
      {
        return this->freight_;
      }

      ServiceClass::FreightOptional& ServiceClass::
      getFreight ()
      {
        return this->freight_;
      }

      void ServiceClass::
      setFreight (const FreightType& x)
      {
        this->freight_.set (x);
      }

      void ServiceClass::
      setFreight (const FreightOptional& x)
      {
        this->freight_ = x;
      }

      void ServiceClass::
      setFreight (::std::unique_ptr< FreightType > x)
      {
        this->freight_.set (std::move (x));
      }

      const ServiceClass::InPersonOptional& ServiceClass::
      getInPerson () const
      {
        return this->in_person_;
      }

      ServiceClass::InPersonOptional& ServiceClass::
      getInPerson ()
      {
        return this->in_person_;
      }

      void ServiceClass::
      setInPerson (const InPersonType& x)
      {
        this->in_person_.set (x);
      }

      void ServiceClass::
      setInPerson (const InPersonOptional& x)
      {
        this->in_person_ = x;
      }

      void ServiceClass::
      setInPerson (::std::unique_ptr< InPersonType > x)
      {
        this->in_person_.set (std::move (x));
      }

      const ServiceClass::PostalOptional& ServiceClass::
      getPostal () const
      {
        return this->postal_;
      }

      ServiceClass::PostalOptional& ServiceClass::
      getPostal ()
      {
        return this->postal_;
      }

      void ServiceClass::
      setPostal (const PostalType& x)
      {
        this->postal_.set (x);
      }

      void ServiceClass::
      setPostal (const PostalOptional& x)
      {
        this->postal_ = x;
      }

      void ServiceClass::
      setPostal (::std::unique_ptr< PostalType > x)
      {
        this->postal_.set (std::move (x));
      }

      const ServiceClass::UnknownOptional& ServiceClass::
      getUnknown () const
      {
        return this->unknown_;
      }

      ServiceClass::UnknownOptional& ServiceClass::
      getUnknown ()
      {
        return this->unknown_;
      }

      void ServiceClass::
      setUnknown (const UnknownType& x)
      {
        this->unknown_.set (x);
      }

      void ServiceClass::
      setUnknown (const UnknownOptional& x)
      {
        this->unknown_ = x;
      }

      void ServiceClass::
      setUnknown (::std::unique_ptr< UnknownType > x)
      {
        this->unknown_.set (std::move (x));
      }

      const ServiceClass::AnySequence& ServiceClass::
      getAny () const
      {
        return this->any_;
      }

      ServiceClass::AnySequence& ServiceClass::
      getAny ()
      {
        return this->any_;
      }

      void ServiceClass::
      setAny (const AnySequence& s)
      {
        this->any_ = s;
      }

      const ::xercesc::DOMDocument& ServiceClass::
      getDomDocument () const
      {
        return *this->dom_document_;
      }

      ::xercesc::DOMDocument& ServiceClass::
      getDomDocument ()
      {
        return *this->dom_document_;
      }


      // Sphere
      // 

      const Sphere::HomeOptional& Sphere::
      getHome () const
      {
        return this->home_;
      }

      Sphere::HomeOptional& Sphere::
      getHome ()
      {
        return this->home_;
      }

      void Sphere::
      setHome (const HomeType& x)
      {
        this->home_.set (x);
      }

      void Sphere::
      setHome (const HomeOptional& x)
      {
        this->home_ = x;
      }

      void Sphere::
      setHome (::std::unique_ptr< HomeType > x)
      {
        this->home_.set (std::move (x));
      }

      const Sphere::WorkOptional& Sphere::
      getWork () const
      {
        return this->work_;
      }

      Sphere::WorkOptional& Sphere::
      getWork ()
      {
        return this->work_;
      }

      void Sphere::
      setWork (const WorkType& x)
      {
        this->work_.set (x);
      }

      void Sphere::
      setWork (const WorkOptional& x)
      {
        this->work_ = x;
      }

      void Sphere::
      setWork (::std::unique_ptr< WorkType > x)
      {
        this->work_.set (std::move (x));
      }

      const Sphere::UnknownOptional& Sphere::
      getUnknown () const
      {
        return this->unknown_;
      }

      Sphere::UnknownOptional& Sphere::
      getUnknown ()
      {
        return this->unknown_;
      }

      void Sphere::
      setUnknown (const UnknownType& x)
      {
        this->unknown_.set (x);
      }

      void Sphere::
      setUnknown (const UnknownOptional& x)
      {
        this->unknown_ = x;
      }

      void Sphere::
      setUnknown (::std::unique_ptr< UnknownType > x)
      {
        this->unknown_.set (std::move (x));
      }

      const Sphere::AnySequence& Sphere::
      getAny () const
      {
        return this->any_;
      }

      Sphere::AnySequence& Sphere::
      getAny ()
      {
        return this->any_;
      }

      void Sphere::
      setAny (const AnySequence& s)
      {
        this->any_ = s;
      }

      const Sphere::FromOptional& Sphere::
      getFrom () const
      {
        return this->from_;
      }

      Sphere::FromOptional& Sphere::
      getFrom ()
      {
        return this->from_;
      }

      void Sphere::
      setFrom (const FromType& x)
      {
        this->from_.set (x);
      }

      void Sphere::
      setFrom (const FromOptional& x)
      {
        this->from_ = x;
      }

      void Sphere::
      setFrom (::std::unique_ptr< FromType > x)
      {
        this->from_.set (std::move (x));
      }

      const Sphere::UntilOptional& Sphere::
      getUntil () const
      {
        return this->until_;
      }

      Sphere::UntilOptional& Sphere::
      getUntil ()
      {
        return this->until_;
      }

      void Sphere::
      setUntil (const UntilType& x)
      {
        this->until_.set (x);
      }

      void Sphere::
      setUntil (const UntilOptional& x)
      {
        this->until_ = x;
      }

      void Sphere::
      setUntil (::std::unique_ptr< UntilType > x)
      {
        this->until_.set (std::move (x));
      }

      const Sphere::IdOptional& Sphere::
      getId () const
      {
        return this->id_;
      }

      Sphere::IdOptional& Sphere::
      getId ()
      {
        return this->id_;
      }

      void Sphere::
      setId (const IdType& x)
      {
        this->id_.set (x);
      }

      void Sphere::
      setId (const IdOptional& x)
      {
        this->id_ = x;
      }

      void Sphere::
      setId (::std::unique_ptr< IdType > x)
      {
        this->id_.set (std::move (x));
      }

      const Sphere::AnyAttributeSet& Sphere::
      getAnyAttribute () const
      {
        return this->any_attribute_;
      }

      Sphere::AnyAttributeSet& Sphere::
      getAnyAttribute ()
      {
        return this->any_attribute_;
      }

      void Sphere::
      setAnyAttribute (const AnyAttributeSet& s)
      {
        this->any_attribute_ = s;
      }

      const ::xercesc::DOMDocument& Sphere::
      getDomDocument () const
      {
        return *this->dom_document_;
      }

      ::xercesc::DOMDocument& Sphere::
      getDomDocument ()
      {
        return *this->dom_document_;
      }


      // StatusIcon
      // 

      const StatusIcon::FromOptional& StatusIcon::
      getFrom () const
      {
        return this->from_;
      }

      StatusIcon::FromOptional& StatusIcon::
      getFrom ()
      {
        return this->from_;
      }

      void StatusIcon::
      setFrom (const FromType& x)
      {
        this->from_.set (x);
      }

      void StatusIcon::
      setFrom (const FromOptional& x)
      {
        this->from_ = x;
      }

      void StatusIcon::
      setFrom (::std::unique_ptr< FromType > x)
      {
        this->from_.set (std::move (x));
      }

      const StatusIcon::UntilOptional& StatusIcon::
      getUntil () const
      {
        return this->until_;
      }

      StatusIcon::UntilOptional& StatusIcon::
      getUntil ()
      {
        return this->until_;
      }

      void StatusIcon::
      setUntil (const UntilType& x)
      {
        this->until_.set (x);
      }

      void StatusIcon::
      setUntil (const UntilOptional& x)
      {
        this->until_ = x;
      }

      void StatusIcon::
      setUntil (::std::unique_ptr< UntilType > x)
      {
        this->until_.set (std::move (x));
      }

      const StatusIcon::IdOptional& StatusIcon::
      getId () const
      {
        return this->id_;
      }

      StatusIcon::IdOptional& StatusIcon::
      getId ()
      {
        return this->id_;
      }

      void StatusIcon::
      setId (const IdType& x)
      {
        this->id_.set (x);
      }

      void StatusIcon::
      setId (const IdOptional& x)
      {
        this->id_ = x;
      }

      void StatusIcon::
      setId (::std::unique_ptr< IdType > x)
      {
        this->id_.set (std::move (x));
      }

      const StatusIcon::AnyAttributeSet& StatusIcon::
      getAnyAttribute () const
      {
        return this->any_attribute_;
      }

      StatusIcon::AnyAttributeSet& StatusIcon::
      getAnyAttribute ()
      {
        return this->any_attribute_;
      }

      void StatusIcon::
      setAnyAttribute (const AnyAttributeSet& s)
      {
        this->any_attribute_ = s;
      }

      const ::xercesc::DOMDocument& StatusIcon::
      getDomDocument () const
      {
        return *this->dom_document_;
      }

      ::xercesc::DOMDocument& StatusIcon::
      getDomDocument ()
      {
        return *this->dom_document_;
      }


      // TimeOffset
      // 

      const TimeOffset::FromOptional& TimeOffset::
      getFrom () const
      {
        return this->from_;
      }

      TimeOffset::FromOptional& TimeOffset::
      getFrom ()
      {
        return this->from_;
      }

      void TimeOffset::
      setFrom (const FromType& x)
      {
        this->from_.set (x);
      }

      void TimeOffset::
      setFrom (const FromOptional& x)
      {
        this->from_ = x;
      }

      void TimeOffset::
      setFrom (::std::unique_ptr< FromType > x)
      {
        this->from_.set (std::move (x));
      }

      const TimeOffset::UntilOptional& TimeOffset::
      getUntil () const
      {
        return this->until_;
      }

      TimeOffset::UntilOptional& TimeOffset::
      getUntil ()
      {
        return this->until_;
      }

      void TimeOffset::
      setUntil (const UntilType& x)
      {
        this->until_.set (x);
      }

      void TimeOffset::
      setUntil (const UntilOptional& x)
      {
        this->until_ = x;
      }

      void TimeOffset::
      setUntil (::std::unique_ptr< UntilType > x)
      {
        this->until_.set (std::move (x));
      }

      const TimeOffset::DescriptionOptional& TimeOffset::
      getDescription () const
      {
        return this->description_;
      }

      TimeOffset::DescriptionOptional& TimeOffset::
      getDescription ()
      {
        return this->description_;
      }

      void TimeOffset::
      setDescription (const DescriptionType& x)
      {
        this->description_.set (x);
      }

      void TimeOffset::
      setDescription (const DescriptionOptional& x)
      {
        this->description_ = x;
      }

      void TimeOffset::
      setDescription (::std::unique_ptr< DescriptionType > x)
      {
        this->description_.set (std::move (x));
      }

      const TimeOffset::IdOptional& TimeOffset::
      getId () const
      {
        return this->id_;
      }

      TimeOffset::IdOptional& TimeOffset::
      getId ()
      {
        return this->id_;
      }

      void TimeOffset::
      setId (const IdType& x)
      {
        this->id_.set (x);
      }

      void TimeOffset::
      setId (const IdOptional& x)
      {
        this->id_ = x;
      }

      void TimeOffset::
      setId (::std::unique_ptr< IdType > x)
      {
        this->id_.set (std::move (x));
      }

      const TimeOffset::AnyAttributeSet& TimeOffset::
      getAnyAttribute () const
      {
        return this->any_attribute_;
      }

      TimeOffset::AnyAttributeSet& TimeOffset::
      getAnyAttribute ()
      {
        return this->any_attribute_;
      }

      void TimeOffset::
      setAnyAttribute (const AnyAttributeSet& s)
      {
        this->any_attribute_ = s;
      }

      const ::xercesc::DOMDocument& TimeOffset::
      getDomDocument () const
      {
        return *this->dom_document_;
      }

      ::xercesc::DOMDocument& TimeOffset::
      getDomDocument ()
      {
        return *this->dom_document_;
      }


      // UserInput
      // 

      const UserInput::IdleThresholdOptional& UserInput::
      getIdleThreshold () const
      {
        return this->idle_threshold_;
      }

      UserInput::IdleThresholdOptional& UserInput::
      getIdleThreshold ()
      {
        return this->idle_threshold_;
      }

      void UserInput::
      setIdleThreshold (const IdleThresholdType& x)
      {
        this->idle_threshold_.set (x);
      }

      void UserInput::
      setIdleThreshold (const IdleThresholdOptional& x)
      {
        this->idle_threshold_ = x;
      }

      const UserInput::LastInputOptional& UserInput::
      getLastInput () const
      {
        return this->last_input_;
      }

      UserInput::LastInputOptional& UserInput::
      getLastInput ()
      {
        return this->last_input_;
      }

      void UserInput::
      setLastInput (const LastInputType& x)
      {
        this->last_input_.set (x);
      }

      void UserInput::
      setLastInput (const LastInputOptional& x)
      {
        this->last_input_ = x;
      }

      void UserInput::
      setLastInput (::std::unique_ptr< LastInputType > x)
      {
        this->last_input_.set (std::move (x));
      }

      const UserInput::IdOptional& UserInput::
      getId () const
      {
        return this->id_;
      }

      UserInput::IdOptional& UserInput::
      getId ()
      {
        return this->id_;
      }

      void UserInput::
      setId (const IdType& x)
      {
        this->id_.set (x);
      }

      void UserInput::
      setId (const IdOptional& x)
      {
        this->id_ = x;
      }

      void UserInput::
      setId (::std::unique_ptr< IdType > x)
      {
        this->id_.set (std::move (x));
      }

      const UserInput::AnyAttributeSet& UserInput::
      getAnyAttribute () const
      {
        return this->any_attribute_;
      }

      UserInput::AnyAttributeSet& UserInput::
      getAnyAttribute ()
      {
        return this->any_attribute_;
      }

      void UserInput::
      setAnyAttribute (const AnyAttributeSet& s)
      {
        this->any_attribute_ = s;
      }

      const ::xercesc::DOMDocument& UserInput::
      getDomDocument () const
      {
        return *this->dom_document_;
      }

      ::xercesc::DOMDocument& UserInput::
      getDomDocument ()
      {
        return *this->dom_document_;
      }


      // Audio
      // 

      const Audio::NoisyOptional& Audio::
      getNoisy () const
      {
        return this->noisy_;
      }

      Audio::NoisyOptional& Audio::
      getNoisy ()
      {
        return this->noisy_;
      }

      void Audio::
      setNoisy (const NoisyType& x)
      {
        this->noisy_.set (x);
      }

      void Audio::
      setNoisy (const NoisyOptional& x)
      {
        this->noisy_ = x;
      }

      void Audio::
      setNoisy (::std::unique_ptr< NoisyType > x)
      {
        this->noisy_.set (std::move (x));
      }

      const Audio::OkOptional& Audio::
      getOk () const
      {
        return this->ok_;
      }

      Audio::OkOptional& Audio::
      getOk ()
      {
        return this->ok_;
      }

      void Audio::
      setOk (const OkType& x)
      {
        this->ok_.set (x);
      }

      void Audio::
      setOk (const OkOptional& x)
      {
        this->ok_ = x;
      }

      void Audio::
      setOk (::std::unique_ptr< OkType > x)
      {
        this->ok_.set (std::move (x));
      }

      const Audio::QuietOptional& Audio::
      getQuiet () const
      {
        return this->quiet_;
      }

      Audio::QuietOptional& Audio::
      getQuiet ()
      {
        return this->quiet_;
      }

      void Audio::
      setQuiet (const QuietType& x)
      {
        this->quiet_.set (x);
      }

      void Audio::
      setQuiet (const QuietOptional& x)
      {
        this->quiet_ = x;
      }

      void Audio::
      setQuiet (::std::unique_ptr< QuietType > x)
      {
        this->quiet_.set (std::move (x));
      }

      const Audio::UnknownOptional& Audio::
      getUnknown () const
      {
        return this->unknown_;
      }

      Audio::UnknownOptional& Audio::
      getUnknown ()
      {
        return this->unknown_;
      }

      void Audio::
      setUnknown (const UnknownType& x)
      {
        this->unknown_.set (x);
      }

      void Audio::
      setUnknown (const UnknownOptional& x)
      {
        this->unknown_ = x;
      }

      void Audio::
      setUnknown (::std::unique_ptr< UnknownType > x)
      {
        this->unknown_.set (std::move (x));
      }


      // Video
      // 

      const Video::ToobrightOptional& Video::
      getToobright () const
      {
        return this->toobright_;
      }

      Video::ToobrightOptional& Video::
      getToobright ()
      {
        return this->toobright_;
      }

      void Video::
      setToobright (const ToobrightType& x)
      {
        this->toobright_.set (x);
      }

      void Video::
      setToobright (const ToobrightOptional& x)
      {
        this->toobright_ = x;
      }

      void Video::
      setToobright (::std::unique_ptr< ToobrightType > x)
      {
        this->toobright_.set (std::move (x));
      }

      const Video::OkOptional& Video::
      getOk () const
      {
        return this->ok_;
      }

      Video::OkOptional& Video::
      getOk ()
      {
        return this->ok_;
      }

      void Video::
      setOk (const OkType& x)
      {
        this->ok_.set (x);
      }

      void Video::
      setOk (const OkOptional& x)
      {
        this->ok_ = x;
      }

      void Video::
      setOk (::std::unique_ptr< OkType > x)
      {
        this->ok_.set (std::move (x));
      }

      const Video::DarkOptional& Video::
      getDark () const
      {
        return this->dark_;
      }

      Video::DarkOptional& Video::
      getDark ()
      {
        return this->dark_;
      }

      void Video::
      setDark (const DarkType& x)
      {
        this->dark_.set (x);
      }

      void Video::
      setDark (const DarkOptional& x)
      {
        this->dark_ = x;
      }

      void Video::
      setDark (::std::unique_ptr< DarkType > x)
      {
        this->dark_.set (std::move (x));
      }

      const Video::UnknownOptional& Video::
      getUnknown () const
      {
        return this->unknown_;
      }

      Video::UnknownOptional& Video::
      getUnknown ()
      {
        return this->unknown_;
      }

      void Video::
      setUnknown (const UnknownType& x)
      {
        this->unknown_.set (x);
      }

      void Video::
      setUnknown (const UnknownOptional& x)
      {
        this->unknown_ = x;
      }

      void Video::
      setUnknown (::std::unique_ptr< UnknownType > x)
      {
        this->unknown_.set (std::move (x));
      }


      // Text
      // 

      const Text::UncomfortableOptional& Text::
      getUncomfortable () const
      {
        return this->uncomfortable_;
      }

      Text::UncomfortableOptional& Text::
      getUncomfortable ()
      {
        return this->uncomfortable_;
      }

      void Text::
      setUncomfortable (const UncomfortableType& x)
      {
        this->uncomfortable_.set (x);
      }

      void Text::
      setUncomfortable (const UncomfortableOptional& x)
      {
        this->uncomfortable_ = x;
      }

      void Text::
      setUncomfortable (::std::unique_ptr< UncomfortableType > x)
      {
        this->uncomfortable_.set (std::move (x));
      }

      const Text::InappropriateOptional& Text::
      getInappropriate () const
      {
        return this->inappropriate_;
      }

      Text::InappropriateOptional& Text::
      getInappropriate ()
      {
        return this->inappropriate_;
      }

      void Text::
      setInappropriate (const InappropriateType& x)
      {
        this->inappropriate_.set (x);
      }

      void Text::
      setInappropriate (const InappropriateOptional& x)
      {
        this->inappropriate_ = x;
      }

      void Text::
      setInappropriate (::std::unique_ptr< InappropriateType > x)
      {
        this->inappropriate_.set (std::move (x));
      }

      const Text::OkOptional& Text::
      getOk () const
      {
        return this->ok_;
      }

      Text::OkOptional& Text::
      getOk ()
      {
        return this->ok_;
      }

      void Text::
      setOk (const OkType& x)
      {
        this->ok_.set (x);
      }

      void Text::
      setOk (const OkOptional& x)
      {
        this->ok_ = x;
      }

      void Text::
      setOk (::std::unique_ptr< OkType > x)
      {
        this->ok_.set (std::move (x));
      }

      const Text::UnknownOptional& Text::
      getUnknown () const
      {
        return this->unknown_;
      }

      Text::UnknownOptional& Text::
      getUnknown ()
      {
        return this->unknown_;
      }

      void Text::
      setUnknown (const UnknownType& x)
      {
        this->unknown_.set (x);
      }

      void Text::
      setUnknown (const UnknownOptional& x)
      {
        this->unknown_ = x;
      }

      void Text::
      setUnknown (::std::unique_ptr< UnknownType > x)
      {
        this->unknown_.set (std::move (x));
      }
    }
  }
}

#include <xsd/cxx/xml/dom/wildcard-source.hxx>

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace flexisip
{
  namespace Xsd
  {
    namespace Rpid
    {
      // Timestamp_t
      //

      Timestamp_t::
      Timestamp_t (const ::flexisip::Xsd::XmlSchema::DateTime& _xsd_DateTime_base)
      : ::flexisip::Xsd::XmlSchema::DateTime (_xsd_DateTime_base)
      {
      }

      Timestamp_t::
      Timestamp_t (const Timestamp_t& x,
                   ::flexisip::Xsd::XmlSchema::Flags f,
                   ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::DateTime (x, f, c)
      {
      }

      Timestamp_t::
      Timestamp_t (const ::xercesc::DOMElement& e,
                   ::flexisip::Xsd::XmlSchema::Flags f,
                   ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::DateTime (e, f, c)
      {
      }

      Timestamp_t::
      Timestamp_t (const ::xercesc::DOMAttr& a,
                   ::flexisip::Xsd::XmlSchema::Flags f,
                   ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::DateTime (a, f, c)
      {
      }

      Timestamp_t::
      Timestamp_t (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::flexisip::Xsd::XmlSchema::Flags f,
                   ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::DateTime (s, e, f, c)
      {
      }

      Timestamp_t* Timestamp_t::
      _clone (::flexisip::Xsd::XmlSchema::Flags f,
              ::flexisip::Xsd::XmlSchema::Container* c) const
      {
        return new class Timestamp_t (*this, f, c);
      }

      Timestamp_t::
      ~Timestamp_t ()
      {
      }

      // DeviceID_t
      //

      DeviceID_t::
      DeviceID_t (const ::flexisip::Xsd::XmlSchema::Uri& _xsd_Uri_base)
      : ::flexisip::Xsd::XmlSchema::Uri (_xsd_Uri_base)
      {
      }

      DeviceID_t::
      DeviceID_t (const DeviceID_t& x,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Uri (x, f, c)
      {
      }

      DeviceID_t::
      DeviceID_t (const ::xercesc::DOMElement& e,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Uri (e, f, c)
      {
      }

      DeviceID_t::
      DeviceID_t (const ::xercesc::DOMAttr& a,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Uri (a, f, c)
      {
      }

      DeviceID_t::
      DeviceID_t (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Uri (s, e, f, c)
      {
      }

      DeviceID_t* DeviceID_t::
      _clone (::flexisip::Xsd::XmlSchema::Flags f,
              ::flexisip::Xsd::XmlSchema::Container* c) const
      {
        return new class DeviceID_t (*this, f, c);
      }

      DeviceID_t::
      ~DeviceID_t ()
      {
      }

      // Note_t
      //

      Note_t::
      Note_t ()
      : ::flexisip::Xsd::XmlSchema::String (),
        lang_ (this)
      {
      }

      Note_t::
      Note_t (const char* _xsd_String_base)
      : ::flexisip::Xsd::XmlSchema::String (_xsd_String_base),
        lang_ (this)
      {
      }

      Note_t::
      Note_t (const ::std::string& _xsd_String_base)
      : ::flexisip::Xsd::XmlSchema::String (_xsd_String_base),
        lang_ (this)
      {
      }

      Note_t::
      Note_t (const ::flexisip::Xsd::XmlSchema::String& _xsd_String_base)
      : ::flexisip::Xsd::XmlSchema::String (_xsd_String_base),
        lang_ (this)
      {
      }

      Note_t::
      Note_t (const Note_t& x,
              ::flexisip::Xsd::XmlSchema::Flags f,
              ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::String (x, f, c),
        lang_ (x.lang_, f, this)
      {
      }

      Note_t::
      Note_t (const ::xercesc::DOMElement& e,
              ::flexisip::Xsd::XmlSchema::Flags f,
              ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::String (e, f | ::flexisip::Xsd::XmlSchema::Flags::base, c),
        lang_ (this)
      {
        if ((f & ::flexisip::Xsd::XmlSchema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void Note_t::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "lang" && n.namespace_ () == "http://www.w3.org/XML/1998/namespace")
          {
            this->lang_.set (LangTraits::create (i, f, this));
            continue;
          }
        }
      }

      Note_t* Note_t::
      _clone (::flexisip::Xsd::XmlSchema::Flags f,
              ::flexisip::Xsd::XmlSchema::Container* c) const
      {
        return new class Note_t (*this, f, c);
      }

      Note_t& Note_t::
      operator= (const Note_t& x)
      {
        if (this != &x)
        {
          static_cast< ::flexisip::Xsd::XmlSchema::String& > (*this) = x;
          this->lang_ = x.lang_;
        }

        return *this;
      }

      Note_t::
      ~Note_t ()
      {
      }

      // Empty
      //

      Empty::
      Empty ()
      : ::flexisip::Xsd::XmlSchema::Type ()
      {
      }

      Empty::
      Empty (const Empty& x,
             ::flexisip::Xsd::XmlSchema::Flags f,
             ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (x, f, c)
      {
      }

      Empty::
      Empty (const ::xercesc::DOMElement& e,
             ::flexisip::Xsd::XmlSchema::Flags f,
             ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (e, f, c)
      {
      }

      Empty::
      Empty (const ::xercesc::DOMAttr& a,
             ::flexisip::Xsd::XmlSchema::Flags f,
             ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (a, f, c)
      {
      }

      Empty::
      Empty (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::flexisip::Xsd::XmlSchema::Flags f,
             ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (s, e, f, c)
      {
      }

      Empty* Empty::
      _clone (::flexisip::Xsd::XmlSchema::Flags f,
              ::flexisip::Xsd::XmlSchema::Container* c) const
      {
        return new class Empty (*this, f, c);
      }

      Empty::
      ~Empty ()
      {
      }
    }
  }
}

namespace flexisip
{
  namespace Xsd
  {
    namespace Rpid
    {
      // ActiveIdle
      //

      ActiveIdle::
      ActiveIdle (const ::xercesc::DOMElement& e,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::String (e, f, c)
      {
        _xsd_ActiveIdle_convert ();
      }

      ActiveIdle::
      ActiveIdle (const ::xercesc::DOMAttr& a,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::String (a, f, c)
      {
        _xsd_ActiveIdle_convert ();
      }

      ActiveIdle::
      ActiveIdle (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::String (s, e, f, c)
      {
        _xsd_ActiveIdle_convert ();
      }

      ActiveIdle* ActiveIdle::
      _clone (::flexisip::Xsd::XmlSchema::Flags f,
              ::flexisip::Xsd::XmlSchema::Container* c) const
      {
        return new class ActiveIdle (*this, f, c);
      }

      ActiveIdle::Value ActiveIdle::
      _xsd_ActiveIdle_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ActiveIdle_literals_);
        const Value* i (::std::lower_bound (
                          _xsd_ActiveIdle_indexes_,
                          _xsd_ActiveIdle_indexes_ + 2,
                          *this,
                          c));

        if (i == _xsd_ActiveIdle_indexes_ + 2 || _xsd_ActiveIdle_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const ActiveIdle::
      _xsd_ActiveIdle_literals_[2] =
      {
        "active",
        "idle"
      };

      const ActiveIdle::Value ActiveIdle::
      _xsd_ActiveIdle_indexes_[2] =
      {
        ::flexisip::Xsd::Rpid::ActiveIdle::active,
        ::flexisip::Xsd::Rpid::ActiveIdle::idle
      };

      // Activities
      //

      Activities::
      Activities ()
      : ::flexisip::Xsd::XmlSchema::Type (),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        note_ (this),
        unknown_ (this),
        appointment_ (this),
        away_ (this),
        breakfast_ (this),
        busy_ (this),
        dinner_ (this),
        holiday_ (this),
        in_transit_ (this),
        looking_for_work_ (this),
        meal_ (this),
        meeting_ (this),
        on_the_phone_ (this),
        performance_ (this),
        permanent_absence_ (this),
        playing_ (this),
        presentation_ (this),
        shopping_ (this),
        sleeping_ (this),
        spectator_ (this),
        steering_ (this),
        travel_ (this),
        tv_ (this),
        vacation_ (this),
        working_ (this),
        worship_ (this),
        other_ (this),
        any_ (this->getDomDocument ()),
        from_ (this),
        until_ (this),
        id_ (this),
        any_attribute_ (this->getDomDocument ())
      {
      }

      Activities::
      Activities (const Activities& x,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (x, f, c),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        note_ (x.note_, f, this),
        unknown_ (x.unknown_, f, this),
        appointment_ (x.appointment_, f, this),
        away_ (x.away_, f, this),
        breakfast_ (x.breakfast_, f, this),
        busy_ (x.busy_, f, this),
        dinner_ (x.dinner_, f, this),
        holiday_ (x.holiday_, f, this),
        in_transit_ (x.in_transit_, f, this),
        looking_for_work_ (x.looking_for_work_, f, this),
        meal_ (x.meal_, f, this),
        meeting_ (x.meeting_, f, this),
        on_the_phone_ (x.on_the_phone_, f, this),
        performance_ (x.performance_, f, this),
        permanent_absence_ (x.permanent_absence_, f, this),
        playing_ (x.playing_, f, this),
        presentation_ (x.presentation_, f, this),
        shopping_ (x.shopping_, f, this),
        sleeping_ (x.sleeping_, f, this),
        spectator_ (x.spectator_, f, this),
        steering_ (x.steering_, f, this),
        travel_ (x.travel_, f, this),
        tv_ (x.tv_, f, this),
        vacation_ (x.vacation_, f, this),
        working_ (x.working_, f, this),
        worship_ (x.worship_, f, this),
        other_ (x.other_, f, this),
        any_ (x.any_, this->getDomDocument ()),
        from_ (x.from_, f, this),
        until_ (x.until_, f, this),
        id_ (x.id_, f, this),
        any_attribute_ (x.any_attribute_, this->getDomDocument ())
      {
      }

      Activities::
      Activities (const ::xercesc::DOMElement& e,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (e, f | ::flexisip::Xsd::XmlSchema::Flags::base, c),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        note_ (this),
        unknown_ (this),
        appointment_ (this),
        away_ (this),
        breakfast_ (this),
        busy_ (this),
        dinner_ (this),
        holiday_ (this),
        in_transit_ (this),
        looking_for_work_ (this),
        meal_ (this),
        meeting_ (this),
        on_the_phone_ (this),
        performance_ (this),
        permanent_absence_ (this),
        playing_ (this),
        presentation_ (this),
        shopping_ (this),
        sleeping_ (this),
        spectator_ (this),
        steering_ (this),
        travel_ (this),
        tv_ (this),
        vacation_ (this),
        working_ (this),
        worship_ (this),
        other_ (this),
        any_ (this->getDomDocument ()),
        from_ (this),
        until_ (this),
        id_ (this),
        any_attribute_ (this->getDomDocument ())
      {
        if ((f & ::flexisip::Xsd::XmlSchema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void Activities::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // note
          //
          if (n.name () == "note" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< NoteType > r (
              NoteTraits::create (i, f, this));

            this->note_.push_back (::std::move (r));
            continue;
          }

          // unknown
          //
          if (n.name () == "unknown" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< UnknownType > r (
              UnknownTraits::create (i, f, this));

            if (!this->unknown_)
            {
              this->unknown_.set (::std::move (r));
              continue;
            }
          }

          // appointment
          //
          if (n.name () == "appointment" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< AppointmentType > r (
              AppointmentTraits::create (i, f, this));

            this->appointment_.push_back (::std::move (r));
            continue;
          }

          // away
          //
          if (n.name () == "away" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< AwayType > r (
              AwayTraits::create (i, f, this));

            this->away_.push_back (::std::move (r));
            continue;
          }

          // breakfast
          //
          if (n.name () == "breakfast" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< BreakfastType > r (
              BreakfastTraits::create (i, f, this));

            this->breakfast_.push_back (::std::move (r));
            continue;
          }

          // busy
          //
          if (n.name () == "busy" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< BusyType > r (
              BusyTraits::create (i, f, this));

            this->busy_.push_back (::std::move (r));
            continue;
          }

          // dinner
          //
          if (n.name () == "dinner" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< DinnerType > r (
              DinnerTraits::create (i, f, this));

            this->dinner_.push_back (::std::move (r));
            continue;
          }

          // holiday
          //
          if (n.name () == "holiday" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< HolidayType > r (
              HolidayTraits::create (i, f, this));

            this->holiday_.push_back (::std::move (r));
            continue;
          }

          // in-transit
          //
          if (n.name () == "in-transit" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< InTransitType > r (
              InTransitTraits::create (i, f, this));

            this->in_transit_.push_back (::std::move (r));
            continue;
          }

          // looking-for-work
          //
          if (n.name () == "looking-for-work" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< LookingForWorkType > r (
              LookingForWorkTraits::create (i, f, this));

            this->looking_for_work_.push_back (::std::move (r));
            continue;
          }

          // meal
          //
          if (n.name () == "meal" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< MealType > r (
              MealTraits::create (i, f, this));

            this->meal_.push_back (::std::move (r));
            continue;
          }

          // meeting
          //
          if (n.name () == "meeting" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< MeetingType > r (
              MeetingTraits::create (i, f, this));

            this->meeting_.push_back (::std::move (r));
            continue;
          }

          // on-the-phone
          //
          if (n.name () == "on-the-phone" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< OnThePhoneType > r (
              OnThePhoneTraits::create (i, f, this));

            this->on_the_phone_.push_back (::std::move (r));
            continue;
          }

          // performance
          //
          if (n.name () == "performance" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< PerformanceType > r (
              PerformanceTraits::create (i, f, this));

            this->performance_.push_back (::std::move (r));
            continue;
          }

          // permanent-absence
          //
          if (n.name () == "permanent-absence" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< PermanentAbsenceType > r (
              PermanentAbsenceTraits::create (i, f, this));

            this->permanent_absence_.push_back (::std::move (r));
            continue;
          }

          // playing
          //
          if (n.name () == "playing" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< PlayingType > r (
              PlayingTraits::create (i, f, this));

            this->playing_.push_back (::std::move (r));
            continue;
          }

          // presentation
          //
          if (n.name () == "presentation" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< PresentationType > r (
              PresentationTraits::create (i, f, this));

            this->presentation_.push_back (::std::move (r));
            continue;
          }

          // shopping
          //
          if (n.name () == "shopping" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< ShoppingType > r (
              ShoppingTraits::create (i, f, this));

            this->shopping_.push_back (::std::move (r));
            continue;
          }

          // sleeping
          //
          if (n.name () == "sleeping" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< SleepingType > r (
              SleepingTraits::create (i, f, this));

            this->sleeping_.push_back (::std::move (r));
            continue;
          }

          // spectator
          //
          if (n.name () == "spectator" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< SpectatorType > r (
              SpectatorTraits::create (i, f, this));

            this->spectator_.push_back (::std::move (r));
            continue;
          }

          // steering
          //
          if (n.name () == "steering" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< SteeringType > r (
              SteeringTraits::create (i, f, this));

            this->steering_.push_back (::std::move (r));
            continue;
          }

          // travel
          //
          if (n.name () == "travel" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< TravelType > r (
              TravelTraits::create (i, f, this));

            this->travel_.push_back (::std::move (r));
            continue;
          }

          // tv
          //
          if (n.name () == "tv" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< TvType > r (
              TvTraits::create (i, f, this));

            this->tv_.push_back (::std::move (r));
            continue;
          }

          // vacation
          //
          if (n.name () == "vacation" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< VacationType > r (
              VacationTraits::create (i, f, this));

            this->vacation_.push_back (::std::move (r));
            continue;
          }

          // working
          //
          if (n.name () == "working" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< WorkingType > r (
              WorkingTraits::create (i, f, this));

            this->working_.push_back (::std::move (r));
            continue;
          }

          // worship
          //
          if (n.name () == "worship" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< WorshipType > r (
              WorshipTraits::create (i, f, this));

            this->worship_.push_back (::std::move (r));
            continue;
          }

          // other
          //
          if (n.name () == "other" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< OtherType > r (
              OtherTraits::create (i, f, this));

            this->other_.push_back (::std::move (r));
            continue;
          }

          // any
          //
          if ((!n.namespace_ ().empty () && n.namespace_ () != "urn:ietf:params:xml:ns:pidf:rpid"))
          {
            ::xercesc::DOMElement* r (
              static_cast< ::xercesc::DOMElement* > (
                this->getDomDocument ().importNode (
                  const_cast< ::xercesc::DOMElement* > (&i), true)));
            this->any_.push_back (r);
            continue;
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "from" && n.namespace_ ().empty ())
          {
            this->from_.set (FromTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "until" && n.namespace_ ().empty ())
          {
            this->until_.set (UntilTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            this->id_.set (IdTraits::create (i, f, this));
            continue;
          }

          // any_attribute
          //
          if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
               n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
          {
            ::xercesc::DOMAttr* r (
              static_cast< ::xercesc::DOMAttr* > (
                this->getDomDocument ().importNode (
                  const_cast< ::xercesc::DOMAttr* > (&i), true)));
            this->any_attribute_ .insert (r);
            continue;
          }
        }
      }

      Activities* Activities::
      _clone (::flexisip::Xsd::XmlSchema::Flags f,
              ::flexisip::Xsd::XmlSchema::Container* c) const
      {
        return new class Activities (*this, f, c);
      }

      Activities& Activities::
      operator= (const Activities& x)
      {
        if (this != &x)
        {
          static_cast< ::flexisip::Xsd::XmlSchema::Type& > (*this) = x;
          this->note_ = x.note_;
          this->unknown_ = x.unknown_;
          this->appointment_ = x.appointment_;
          this->away_ = x.away_;
          this->breakfast_ = x.breakfast_;
          this->busy_ = x.busy_;
          this->dinner_ = x.dinner_;
          this->holiday_ = x.holiday_;
          this->in_transit_ = x.in_transit_;
          this->looking_for_work_ = x.looking_for_work_;
          this->meal_ = x.meal_;
          this->meeting_ = x.meeting_;
          this->on_the_phone_ = x.on_the_phone_;
          this->performance_ = x.performance_;
          this->permanent_absence_ = x.permanent_absence_;
          this->playing_ = x.playing_;
          this->presentation_ = x.presentation_;
          this->shopping_ = x.shopping_;
          this->sleeping_ = x.sleeping_;
          this->spectator_ = x.spectator_;
          this->steering_ = x.steering_;
          this->travel_ = x.travel_;
          this->tv_ = x.tv_;
          this->vacation_ = x.vacation_;
          this->working_ = x.working_;
          this->worship_ = x.worship_;
          this->other_ = x.other_;
          this->any_ = x.any_;
          this->from_ = x.from_;
          this->until_ = x.until_;
          this->id_ = x.id_;
          this->any_attribute_ = x.any_attribute_;
        }

        return *this;
      }

      Activities::
      ~Activities ()
      {
      }

      // Mood
      //

      Mood::
      Mood ()
      : ::flexisip::Xsd::XmlSchema::Type (),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        note_ (this),
        unknown_ (this),
        afraid_ (this),
        amazed_ (this),
        angry_ (this),
        annoyed_ (this),
        anxious_ (this),
        ashamed_ (this),
        bored_ (this),
        brave_ (this),
        calm_ (this),
        cold_ (this),
        confused_ (this),
        contented_ (this),
        cranky_ (this),
        curious_ (this),
        depressed_ (this),
        disappointed_ (this),
        disgusted_ (this),
        distracted_ (this),
        embarrassed_ (this),
        excited_ (this),
        flirtatious_ (this),
        frustrated_ (this),
        grumpy_ (this),
        guilty_ (this),
        happy_ (this),
        hot_ (this),
        humbled_ (this),
        humiliated_ (this),
        hungry_ (this),
        hurt_ (this),
        impressed_ (this),
        in_awe_ (this),
        in_love_ (this),
        indignant_ (this),
        interested_ (this),
        invincible_ (this),
        jealous_ (this),
        lonely_ (this),
        mean_ (this),
        moody_ (this),
        nervous_ (this),
        neutral_ (this),
        offended_ (this),
        playful_ (this),
        proud_ (this),
        relieved_ (this),
        remorseful_ (this),
        restless_ (this),
        sad_ (this),
        sarcastic_ (this),
        serious_ (this),
        shocked_ (this),
        shy_ (this),
        sick_ (this),
        sleepy_ (this),
        stressed_ (this),
        surprised_ (this),
        thirsty_ (this),
        worried_ (this),
        other_ (this),
        any_ (this->getDomDocument ()),
        from_ (this),
        until_ (this),
        id_ (this),
        any_attribute_ (this->getDomDocument ())
      {
      }

      Mood::
      Mood (const Mood& x,
            ::flexisip::Xsd::XmlSchema::Flags f,
            ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (x, f, c),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        note_ (x.note_, f, this),
        unknown_ (x.unknown_, f, this),
        afraid_ (x.afraid_, f, this),
        amazed_ (x.amazed_, f, this),
        angry_ (x.angry_, f, this),
        annoyed_ (x.annoyed_, f, this),
        anxious_ (x.anxious_, f, this),
        ashamed_ (x.ashamed_, f, this),
        bored_ (x.bored_, f, this),
        brave_ (x.brave_, f, this),
        calm_ (x.calm_, f, this),
        cold_ (x.cold_, f, this),
        confused_ (x.confused_, f, this),
        contented_ (x.contented_, f, this),
        cranky_ (x.cranky_, f, this),
        curious_ (x.curious_, f, this),
        depressed_ (x.depressed_, f, this),
        disappointed_ (x.disappointed_, f, this),
        disgusted_ (x.disgusted_, f, this),
        distracted_ (x.distracted_, f, this),
        embarrassed_ (x.embarrassed_, f, this),
        excited_ (x.excited_, f, this),
        flirtatious_ (x.flirtatious_, f, this),
        frustrated_ (x.frustrated_, f, this),
        grumpy_ (x.grumpy_, f, this),
        guilty_ (x.guilty_, f, this),
        happy_ (x.happy_, f, this),
        hot_ (x.hot_, f, this),
        humbled_ (x.humbled_, f, this),
        humiliated_ (x.humiliated_, f, this),
        hungry_ (x.hungry_, f, this),
        hurt_ (x.hurt_, f, this),
        impressed_ (x.impressed_, f, this),
        in_awe_ (x.in_awe_, f, this),
        in_love_ (x.in_love_, f, this),
        indignant_ (x.indignant_, f, this),
        interested_ (x.interested_, f, this),
        invincible_ (x.invincible_, f, this),
        jealous_ (x.jealous_, f, this),
        lonely_ (x.lonely_, f, this),
        mean_ (x.mean_, f, this),
        moody_ (x.moody_, f, this),
        nervous_ (x.nervous_, f, this),
        neutral_ (x.neutral_, f, this),
        offended_ (x.offended_, f, this),
        playful_ (x.playful_, f, this),
        proud_ (x.proud_, f, this),
        relieved_ (x.relieved_, f, this),
        remorseful_ (x.remorseful_, f, this),
        restless_ (x.restless_, f, this),
        sad_ (x.sad_, f, this),
        sarcastic_ (x.sarcastic_, f, this),
        serious_ (x.serious_, f, this),
        shocked_ (x.shocked_, f, this),
        shy_ (x.shy_, f, this),
        sick_ (x.sick_, f, this),
        sleepy_ (x.sleepy_, f, this),
        stressed_ (x.stressed_, f, this),
        surprised_ (x.surprised_, f, this),
        thirsty_ (x.thirsty_, f, this),
        worried_ (x.worried_, f, this),
        other_ (x.other_, f, this),
        any_ (x.any_, this->getDomDocument ()),
        from_ (x.from_, f, this),
        until_ (x.until_, f, this),
        id_ (x.id_, f, this),
        any_attribute_ (x.any_attribute_, this->getDomDocument ())
      {
      }

      Mood::
      Mood (const ::xercesc::DOMElement& e,
            ::flexisip::Xsd::XmlSchema::Flags f,
            ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (e, f | ::flexisip::Xsd::XmlSchema::Flags::base, c),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        note_ (this),
        unknown_ (this),
        afraid_ (this),
        amazed_ (this),
        angry_ (this),
        annoyed_ (this),
        anxious_ (this),
        ashamed_ (this),
        bored_ (this),
        brave_ (this),
        calm_ (this),
        cold_ (this),
        confused_ (this),
        contented_ (this),
        cranky_ (this),
        curious_ (this),
        depressed_ (this),
        disappointed_ (this),
        disgusted_ (this),
        distracted_ (this),
        embarrassed_ (this),
        excited_ (this),
        flirtatious_ (this),
        frustrated_ (this),
        grumpy_ (this),
        guilty_ (this),
        happy_ (this),
        hot_ (this),
        humbled_ (this),
        humiliated_ (this),
        hungry_ (this),
        hurt_ (this),
        impressed_ (this),
        in_awe_ (this),
        in_love_ (this),
        indignant_ (this),
        interested_ (this),
        invincible_ (this),
        jealous_ (this),
        lonely_ (this),
        mean_ (this),
        moody_ (this),
        nervous_ (this),
        neutral_ (this),
        offended_ (this),
        playful_ (this),
        proud_ (this),
        relieved_ (this),
        remorseful_ (this),
        restless_ (this),
        sad_ (this),
        sarcastic_ (this),
        serious_ (this),
        shocked_ (this),
        shy_ (this),
        sick_ (this),
        sleepy_ (this),
        stressed_ (this),
        surprised_ (this),
        thirsty_ (this),
        worried_ (this),
        other_ (this),
        any_ (this->getDomDocument ()),
        from_ (this),
        until_ (this),
        id_ (this),
        any_attribute_ (this->getDomDocument ())
      {
        if ((f & ::flexisip::Xsd::XmlSchema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void Mood::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // note
          //
          if (n.name () == "note" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< NoteType > r (
              NoteTraits::create (i, f, this));

            this->note_.push_back (::std::move (r));
            continue;
          }

          // unknown
          //
          if (n.name () == "unknown" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< UnknownType > r (
              UnknownTraits::create (i, f, this));

            if (!this->unknown_)
            {
              this->unknown_.set (::std::move (r));
              continue;
            }
          }

          // afraid
          //
          if (n.name () == "afraid" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< AfraidType > r (
              AfraidTraits::create (i, f, this));

            this->afraid_.push_back (::std::move (r));
            continue;
          }

          // amazed
          //
          if (n.name () == "amazed" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< AmazedType > r (
              AmazedTraits::create (i, f, this));

            this->amazed_.push_back (::std::move (r));
            continue;
          }

          // angry
          //
          if (n.name () == "angry" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< AngryType > r (
              AngryTraits::create (i, f, this));

            this->angry_.push_back (::std::move (r));
            continue;
          }

          // annoyed
          //
          if (n.name () == "annoyed" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< AnnoyedType > r (
              AnnoyedTraits::create (i, f, this));

            this->annoyed_.push_back (::std::move (r));
            continue;
          }

          // anxious
          //
          if (n.name () == "anxious" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< AnxiousType > r (
              AnxiousTraits::create (i, f, this));

            this->anxious_.push_back (::std::move (r));
            continue;
          }

          // ashamed
          //
          if (n.name () == "ashamed" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< AshamedType > r (
              AshamedTraits::create (i, f, this));

            this->ashamed_.push_back (::std::move (r));
            continue;
          }

          // bored
          //
          if (n.name () == "bored" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< BoredType > r (
              BoredTraits::create (i, f, this));

            this->bored_.push_back (::std::move (r));
            continue;
          }

          // brave
          //
          if (n.name () == "brave" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< BraveType > r (
              BraveTraits::create (i, f, this));

            this->brave_.push_back (::std::move (r));
            continue;
          }

          // calm
          //
          if (n.name () == "calm" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< CalmType > r (
              CalmTraits::create (i, f, this));

            this->calm_.push_back (::std::move (r));
            continue;
          }

          // cold
          //
          if (n.name () == "cold" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< ColdType > r (
              ColdTraits::create (i, f, this));

            this->cold_.push_back (::std::move (r));
            continue;
          }

          // confused
          //
          if (n.name () == "confused" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< ConfusedType > r (
              ConfusedTraits::create (i, f, this));

            this->confused_.push_back (::std::move (r));
            continue;
          }

          // contented
          //
          if (n.name () == "contented" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< ContentedType > r (
              ContentedTraits::create (i, f, this));

            this->contented_.push_back (::std::move (r));
            continue;
          }

          // cranky
          //
          if (n.name () == "cranky" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< CrankyType > r (
              CrankyTraits::create (i, f, this));

            this->cranky_.push_back (::std::move (r));
            continue;
          }

          // curious
          //
          if (n.name () == "curious" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< CuriousType > r (
              CuriousTraits::create (i, f, this));

            this->curious_.push_back (::std::move (r));
            continue;
          }

          // depressed
          //
          if (n.name () == "depressed" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< DepressedType > r (
              DepressedTraits::create (i, f, this));

            this->depressed_.push_back (::std::move (r));
            continue;
          }

          // disappointed
          //
          if (n.name () == "disappointed" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< DisappointedType > r (
              DisappointedTraits::create (i, f, this));

            this->disappointed_.push_back (::std::move (r));
            continue;
          }

          // disgusted
          //
          if (n.name () == "disgusted" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< DisgustedType > r (
              DisgustedTraits::create (i, f, this));

            this->disgusted_.push_back (::std::move (r));
            continue;
          }

          // distracted
          //
          if (n.name () == "distracted" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< DistractedType > r (
              DistractedTraits::create (i, f, this));

            this->distracted_.push_back (::std::move (r));
            continue;
          }

          // embarrassed
          //
          if (n.name () == "embarrassed" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< EmbarrassedType > r (
              EmbarrassedTraits::create (i, f, this));

            this->embarrassed_.push_back (::std::move (r));
            continue;
          }

          // excited
          //
          if (n.name () == "excited" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< ExcitedType > r (
              ExcitedTraits::create (i, f, this));

            this->excited_.push_back (::std::move (r));
            continue;
          }

          // flirtatious
          //
          if (n.name () == "flirtatious" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< FlirtatiousType > r (
              FlirtatiousTraits::create (i, f, this));

            this->flirtatious_.push_back (::std::move (r));
            continue;
          }

          // frustrated
          //
          if (n.name () == "frustrated" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< FrustratedType > r (
              FrustratedTraits::create (i, f, this));

            this->frustrated_.push_back (::std::move (r));
            continue;
          }

          // grumpy
          //
          if (n.name () == "grumpy" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< GrumpyType > r (
              GrumpyTraits::create (i, f, this));

            this->grumpy_.push_back (::std::move (r));
            continue;
          }

          // guilty
          //
          if (n.name () == "guilty" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< GuiltyType > r (
              GuiltyTraits::create (i, f, this));

            this->guilty_.push_back (::std::move (r));
            continue;
          }

          // happy
          //
          if (n.name () == "happy" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< HappyType > r (
              HappyTraits::create (i, f, this));

            this->happy_.push_back (::std::move (r));
            continue;
          }

          // hot
          //
          if (n.name () == "hot" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< HotType > r (
              HotTraits::create (i, f, this));

            this->hot_.push_back (::std::move (r));
            continue;
          }

          // humbled
          //
          if (n.name () == "humbled" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< HumbledType > r (
              HumbledTraits::create (i, f, this));

            this->humbled_.push_back (::std::move (r));
            continue;
          }

          // humiliated
          //
          if (n.name () == "humiliated" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< HumiliatedType > r (
              HumiliatedTraits::create (i, f, this));

            this->humiliated_.push_back (::std::move (r));
            continue;
          }

          // hungry
          //
          if (n.name () == "hungry" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< HungryType > r (
              HungryTraits::create (i, f, this));

            this->hungry_.push_back (::std::move (r));
            continue;
          }

          // hurt
          //
          if (n.name () == "hurt" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< HurtType > r (
              HurtTraits::create (i, f, this));

            this->hurt_.push_back (::std::move (r));
            continue;
          }

          // impressed
          //
          if (n.name () == "impressed" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< ImpressedType > r (
              ImpressedTraits::create (i, f, this));

            this->impressed_.push_back (::std::move (r));
            continue;
          }

          // in_awe
          //
          if (n.name () == "in_awe" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< In_aweType > r (
              In_aweTraits::create (i, f, this));

            this->in_awe_.push_back (::std::move (r));
            continue;
          }

          // in_love
          //
          if (n.name () == "in_love" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< In_loveType > r (
              In_loveTraits::create (i, f, this));

            this->in_love_.push_back (::std::move (r));
            continue;
          }

          // indignant
          //
          if (n.name () == "indignant" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< IndignantType > r (
              IndignantTraits::create (i, f, this));

            this->indignant_.push_back (::std::move (r));
            continue;
          }

          // interested
          //
          if (n.name () == "interested" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< InterestedType > r (
              InterestedTraits::create (i, f, this));

            this->interested_.push_back (::std::move (r));
            continue;
          }

          // invincible
          //
          if (n.name () == "invincible" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< InvincibleType > r (
              InvincibleTraits::create (i, f, this));

            this->invincible_.push_back (::std::move (r));
            continue;
          }

          // jealous
          //
          if (n.name () == "jealous" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< JealousType > r (
              JealousTraits::create (i, f, this));

            this->jealous_.push_back (::std::move (r));
            continue;
          }

          // lonely
          //
          if (n.name () == "lonely" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< LonelyType > r (
              LonelyTraits::create (i, f, this));

            this->lonely_.push_back (::std::move (r));
            continue;
          }

          // mean
          //
          if (n.name () == "mean" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< MeanType > r (
              MeanTraits::create (i, f, this));

            this->mean_.push_back (::std::move (r));
            continue;
          }

          // moody
          //
          if (n.name () == "moody" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< MoodyType > r (
              MoodyTraits::create (i, f, this));

            this->moody_.push_back (::std::move (r));
            continue;
          }

          // nervous
          //
          if (n.name () == "nervous" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< NervousType > r (
              NervousTraits::create (i, f, this));

            this->nervous_.push_back (::std::move (r));
            continue;
          }

          // neutral
          //
          if (n.name () == "neutral" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< NeutralType > r (
              NeutralTraits::create (i, f, this));

            this->neutral_.push_back (::std::move (r));
            continue;
          }

          // offended
          //
          if (n.name () == "offended" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< OffendedType > r (
              OffendedTraits::create (i, f, this));

            this->offended_.push_back (::std::move (r));
            continue;
          }

          // playful
          //
          if (n.name () == "playful" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< PlayfulType > r (
              PlayfulTraits::create (i, f, this));

            this->playful_.push_back (::std::move (r));
            continue;
          }

          // proud
          //
          if (n.name () == "proud" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< ProudType > r (
              ProudTraits::create (i, f, this));

            this->proud_.push_back (::std::move (r));
            continue;
          }

          // relieved
          //
          if (n.name () == "relieved" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< RelievedType > r (
              RelievedTraits::create (i, f, this));

            this->relieved_.push_back (::std::move (r));
            continue;
          }

          // remorseful
          //
          if (n.name () == "remorseful" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< RemorsefulType > r (
              RemorsefulTraits::create (i, f, this));

            this->remorseful_.push_back (::std::move (r));
            continue;
          }

          // restless
          //
          if (n.name () == "restless" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< RestlessType > r (
              RestlessTraits::create (i, f, this));

            this->restless_.push_back (::std::move (r));
            continue;
          }

          // sad
          //
          if (n.name () == "sad" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< SadType > r (
              SadTraits::create (i, f, this));

            this->sad_.push_back (::std::move (r));
            continue;
          }

          // sarcastic
          //
          if (n.name () == "sarcastic" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< SarcasticType > r (
              SarcasticTraits::create (i, f, this));

            this->sarcastic_.push_back (::std::move (r));
            continue;
          }

          // serious
          //
          if (n.name () == "serious" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< SeriousType > r (
              SeriousTraits::create (i, f, this));

            this->serious_.push_back (::std::move (r));
            continue;
          }

          // shocked
          //
          if (n.name () == "shocked" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< ShockedType > r (
              ShockedTraits::create (i, f, this));

            this->shocked_.push_back (::std::move (r));
            continue;
          }

          // shy
          //
          if (n.name () == "shy" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< ShyType > r (
              ShyTraits::create (i, f, this));

            this->shy_.push_back (::std::move (r));
            continue;
          }

          // sick
          //
          if (n.name () == "sick" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< SickType > r (
              SickTraits::create (i, f, this));

            this->sick_.push_back (::std::move (r));
            continue;
          }

          // sleepy
          //
          if (n.name () == "sleepy" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< SleepyType > r (
              SleepyTraits::create (i, f, this));

            this->sleepy_.push_back (::std::move (r));
            continue;
          }

          // stressed
          //
          if (n.name () == "stressed" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< StressedType > r (
              StressedTraits::create (i, f, this));

            this->stressed_.push_back (::std::move (r));
            continue;
          }

          // surprised
          //
          if (n.name () == "surprised" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< SurprisedType > r (
              SurprisedTraits::create (i, f, this));

            this->surprised_.push_back (::std::move (r));
            continue;
          }

          // thirsty
          //
          if (n.name () == "thirsty" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< ThirstyType > r (
              ThirstyTraits::create (i, f, this));

            this->thirsty_.push_back (::std::move (r));
            continue;
          }

          // worried
          //
          if (n.name () == "worried" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< WorriedType > r (
              WorriedTraits::create (i, f, this));

            this->worried_.push_back (::std::move (r));
            continue;
          }

          // other
          //
          if (n.name () == "other" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< OtherType > r (
              OtherTraits::create (i, f, this));

            this->other_.push_back (::std::move (r));
            continue;
          }

          // any
          //
          if ((!n.namespace_ ().empty () && n.namespace_ () != "urn:ietf:params:xml:ns:pidf:rpid"))
          {
            ::xercesc::DOMElement* r (
              static_cast< ::xercesc::DOMElement* > (
                this->getDomDocument ().importNode (
                  const_cast< ::xercesc::DOMElement* > (&i), true)));
            this->any_.push_back (r);
            continue;
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "from" && n.namespace_ ().empty ())
          {
            this->from_.set (FromTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "until" && n.namespace_ ().empty ())
          {
            this->until_.set (UntilTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            this->id_.set (IdTraits::create (i, f, this));
            continue;
          }

          // any_attribute
          //
          if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
               n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
          {
            ::xercesc::DOMAttr* r (
              static_cast< ::xercesc::DOMAttr* > (
                this->getDomDocument ().importNode (
                  const_cast< ::xercesc::DOMAttr* > (&i), true)));
            this->any_attribute_ .insert (r);
            continue;
          }
        }
      }

      Mood* Mood::
      _clone (::flexisip::Xsd::XmlSchema::Flags f,
              ::flexisip::Xsd::XmlSchema::Container* c) const
      {
        return new class Mood (*this, f, c);
      }

      Mood& Mood::
      operator= (const Mood& x)
      {
        if (this != &x)
        {
          static_cast< ::flexisip::Xsd::XmlSchema::Type& > (*this) = x;
          this->note_ = x.note_;
          this->unknown_ = x.unknown_;
          this->afraid_ = x.afraid_;
          this->amazed_ = x.amazed_;
          this->angry_ = x.angry_;
          this->annoyed_ = x.annoyed_;
          this->anxious_ = x.anxious_;
          this->ashamed_ = x.ashamed_;
          this->bored_ = x.bored_;
          this->brave_ = x.brave_;
          this->calm_ = x.calm_;
          this->cold_ = x.cold_;
          this->confused_ = x.confused_;
          this->contented_ = x.contented_;
          this->cranky_ = x.cranky_;
          this->curious_ = x.curious_;
          this->depressed_ = x.depressed_;
          this->disappointed_ = x.disappointed_;
          this->disgusted_ = x.disgusted_;
          this->distracted_ = x.distracted_;
          this->embarrassed_ = x.embarrassed_;
          this->excited_ = x.excited_;
          this->flirtatious_ = x.flirtatious_;
          this->frustrated_ = x.frustrated_;
          this->grumpy_ = x.grumpy_;
          this->guilty_ = x.guilty_;
          this->happy_ = x.happy_;
          this->hot_ = x.hot_;
          this->humbled_ = x.humbled_;
          this->humiliated_ = x.humiliated_;
          this->hungry_ = x.hungry_;
          this->hurt_ = x.hurt_;
          this->impressed_ = x.impressed_;
          this->in_awe_ = x.in_awe_;
          this->in_love_ = x.in_love_;
          this->indignant_ = x.indignant_;
          this->interested_ = x.interested_;
          this->invincible_ = x.invincible_;
          this->jealous_ = x.jealous_;
          this->lonely_ = x.lonely_;
          this->mean_ = x.mean_;
          this->moody_ = x.moody_;
          this->nervous_ = x.nervous_;
          this->neutral_ = x.neutral_;
          this->offended_ = x.offended_;
          this->playful_ = x.playful_;
          this->proud_ = x.proud_;
          this->relieved_ = x.relieved_;
          this->remorseful_ = x.remorseful_;
          this->restless_ = x.restless_;
          this->sad_ = x.sad_;
          this->sarcastic_ = x.sarcastic_;
          this->serious_ = x.serious_;
          this->shocked_ = x.shocked_;
          this->shy_ = x.shy_;
          this->sick_ = x.sick_;
          this->sleepy_ = x.sleepy_;
          this->stressed_ = x.stressed_;
          this->surprised_ = x.surprised_;
          this->thirsty_ = x.thirsty_;
          this->worried_ = x.worried_;
          this->other_ = x.other_;
          this->any_ = x.any_;
          this->from_ = x.from_;
          this->until_ = x.until_;
          this->id_ = x.id_;
          this->any_attribute_ = x.any_attribute_;
        }

        return *this;
      }

      Mood::
      ~Mood ()
      {
      }

      // PlaceIs
      //

      PlaceIs::
      PlaceIs ()
      : ::flexisip::Xsd::XmlSchema::Type (),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        note_ (this),
        audio_ (this),
        video_ (this),
        text_ (this),
        from_ (this),
        until_ (this),
        id_ (this),
        any_attribute_ (this->getDomDocument ())
      {
      }

      PlaceIs::
      PlaceIs (const PlaceIs& x,
               ::flexisip::Xsd::XmlSchema::Flags f,
               ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (x, f, c),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        note_ (x.note_, f, this),
        audio_ (x.audio_, f, this),
        video_ (x.video_, f, this),
        text_ (x.text_, f, this),
        from_ (x.from_, f, this),
        until_ (x.until_, f, this),
        id_ (x.id_, f, this),
        any_attribute_ (x.any_attribute_, this->getDomDocument ())
      {
      }

      PlaceIs::
      PlaceIs (const ::xercesc::DOMElement& e,
               ::flexisip::Xsd::XmlSchema::Flags f,
               ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (e, f | ::flexisip::Xsd::XmlSchema::Flags::base, c),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        note_ (this),
        audio_ (this),
        video_ (this),
        text_ (this),
        from_ (this),
        until_ (this),
        id_ (this),
        any_attribute_ (this->getDomDocument ())
      {
        if ((f & ::flexisip::Xsd::XmlSchema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void PlaceIs::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // note
          //
          if (n.name () == "note" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< NoteType > r (
              NoteTraits::create (i, f, this));

            this->note_.push_back (::std::move (r));
            continue;
          }

          // audio
          //
          if (n.name () == "audio" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< AudioType > r (
              AudioTraits::create (i, f, this));

            if (!this->audio_)
            {
              this->audio_.set (::std::move (r));
              continue;
            }
          }

          // video
          //
          if (n.name () == "video" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< VideoType > r (
              VideoTraits::create (i, f, this));

            if (!this->video_)
            {
              this->video_.set (::std::move (r));
              continue;
            }
          }

          // text
          //
          if (n.name () == "text" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< TextType > r (
              TextTraits::create (i, f, this));

            if (!this->text_)
            {
              this->text_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "from" && n.namespace_ ().empty ())
          {
            this->from_.set (FromTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "until" && n.namespace_ ().empty ())
          {
            this->until_.set (UntilTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            this->id_.set (IdTraits::create (i, f, this));
            continue;
          }

          // any_attribute
          //
          if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
               n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
          {
            ::xercesc::DOMAttr* r (
              static_cast< ::xercesc::DOMAttr* > (
                this->getDomDocument ().importNode (
                  const_cast< ::xercesc::DOMAttr* > (&i), true)));
            this->any_attribute_ .insert (r);
            continue;
          }
        }
      }

      PlaceIs* PlaceIs::
      _clone (::flexisip::Xsd::XmlSchema::Flags f,
              ::flexisip::Xsd::XmlSchema::Container* c) const
      {
        return new class PlaceIs (*this, f, c);
      }

      PlaceIs& PlaceIs::
      operator= (const PlaceIs& x)
      {
        if (this != &x)
        {
          static_cast< ::flexisip::Xsd::XmlSchema::Type& > (*this) = x;
          this->note_ = x.note_;
          this->audio_ = x.audio_;
          this->video_ = x.video_;
          this->text_ = x.text_;
          this->from_ = x.from_;
          this->until_ = x.until_;
          this->id_ = x.id_;
          this->any_attribute_ = x.any_attribute_;
        }

        return *this;
      }

      PlaceIs::
      ~PlaceIs ()
      {
      }

      // PlaceType
      //

      PlaceType::
      PlaceType ()
      : ::flexisip::Xsd::XmlSchema::Type (),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        note_ (this),
        other_ (this),
        any_ (this->getDomDocument ()),
        from_ (this),
        until_ (this),
        id_ (this),
        any_attribute_ (this->getDomDocument ())
      {
      }

      PlaceType::
      PlaceType (const PlaceType& x,
                 ::flexisip::Xsd::XmlSchema::Flags f,
                 ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (x, f, c),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        note_ (x.note_, f, this),
        other_ (x.other_, f, this),
        any_ (x.any_, this->getDomDocument ()),
        from_ (x.from_, f, this),
        until_ (x.until_, f, this),
        id_ (x.id_, f, this),
        any_attribute_ (x.any_attribute_, this->getDomDocument ())
      {
      }

      PlaceType::
      PlaceType (const ::xercesc::DOMElement& e,
                 ::flexisip::Xsd::XmlSchema::Flags f,
                 ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (e, f | ::flexisip::Xsd::XmlSchema::Flags::base, c),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        note_ (this),
        other_ (this),
        any_ (this->getDomDocument ()),
        from_ (this),
        until_ (this),
        id_ (this),
        any_attribute_ (this->getDomDocument ())
      {
        if ((f & ::flexisip::Xsd::XmlSchema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void PlaceType::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // note
          //
          if (n.name () == "note" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< NoteType > r (
              NoteTraits::create (i, f, this));

            this->note_.push_back (::std::move (r));
            continue;
          }

          // other
          //
          if (n.name () == "other" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< OtherType > r (
              OtherTraits::create (i, f, this));

            if (!this->other_)
            {
              this->other_.set (::std::move (r));
              continue;
            }
          }

          // any
          //
          if ((!n.namespace_ ().empty () && n.namespace_ () != "urn:ietf:params:xml:ns:pidf:rpid"))
          {
            ::xercesc::DOMElement* r (
              static_cast< ::xercesc::DOMElement* > (
                this->getDomDocument ().importNode (
                  const_cast< ::xercesc::DOMElement* > (&i), true)));
            this->any_.push_back (r);
            continue;
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "from" && n.namespace_ ().empty ())
          {
            this->from_.set (FromTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "until" && n.namespace_ ().empty ())
          {
            this->until_.set (UntilTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            this->id_.set (IdTraits::create (i, f, this));
            continue;
          }

          // any_attribute
          //
          if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
               n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
          {
            ::xercesc::DOMAttr* r (
              static_cast< ::xercesc::DOMAttr* > (
                this->getDomDocument ().importNode (
                  const_cast< ::xercesc::DOMAttr* > (&i), true)));
            this->any_attribute_ .insert (r);
            continue;
          }
        }
      }

      PlaceType* PlaceType::
      _clone (::flexisip::Xsd::XmlSchema::Flags f,
              ::flexisip::Xsd::XmlSchema::Container* c) const
      {
        return new class PlaceType (*this, f, c);
      }

      PlaceType& PlaceType::
      operator= (const PlaceType& x)
      {
        if (this != &x)
        {
          static_cast< ::flexisip::Xsd::XmlSchema::Type& > (*this) = x;
          this->note_ = x.note_;
          this->other_ = x.other_;
          this->any_ = x.any_;
          this->from_ = x.from_;
          this->until_ = x.until_;
          this->id_ = x.id_;
          this->any_attribute_ = x.any_attribute_;
        }

        return *this;
      }

      PlaceType::
      ~PlaceType ()
      {
      }

      // Privacy
      //

      Privacy::
      Privacy ()
      : ::flexisip::Xsd::XmlSchema::Type (),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        note_ (this),
        unknown_ (this),
        audio_ (this),
        text_ (this),
        video_ (this),
        any_ (this->getDomDocument ()),
        from_ (this),
        until_ (this),
        id_ (this),
        any_attribute_ (this->getDomDocument ())
      {
      }

      Privacy::
      Privacy (const Privacy& x,
               ::flexisip::Xsd::XmlSchema::Flags f,
               ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (x, f, c),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        note_ (x.note_, f, this),
        unknown_ (x.unknown_, f, this),
        audio_ (x.audio_, f, this),
        text_ (x.text_, f, this),
        video_ (x.video_, f, this),
        any_ (x.any_, this->getDomDocument ()),
        from_ (x.from_, f, this),
        until_ (x.until_, f, this),
        id_ (x.id_, f, this),
        any_attribute_ (x.any_attribute_, this->getDomDocument ())
      {
      }

      Privacy::
      Privacy (const ::xercesc::DOMElement& e,
               ::flexisip::Xsd::XmlSchema::Flags f,
               ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (e, f | ::flexisip::Xsd::XmlSchema::Flags::base, c),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        note_ (this),
        unknown_ (this),
        audio_ (this),
        text_ (this),
        video_ (this),
        any_ (this->getDomDocument ()),
        from_ (this),
        until_ (this),
        id_ (this),
        any_attribute_ (this->getDomDocument ())
      {
        if ((f & ::flexisip::Xsd::XmlSchema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void Privacy::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // note
          //
          if (n.name () == "note" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< NoteType > r (
              NoteTraits::create (i, f, this));

            this->note_.push_back (::std::move (r));
            continue;
          }

          // unknown
          //
          if (n.name () == "unknown" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< UnknownType > r (
              UnknownTraits::create (i, f, this));

            if (!this->unknown_)
            {
              this->unknown_.set (::std::move (r));
              continue;
            }
          }

          // audio
          //
          if (n.name () == "audio" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< AudioType > r (
              AudioTraits::create (i, f, this));

            if (!this->audio_)
            {
              this->audio_.set (::std::move (r));
              continue;
            }
          }

          // text
          //
          if (n.name () == "text" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< TextType > r (
              TextTraits::create (i, f, this));

            if (!this->text_)
            {
              this->text_.set (::std::move (r));
              continue;
            }
          }

          // video
          //
          if (n.name () == "video" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< VideoType > r (
              VideoTraits::create (i, f, this));

            if (!this->video_)
            {
              this->video_.set (::std::move (r));
              continue;
            }
          }

          // any
          //
          if ((!n.namespace_ ().empty () && n.namespace_ () != "urn:ietf:params:xml:ns:pidf:rpid"))
          {
            ::xercesc::DOMElement* r (
              static_cast< ::xercesc::DOMElement* > (
                this->getDomDocument ().importNode (
                  const_cast< ::xercesc::DOMElement* > (&i), true)));
            this->any_.push_back (r);
            continue;
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "from" && n.namespace_ ().empty ())
          {
            this->from_.set (FromTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "until" && n.namespace_ ().empty ())
          {
            this->until_.set (UntilTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            this->id_.set (IdTraits::create (i, f, this));
            continue;
          }

          // any_attribute
          //
          if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
               n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
          {
            ::xercesc::DOMAttr* r (
              static_cast< ::xercesc::DOMAttr* > (
                this->getDomDocument ().importNode (
                  const_cast< ::xercesc::DOMAttr* > (&i), true)));
            this->any_attribute_ .insert (r);
            continue;
          }
        }
      }

      Privacy* Privacy::
      _clone (::flexisip::Xsd::XmlSchema::Flags f,
              ::flexisip::Xsd::XmlSchema::Container* c) const
      {
        return new class Privacy (*this, f, c);
      }

      Privacy& Privacy::
      operator= (const Privacy& x)
      {
        if (this != &x)
        {
          static_cast< ::flexisip::Xsd::XmlSchema::Type& > (*this) = x;
          this->note_ = x.note_;
          this->unknown_ = x.unknown_;
          this->audio_ = x.audio_;
          this->text_ = x.text_;
          this->video_ = x.video_;
          this->any_ = x.any_;
          this->from_ = x.from_;
          this->until_ = x.until_;
          this->id_ = x.id_;
          this->any_attribute_ = x.any_attribute_;
        }

        return *this;
      }

      Privacy::
      ~Privacy ()
      {
      }

      // Relationship
      //

      Relationship::
      Relationship ()
      : ::flexisip::Xsd::XmlSchema::Type (),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        note_ (this),
        assistant_ (this),
        associate_ (this),
        family_ (this),
        friend__ (this),
        other_ (this),
        self_ (this),
        supervisor_ (this),
        unknown_ (this),
        any_ (this->getDomDocument ())
      {
      }

      Relationship::
      Relationship (const Relationship& x,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (x, f, c),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        note_ (x.note_, f, this),
        assistant_ (x.assistant_, f, this),
        associate_ (x.associate_, f, this),
        family_ (x.family_, f, this),
        friend__ (x.friend__, f, this),
        other_ (x.other_, f, this),
        self_ (x.self_, f, this),
        supervisor_ (x.supervisor_, f, this),
        unknown_ (x.unknown_, f, this),
        any_ (x.any_, this->getDomDocument ())
      {
      }

      Relationship::
      Relationship (const ::xercesc::DOMElement& e,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (e, f | ::flexisip::Xsd::XmlSchema::Flags::base, c),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        note_ (this),
        assistant_ (this),
        associate_ (this),
        family_ (this),
        friend__ (this),
        other_ (this),
        self_ (this),
        supervisor_ (this),
        unknown_ (this),
        any_ (this->getDomDocument ())
      {
        if ((f & ::flexisip::Xsd::XmlSchema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void Relationship::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // note
          //
          if (n.name () == "note" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< NoteType > r (
              NoteTraits::create (i, f, this));

            this->note_.push_back (::std::move (r));
            continue;
          }

          // assistant
          //
          if (n.name () == "assistant" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< AssistantType > r (
              AssistantTraits::create (i, f, this));

            if (!this->assistant_)
            {
              this->assistant_.set (::std::move (r));
              continue;
            }
          }

          // associate
          //
          if (n.name () == "associate" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< AssociateType > r (
              AssociateTraits::create (i, f, this));

            if (!this->associate_)
            {
              this->associate_.set (::std::move (r));
              continue;
            }
          }

          // family
          //
          if (n.name () == "family" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< FamilyType > r (
              FamilyTraits::create (i, f, this));

            if (!this->family_)
            {
              this->family_.set (::std::move (r));
              continue;
            }
          }

          // friend
          //
          if (n.name () == "friend" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< FriendType > r (
              FriendTraits::create (i, f, this));

            if (!this->friend__)
            {
              this->friend__.set (::std::move (r));
              continue;
            }
          }

          // other
          //
          if (n.name () == "other" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< OtherType > r (
              OtherTraits::create (i, f, this));

            if (!this->other_)
            {
              this->other_.set (::std::move (r));
              continue;
            }
          }

          // self
          //
          if (n.name () == "self" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< SelfType > r (
              SelfTraits::create (i, f, this));

            if (!this->self_)
            {
              this->self_.set (::std::move (r));
              continue;
            }
          }

          // supervisor
          //
          if (n.name () == "supervisor" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< SupervisorType > r (
              SupervisorTraits::create (i, f, this));

            if (!this->supervisor_)
            {
              this->supervisor_.set (::std::move (r));
              continue;
            }
          }

          // unknown
          //
          if (n.name () == "unknown" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< UnknownType > r (
              UnknownTraits::create (i, f, this));

            if (!this->unknown_)
            {
              this->unknown_.set (::std::move (r));
              continue;
            }
          }

          // any
          //
          if ((!n.namespace_ ().empty () && n.namespace_ () != "urn:ietf:params:xml:ns:pidf:rpid"))
          {
            ::xercesc::DOMElement* r (
              static_cast< ::xercesc::DOMElement* > (
                this->getDomDocument ().importNode (
                  const_cast< ::xercesc::DOMElement* > (&i), true)));
            this->any_.push_back (r);
            continue;
          }

          break;
        }
      }

      Relationship* Relationship::
      _clone (::flexisip::Xsd::XmlSchema::Flags f,
              ::flexisip::Xsd::XmlSchema::Container* c) const
      {
        return new class Relationship (*this, f, c);
      }

      Relationship& Relationship::
      operator= (const Relationship& x)
      {
        if (this != &x)
        {
          static_cast< ::flexisip::Xsd::XmlSchema::Type& > (*this) = x;
          this->note_ = x.note_;
          this->assistant_ = x.assistant_;
          this->associate_ = x.associate_;
          this->family_ = x.family_;
          this->friend__ = x.friend__;
          this->other_ = x.other_;
          this->self_ = x.self_;
          this->supervisor_ = x.supervisor_;
          this->unknown_ = x.unknown_;
          this->any_ = x.any_;
        }

        return *this;
      }

      Relationship::
      ~Relationship ()
      {
      }

      // ServiceClass
      //

      ServiceClass::
      ServiceClass ()
      : ::flexisip::Xsd::XmlSchema::Type (),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        note_ (this),
        courier_ (this),
        electronic_ (this),
        freight_ (this),
        in_person_ (this),
        postal_ (this),
        unknown_ (this),
        any_ (this->getDomDocument ())
      {
      }

      ServiceClass::
      ServiceClass (const ServiceClass& x,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (x, f, c),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        note_ (x.note_, f, this),
        courier_ (x.courier_, f, this),
        electronic_ (x.electronic_, f, this),
        freight_ (x.freight_, f, this),
        in_person_ (x.in_person_, f, this),
        postal_ (x.postal_, f, this),
        unknown_ (x.unknown_, f, this),
        any_ (x.any_, this->getDomDocument ())
      {
      }

      ServiceClass::
      ServiceClass (const ::xercesc::DOMElement& e,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (e, f | ::flexisip::Xsd::XmlSchema::Flags::base, c),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        note_ (this),
        courier_ (this),
        electronic_ (this),
        freight_ (this),
        in_person_ (this),
        postal_ (this),
        unknown_ (this),
        any_ (this->getDomDocument ())
      {
        if ((f & ::flexisip::Xsd::XmlSchema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void ServiceClass::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // note
          //
          if (n.name () == "note" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< NoteType > r (
              NoteTraits::create (i, f, this));

            this->note_.push_back (::std::move (r));
            continue;
          }

          // courier
          //
          if (n.name () == "courier" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< CourierType > r (
              CourierTraits::create (i, f, this));

            if (!this->courier_)
            {
              this->courier_.set (::std::move (r));
              continue;
            }
          }

          // electronic
          //
          if (n.name () == "electronic" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< ElectronicType > r (
              ElectronicTraits::create (i, f, this));

            if (!this->electronic_)
            {
              this->electronic_.set (::std::move (r));
              continue;
            }
          }

          // freight
          //
          if (n.name () == "freight" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< FreightType > r (
              FreightTraits::create (i, f, this));

            if (!this->freight_)
            {
              this->freight_.set (::std::move (r));
              continue;
            }
          }

          // in-person
          //
          if (n.name () == "in-person" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< InPersonType > r (
              InPersonTraits::create (i, f, this));

            if (!this->in_person_)
            {
              this->in_person_.set (::std::move (r));
              continue;
            }
          }

          // postal
          //
          if (n.name () == "postal" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< PostalType > r (
              PostalTraits::create (i, f, this));

            if (!this->postal_)
            {
              this->postal_.set (::std::move (r));
              continue;
            }
          }

          // unknown
          //
          if (n.name () == "unknown" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< UnknownType > r (
              UnknownTraits::create (i, f, this));

            if (!this->unknown_)
            {
              this->unknown_.set (::std::move (r));
              continue;
            }
          }

          // any
          //
          if ((!n.namespace_ ().empty () && n.namespace_ () != "urn:ietf:params:xml:ns:pidf:rpid"))
          {
            ::xercesc::DOMElement* r (
              static_cast< ::xercesc::DOMElement* > (
                this->getDomDocument ().importNode (
                  const_cast< ::xercesc::DOMElement* > (&i), true)));
            this->any_.push_back (r);
            continue;
          }

          break;
        }
      }

      ServiceClass* ServiceClass::
      _clone (::flexisip::Xsd::XmlSchema::Flags f,
              ::flexisip::Xsd::XmlSchema::Container* c) const
      {
        return new class ServiceClass (*this, f, c);
      }

      ServiceClass& ServiceClass::
      operator= (const ServiceClass& x)
      {
        if (this != &x)
        {
          static_cast< ::flexisip::Xsd::XmlSchema::Type& > (*this) = x;
          this->note_ = x.note_;
          this->courier_ = x.courier_;
          this->electronic_ = x.electronic_;
          this->freight_ = x.freight_;
          this->in_person_ = x.in_person_;
          this->postal_ = x.postal_;
          this->unknown_ = x.unknown_;
          this->any_ = x.any_;
        }

        return *this;
      }

      ServiceClass::
      ~ServiceClass ()
      {
      }

      // Sphere
      //

      Sphere::
      Sphere ()
      : ::flexisip::Xsd::XmlSchema::Type (),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        home_ (this),
        work_ (this),
        unknown_ (this),
        any_ (this->getDomDocument ()),
        from_ (this),
        until_ (this),
        id_ (this),
        any_attribute_ (this->getDomDocument ())
      {
      }

      Sphere::
      Sphere (const Sphere& x,
              ::flexisip::Xsd::XmlSchema::Flags f,
              ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (x, f, c),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        home_ (x.home_, f, this),
        work_ (x.work_, f, this),
        unknown_ (x.unknown_, f, this),
        any_ (x.any_, this->getDomDocument ()),
        from_ (x.from_, f, this),
        until_ (x.until_, f, this),
        id_ (x.id_, f, this),
        any_attribute_ (x.any_attribute_, this->getDomDocument ())
      {
      }

      Sphere::
      Sphere (const ::xercesc::DOMElement& e,
              ::flexisip::Xsd::XmlSchema::Flags f,
              ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (e, f | ::flexisip::Xsd::XmlSchema::Flags::base, c),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        home_ (this),
        work_ (this),
        unknown_ (this),
        any_ (this->getDomDocument ()),
        from_ (this),
        until_ (this),
        id_ (this),
        any_attribute_ (this->getDomDocument ())
      {
        if ((f & ::flexisip::Xsd::XmlSchema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void Sphere::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // home
          //
          if (n.name () == "home" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< HomeType > r (
              HomeTraits::create (i, f, this));

            if (!this->home_)
            {
              this->home_.set (::std::move (r));
              continue;
            }
          }

          // work
          //
          if (n.name () == "work" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< WorkType > r (
              WorkTraits::create (i, f, this));

            if (!this->work_)
            {
              this->work_.set (::std::move (r));
              continue;
            }
          }

          // unknown
          //
          if (n.name () == "unknown" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< UnknownType > r (
              UnknownTraits::create (i, f, this));

            if (!this->unknown_)
            {
              this->unknown_.set (::std::move (r));
              continue;
            }
          }

          // any
          //
          if ((!n.namespace_ ().empty () && n.namespace_ () != "urn:ietf:params:xml:ns:pidf:rpid"))
          {
            ::xercesc::DOMElement* r (
              static_cast< ::xercesc::DOMElement* > (
                this->getDomDocument ().importNode (
                  const_cast< ::xercesc::DOMElement* > (&i), true)));
            this->any_.push_back (r);
            continue;
          }

          break;
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "from" && n.namespace_ ().empty ())
          {
            this->from_.set (FromTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "until" && n.namespace_ ().empty ())
          {
            this->until_.set (UntilTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            this->id_.set (IdTraits::create (i, f, this));
            continue;
          }

          // any_attribute
          //
          if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
               n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
          {
            ::xercesc::DOMAttr* r (
              static_cast< ::xercesc::DOMAttr* > (
                this->getDomDocument ().importNode (
                  const_cast< ::xercesc::DOMAttr* > (&i), true)));
            this->any_attribute_ .insert (r);
            continue;
          }
        }
      }

      Sphere* Sphere::
      _clone (::flexisip::Xsd::XmlSchema::Flags f,
              ::flexisip::Xsd::XmlSchema::Container* c) const
      {
        return new class Sphere (*this, f, c);
      }

      Sphere& Sphere::
      operator= (const Sphere& x)
      {
        if (this != &x)
        {
          static_cast< ::flexisip::Xsd::XmlSchema::Type& > (*this) = x;
          this->home_ = x.home_;
          this->work_ = x.work_;
          this->unknown_ = x.unknown_;
          this->any_ = x.any_;
          this->from_ = x.from_;
          this->until_ = x.until_;
          this->id_ = x.id_;
          this->any_attribute_ = x.any_attribute_;
        }

        return *this;
      }

      Sphere::
      ~Sphere ()
      {
      }

      // StatusIcon
      //

      StatusIcon::
      StatusIcon (const ::flexisip::Xsd::XmlSchema::Uri& _xsd_Uri_base)
      : ::flexisip::Xsd::XmlSchema::Uri (_xsd_Uri_base),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        from_ (this),
        until_ (this),
        id_ (this),
        any_attribute_ (this->getDomDocument ())
      {
      }

      StatusIcon::
      StatusIcon (const StatusIcon& x,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Uri (x, f, c),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        from_ (x.from_, f, this),
        until_ (x.until_, f, this),
        id_ (x.id_, f, this),
        any_attribute_ (x.any_attribute_, this->getDomDocument ())
      {
      }

      StatusIcon::
      StatusIcon (const ::xercesc::DOMElement& e,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Uri (e, f | ::flexisip::Xsd::XmlSchema::Flags::base, c),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        from_ (this),
        until_ (this),
        id_ (this),
        any_attribute_ (this->getDomDocument ())
      {
        if ((f & ::flexisip::Xsd::XmlSchema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void StatusIcon::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "from" && n.namespace_ ().empty ())
          {
            this->from_.set (FromTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "until" && n.namespace_ ().empty ())
          {
            this->until_.set (UntilTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            this->id_.set (IdTraits::create (i, f, this));
            continue;
          }

          // any_attribute
          //
          if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
               n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
          {
            ::xercesc::DOMAttr* r (
              static_cast< ::xercesc::DOMAttr* > (
                this->getDomDocument ().importNode (
                  const_cast< ::xercesc::DOMAttr* > (&i), true)));
            this->any_attribute_ .insert (r);
            continue;
          }
        }
      }

      StatusIcon* StatusIcon::
      _clone (::flexisip::Xsd::XmlSchema::Flags f,
              ::flexisip::Xsd::XmlSchema::Container* c) const
      {
        return new class StatusIcon (*this, f, c);
      }

      StatusIcon& StatusIcon::
      operator= (const StatusIcon& x)
      {
        if (this != &x)
        {
          static_cast< ::flexisip::Xsd::XmlSchema::Uri& > (*this) = x;
          this->from_ = x.from_;
          this->until_ = x.until_;
          this->id_ = x.id_;
          this->any_attribute_ = x.any_attribute_;
        }

        return *this;
      }

      StatusIcon::
      ~StatusIcon ()
      {
      }

      // TimeOffset
      //

      TimeOffset::
      TimeOffset (const ::flexisip::Xsd::XmlSchema::Integer& _xsd_Integer_base)
      : ::xsd::cxx::tree::fundamental_base< ::flexisip::Xsd::XmlSchema::Integer, char, ::flexisip::Xsd::XmlSchema::SimpleType > (_xsd_Integer_base),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        from_ (this),
        until_ (this),
        description_ (this),
        id_ (this),
        any_attribute_ (this->getDomDocument ())
      {
      }

      TimeOffset::
      TimeOffset (const TimeOffset& x,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  ::flexisip::Xsd::XmlSchema::Container* c)
      : ::xsd::cxx::tree::fundamental_base< ::flexisip::Xsd::XmlSchema::Integer, char, ::flexisip::Xsd::XmlSchema::SimpleType > (x, f, c),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        from_ (x.from_, f, this),
        until_ (x.until_, f, this),
        description_ (x.description_, f, this),
        id_ (x.id_, f, this),
        any_attribute_ (x.any_attribute_, this->getDomDocument ())
      {
      }

      TimeOffset::
      TimeOffset (const ::xercesc::DOMElement& e,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  ::flexisip::Xsd::XmlSchema::Container* c)
      : ::xsd::cxx::tree::fundamental_base< ::flexisip::Xsd::XmlSchema::Integer, char, ::flexisip::Xsd::XmlSchema::SimpleType > (e, f | ::flexisip::Xsd::XmlSchema::Flags::base, c),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        from_ (this),
        until_ (this),
        description_ (this),
        id_ (this),
        any_attribute_ (this->getDomDocument ())
      {
        if ((f & ::flexisip::Xsd::XmlSchema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void TimeOffset::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "from" && n.namespace_ ().empty ())
          {
            this->from_.set (FromTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "until" && n.namespace_ ().empty ())
          {
            this->until_.set (UntilTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "description" && n.namespace_ ().empty ())
          {
            this->description_.set (DescriptionTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            this->id_.set (IdTraits::create (i, f, this));
            continue;
          }

          // any_attribute
          //
          if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
               n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
          {
            ::xercesc::DOMAttr* r (
              static_cast< ::xercesc::DOMAttr* > (
                this->getDomDocument ().importNode (
                  const_cast< ::xercesc::DOMAttr* > (&i), true)));
            this->any_attribute_ .insert (r);
            continue;
          }
        }
      }

      TimeOffset* TimeOffset::
      _clone (::flexisip::Xsd::XmlSchema::Flags f,
              ::flexisip::Xsd::XmlSchema::Container* c) const
      {
        return new class TimeOffset (*this, f, c);
      }

      TimeOffset& TimeOffset::
      operator= (const TimeOffset& x)
      {
        if (this != &x)
        {
          static_cast< ::xsd::cxx::tree::fundamental_base< ::flexisip::Xsd::XmlSchema::Integer, char, ::flexisip::Xsd::XmlSchema::SimpleType >& > (*this) = x;
          this->from_ = x.from_;
          this->until_ = x.until_;
          this->description_ = x.description_;
          this->id_ = x.id_;
          this->any_attribute_ = x.any_attribute_;
        }

        return *this;
      }

      TimeOffset::
      ~TimeOffset ()
      {
      }

      // UserInput
      //

      UserInput::
      UserInput (::flexisip::Xsd::Rpid::ActiveIdle::Value _xsd_ActiveIdle_base)
      : ::flexisip::Xsd::Rpid::ActiveIdle (_xsd_ActiveIdle_base),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        idle_threshold_ (this),
        last_input_ (this),
        id_ (this),
        any_attribute_ (this->getDomDocument ())
      {
      }

      UserInput::
      UserInput (const char* _xsd_String_base)
      : ::flexisip::Xsd::Rpid::ActiveIdle (_xsd_String_base),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        idle_threshold_ (this),
        last_input_ (this),
        id_ (this),
        any_attribute_ (this->getDomDocument ())
      {
      }

      UserInput::
      UserInput (const ::std::string& _xsd_String_base)
      : ::flexisip::Xsd::Rpid::ActiveIdle (_xsd_String_base),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        idle_threshold_ (this),
        last_input_ (this),
        id_ (this),
        any_attribute_ (this->getDomDocument ())
      {
      }

      UserInput::
      UserInput (const ::flexisip::Xsd::Rpid::ActiveIdle& _xsd_ActiveIdle_base)
      : ::flexisip::Xsd::Rpid::ActiveIdle (_xsd_ActiveIdle_base),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        idle_threshold_ (this),
        last_input_ (this),
        id_ (this),
        any_attribute_ (this->getDomDocument ())
      {
      }

      UserInput::
      UserInput (const UserInput& x,
                 ::flexisip::Xsd::XmlSchema::Flags f,
                 ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::Rpid::ActiveIdle (x, f, c),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        idle_threshold_ (x.idle_threshold_, f, this),
        last_input_ (x.last_input_, f, this),
        id_ (x.id_, f, this),
        any_attribute_ (x.any_attribute_, this->getDomDocument ())
      {
      }

      UserInput::
      UserInput (const ::xercesc::DOMElement& e,
                 ::flexisip::Xsd::XmlSchema::Flags f,
                 ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::Rpid::ActiveIdle (e, f | ::flexisip::Xsd::XmlSchema::Flags::base, c),
        dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
        idle_threshold_ (this),
        last_input_ (this),
        id_ (this),
        any_attribute_ (this->getDomDocument ())
      {
        if ((f & ::flexisip::Xsd::XmlSchema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void UserInput::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "idle-threshold" && n.namespace_ ().empty ())
          {
            this->idle_threshold_.set (IdleThresholdTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "last-input" && n.namespace_ ().empty ())
          {
            this->last_input_.set (LastInputTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            this->id_.set (IdTraits::create (i, f, this));
            continue;
          }

          // any_attribute
          //
          if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< char > () &&
               n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< char > ()))
          {
            ::xercesc::DOMAttr* r (
              static_cast< ::xercesc::DOMAttr* > (
                this->getDomDocument ().importNode (
                  const_cast< ::xercesc::DOMAttr* > (&i), true)));
            this->any_attribute_ .insert (r);
            continue;
          }
        }
      }

      UserInput* UserInput::
      _clone (::flexisip::Xsd::XmlSchema::Flags f,
              ::flexisip::Xsd::XmlSchema::Container* c) const
      {
        return new class UserInput (*this, f, c);
      }

      UserInput& UserInput::
      operator= (const UserInput& x)
      {
        if (this != &x)
        {
          static_cast< ::flexisip::Xsd::Rpid::ActiveIdle& > (*this) = x;
          this->idle_threshold_ = x.idle_threshold_;
          this->last_input_ = x.last_input_;
          this->id_ = x.id_;
          this->any_attribute_ = x.any_attribute_;
        }

        return *this;
      }

      UserInput::
      ~UserInput ()
      {
      }

      // Audio
      //

      Audio::
      Audio ()
      : ::flexisip::Xsd::XmlSchema::Type (),
        noisy_ (this),
        ok_ (this),
        quiet_ (this),
        unknown_ (this)
      {
      }

      Audio::
      Audio (const Audio& x,
             ::flexisip::Xsd::XmlSchema::Flags f,
             ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (x, f, c),
        noisy_ (x.noisy_, f, this),
        ok_ (x.ok_, f, this),
        quiet_ (x.quiet_, f, this),
        unknown_ (x.unknown_, f, this)
      {
      }

      Audio::
      Audio (const ::xercesc::DOMElement& e,
             ::flexisip::Xsd::XmlSchema::Flags f,
             ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (e, f | ::flexisip::Xsd::XmlSchema::Flags::base, c),
        noisy_ (this),
        ok_ (this),
        quiet_ (this),
        unknown_ (this)
      {
        if ((f & ::flexisip::Xsd::XmlSchema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void Audio::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // noisy
          //
          if (n.name () == "noisy" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< NoisyType > r (
              NoisyTraits::create (i, f, this));

            if (!this->noisy_)
            {
              this->noisy_.set (::std::move (r));
              continue;
            }
          }

          // ok
          //
          if (n.name () == "ok" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< OkType > r (
              OkTraits::create (i, f, this));

            if (!this->ok_)
            {
              this->ok_.set (::std::move (r));
              continue;
            }
          }

          // quiet
          //
          if (n.name () == "quiet" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< QuietType > r (
              QuietTraits::create (i, f, this));

            if (!this->quiet_)
            {
              this->quiet_.set (::std::move (r));
              continue;
            }
          }

          // unknown
          //
          if (n.name () == "unknown" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< UnknownType > r (
              UnknownTraits::create (i, f, this));

            if (!this->unknown_)
            {
              this->unknown_.set (::std::move (r));
              continue;
            }
          }

          break;
        }
      }

      Audio* Audio::
      _clone (::flexisip::Xsd::XmlSchema::Flags f,
              ::flexisip::Xsd::XmlSchema::Container* c) const
      {
        return new class Audio (*this, f, c);
      }

      Audio& Audio::
      operator= (const Audio& x)
      {
        if (this != &x)
        {
          static_cast< ::flexisip::Xsd::XmlSchema::Type& > (*this) = x;
          this->noisy_ = x.noisy_;
          this->ok_ = x.ok_;
          this->quiet_ = x.quiet_;
          this->unknown_ = x.unknown_;
        }

        return *this;
      }

      Audio::
      ~Audio ()
      {
      }

      // Video
      //

      Video::
      Video ()
      : ::flexisip::Xsd::XmlSchema::Type (),
        toobright_ (this),
        ok_ (this),
        dark_ (this),
        unknown_ (this)
      {
      }

      Video::
      Video (const Video& x,
             ::flexisip::Xsd::XmlSchema::Flags f,
             ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (x, f, c),
        toobright_ (x.toobright_, f, this),
        ok_ (x.ok_, f, this),
        dark_ (x.dark_, f, this),
        unknown_ (x.unknown_, f, this)
      {
      }

      Video::
      Video (const ::xercesc::DOMElement& e,
             ::flexisip::Xsd::XmlSchema::Flags f,
             ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (e, f | ::flexisip::Xsd::XmlSchema::Flags::base, c),
        toobright_ (this),
        ok_ (this),
        dark_ (this),
        unknown_ (this)
      {
        if ((f & ::flexisip::Xsd::XmlSchema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void Video::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // toobright
          //
          if (n.name () == "toobright" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< ToobrightType > r (
              ToobrightTraits::create (i, f, this));

            if (!this->toobright_)
            {
              this->toobright_.set (::std::move (r));
              continue;
            }
          }

          // ok
          //
          if (n.name () == "ok" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< OkType > r (
              OkTraits::create (i, f, this));

            if (!this->ok_)
            {
              this->ok_.set (::std::move (r));
              continue;
            }
          }

          // dark
          //
          if (n.name () == "dark" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< DarkType > r (
              DarkTraits::create (i, f, this));

            if (!this->dark_)
            {
              this->dark_.set (::std::move (r));
              continue;
            }
          }

          // unknown
          //
          if (n.name () == "unknown" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< UnknownType > r (
              UnknownTraits::create (i, f, this));

            if (!this->unknown_)
            {
              this->unknown_.set (::std::move (r));
              continue;
            }
          }

          break;
        }
      }

      Video* Video::
      _clone (::flexisip::Xsd::XmlSchema::Flags f,
              ::flexisip::Xsd::XmlSchema::Container* c) const
      {
        return new class Video (*this, f, c);
      }

      Video& Video::
      operator= (const Video& x)
      {
        if (this != &x)
        {
          static_cast< ::flexisip::Xsd::XmlSchema::Type& > (*this) = x;
          this->toobright_ = x.toobright_;
          this->ok_ = x.ok_;
          this->dark_ = x.dark_;
          this->unknown_ = x.unknown_;
        }

        return *this;
      }

      Video::
      ~Video ()
      {
      }

      // Text
      //

      Text::
      Text ()
      : ::flexisip::Xsd::XmlSchema::Type (),
        uncomfortable_ (this),
        inappropriate_ (this),
        ok_ (this),
        unknown_ (this)
      {
      }

      Text::
      Text (const Text& x,
            ::flexisip::Xsd::XmlSchema::Flags f,
            ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (x, f, c),
        uncomfortable_ (x.uncomfortable_, f, this),
        inappropriate_ (x.inappropriate_, f, this),
        ok_ (x.ok_, f, this),
        unknown_ (x.unknown_, f, this)
      {
      }

      Text::
      Text (const ::xercesc::DOMElement& e,
            ::flexisip::Xsd::XmlSchema::Flags f,
            ::flexisip::Xsd::XmlSchema::Container* c)
      : ::flexisip::Xsd::XmlSchema::Type (e, f | ::flexisip::Xsd::XmlSchema::Flags::base, c),
        uncomfortable_ (this),
        inappropriate_ (this),
        ok_ (this),
        unknown_ (this)
      {
        if ((f & ::flexisip::Xsd::XmlSchema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void Text::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // uncomfortable
          //
          if (n.name () == "uncomfortable" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< UncomfortableType > r (
              UncomfortableTraits::create (i, f, this));

            if (!this->uncomfortable_)
            {
              this->uncomfortable_.set (::std::move (r));
              continue;
            }
          }

          // inappropriate
          //
          if (n.name () == "inappropriate" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< InappropriateType > r (
              InappropriateTraits::create (i, f, this));

            if (!this->inappropriate_)
            {
              this->inappropriate_.set (::std::move (r));
              continue;
            }
          }

          // ok
          //
          if (n.name () == "ok" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< OkType > r (
              OkTraits::create (i, f, this));

            if (!this->ok_)
            {
              this->ok_.set (::std::move (r));
              continue;
            }
          }

          // unknown
          //
          if (n.name () == "unknown" && n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
          {
            ::std::unique_ptr< UnknownType > r (
              UnknownTraits::create (i, f, this));

            if (!this->unknown_)
            {
              this->unknown_.set (::std::move (r));
              continue;
            }
          }

          break;
        }
      }

      Text* Text::
      _clone (::flexisip::Xsd::XmlSchema::Flags f,
              ::flexisip::Xsd::XmlSchema::Container* c) const
      {
        return new class Text (*this, f, c);
      }

      Text& Text::
      operator= (const Text& x)
      {
        if (this != &x)
        {
          static_cast< ::flexisip::Xsd::XmlSchema::Type& > (*this) = x;
          this->uncomfortable_ = x.uncomfortable_;
          this->inappropriate_ = x.inappropriate_;
          this->ok_ = x.ok_;
          this->unknown_ = x.unknown_;
        }

        return *this;
      }

      Text::
      ~Text ()
      {
      }
    }
  }
}

#include <ostream>

namespace flexisip
{
  namespace Xsd
  {
    namespace Rpid
    {
      ::std::ostream&
      operator<< (::std::ostream& o, const Timestamp_t& i)
      {
        o << static_cast< const ::flexisip::Xsd::XmlSchema::DateTime& > (i);

        return o;
      }

      ::std::ostream&
      operator<< (::std::ostream& o, const DeviceID_t& i)
      {
        o << static_cast< const ::flexisip::Xsd::XmlSchema::Uri& > (i);

        return o;
      }

      ::std::ostream&
      operator<< (::std::ostream& o, const Note_t& i)
      {
        o << static_cast< const ::flexisip::Xsd::XmlSchema::String& > (i);

        if (i.getLang ())
        {
          o << ::std::endl << "lang: " << *i.getLang ();
        }

        return o;
      }

      ::std::ostream&
      operator<< (::std::ostream& o, const Empty&)
      {
        return o;
      }
    }
  }
}

namespace flexisip
{
  namespace Xsd
  {
    namespace Rpid
    {
      ::std::ostream&
      operator<< (::std::ostream& o, ActiveIdle::Value i)
      {
        return o << ActiveIdle::_xsd_ActiveIdle_literals_[i];
      }

      ::std::ostream&
      operator<< (::std::ostream& o, const ActiveIdle& i)
      {
        return o << static_cast< const ::flexisip::Xsd::XmlSchema::String& > (i);
      }

      ::std::ostream&
      operator<< (::std::ostream& o, const Activities& i)
      {
        for (Activities::NoteConstIterator
             b (i.getNote ().begin ()), e (i.getNote ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "note: " << *b;
        }

        if (i.getUnknown ())
        {
          o << ::std::endl << "unknown: " << *i.getUnknown ();
        }

        for (Activities::AppointmentConstIterator
             b (i.getAppointment ().begin ()), e (i.getAppointment ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "appointment: " << *b;
        }

        for (Activities::AwayConstIterator
             b (i.getAway ().begin ()), e (i.getAway ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "away: " << *b;
        }

        for (Activities::BreakfastConstIterator
             b (i.getBreakfast ().begin ()), e (i.getBreakfast ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "breakfast: " << *b;
        }

        for (Activities::BusyConstIterator
             b (i.getBusy ().begin ()), e (i.getBusy ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "busy: " << *b;
        }

        for (Activities::DinnerConstIterator
             b (i.getDinner ().begin ()), e (i.getDinner ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "dinner: " << *b;
        }

        for (Activities::HolidayConstIterator
             b (i.getHoliday ().begin ()), e (i.getHoliday ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "holiday: " << *b;
        }

        for (Activities::InTransitConstIterator
             b (i.getInTransit ().begin ()), e (i.getInTransit ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "in-transit: " << *b;
        }

        for (Activities::LookingForWorkConstIterator
             b (i.getLookingForWork ().begin ()), e (i.getLookingForWork ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "looking-for-work: " << *b;
        }

        for (Activities::MealConstIterator
             b (i.getMeal ().begin ()), e (i.getMeal ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "meal: " << *b;
        }

        for (Activities::MeetingConstIterator
             b (i.getMeeting ().begin ()), e (i.getMeeting ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "meeting: " << *b;
        }

        for (Activities::OnThePhoneConstIterator
             b (i.getOnThePhone ().begin ()), e (i.getOnThePhone ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "on-the-phone: " << *b;
        }

        for (Activities::PerformanceConstIterator
             b (i.getPerformance ().begin ()), e (i.getPerformance ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "performance: " << *b;
        }

        for (Activities::PermanentAbsenceConstIterator
             b (i.getPermanentAbsence ().begin ()), e (i.getPermanentAbsence ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "permanent-absence: " << *b;
        }

        for (Activities::PlayingConstIterator
             b (i.getPlaying ().begin ()), e (i.getPlaying ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "playing: " << *b;
        }

        for (Activities::PresentationConstIterator
             b (i.getPresentation ().begin ()), e (i.getPresentation ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "presentation: " << *b;
        }

        for (Activities::ShoppingConstIterator
             b (i.getShopping ().begin ()), e (i.getShopping ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "shopping: " << *b;
        }

        for (Activities::SleepingConstIterator
             b (i.getSleeping ().begin ()), e (i.getSleeping ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "sleeping: " << *b;
        }

        for (Activities::SpectatorConstIterator
             b (i.getSpectator ().begin ()), e (i.getSpectator ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "spectator: " << *b;
        }

        for (Activities::SteeringConstIterator
             b (i.getSteering ().begin ()), e (i.getSteering ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "steering: " << *b;
        }

        for (Activities::TravelConstIterator
             b (i.getTravel ().begin ()), e (i.getTravel ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "travel: " << *b;
        }

        for (Activities::TvConstIterator
             b (i.getTv ().begin ()), e (i.getTv ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "tv: " << *b;
        }

        for (Activities::VacationConstIterator
             b (i.getVacation ().begin ()), e (i.getVacation ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "vacation: " << *b;
        }

        for (Activities::WorkingConstIterator
             b (i.getWorking ().begin ()), e (i.getWorking ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "working: " << *b;
        }

        for (Activities::WorshipConstIterator
             b (i.getWorship ().begin ()), e (i.getWorship ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "worship: " << *b;
        }

        for (Activities::OtherConstIterator
             b (i.getOther ().begin ()), e (i.getOther ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "other: " << *b;
        }

        if (i.getFrom ())
        {
          o << ::std::endl << "from: " << *i.getFrom ();
        }

        if (i.getUntil ())
        {
          o << ::std::endl << "until: " << *i.getUntil ();
        }

        if (i.getId ())
        {
          o << ::std::endl << "id: " << *i.getId ();
        }

        return o;
      }

      ::std::ostream&
      operator<< (::std::ostream& o, const Mood& i)
      {
        for (Mood::NoteConstIterator
             b (i.getNote ().begin ()), e (i.getNote ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "note: " << *b;
        }

        if (i.getUnknown ())
        {
          o << ::std::endl << "unknown: " << *i.getUnknown ();
        }

        for (Mood::AfraidConstIterator
             b (i.getAfraid ().begin ()), e (i.getAfraid ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "afraid: " << *b;
        }

        for (Mood::AmazedConstIterator
             b (i.getAmazed ().begin ()), e (i.getAmazed ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "amazed: " << *b;
        }

        for (Mood::AngryConstIterator
             b (i.getAngry ().begin ()), e (i.getAngry ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "angry: " << *b;
        }

        for (Mood::AnnoyedConstIterator
             b (i.getAnnoyed ().begin ()), e (i.getAnnoyed ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "annoyed: " << *b;
        }

        for (Mood::AnxiousConstIterator
             b (i.getAnxious ().begin ()), e (i.getAnxious ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "anxious: " << *b;
        }

        for (Mood::AshamedConstIterator
             b (i.getAshamed ().begin ()), e (i.getAshamed ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "ashamed: " << *b;
        }

        for (Mood::BoredConstIterator
             b (i.getBored ().begin ()), e (i.getBored ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "bored: " << *b;
        }

        for (Mood::BraveConstIterator
             b (i.getBrave ().begin ()), e (i.getBrave ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "brave: " << *b;
        }

        for (Mood::CalmConstIterator
             b (i.getCalm ().begin ()), e (i.getCalm ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "calm: " << *b;
        }

        for (Mood::ColdConstIterator
             b (i.getCold ().begin ()), e (i.getCold ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "cold: " << *b;
        }

        for (Mood::ConfusedConstIterator
             b (i.getConfused ().begin ()), e (i.getConfused ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "confused: " << *b;
        }

        for (Mood::ContentedConstIterator
             b (i.getContented ().begin ()), e (i.getContented ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "contented: " << *b;
        }

        for (Mood::CrankyConstIterator
             b (i.getCranky ().begin ()), e (i.getCranky ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "cranky: " << *b;
        }

        for (Mood::CuriousConstIterator
             b (i.getCurious ().begin ()), e (i.getCurious ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "curious: " << *b;
        }

        for (Mood::DepressedConstIterator
             b (i.getDepressed ().begin ()), e (i.getDepressed ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "depressed: " << *b;
        }

        for (Mood::DisappointedConstIterator
             b (i.getDisappointed ().begin ()), e (i.getDisappointed ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "disappointed: " << *b;
        }

        for (Mood::DisgustedConstIterator
             b (i.getDisgusted ().begin ()), e (i.getDisgusted ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "disgusted: " << *b;
        }

        for (Mood::DistractedConstIterator
             b (i.getDistracted ().begin ()), e (i.getDistracted ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "distracted: " << *b;
        }

        for (Mood::EmbarrassedConstIterator
             b (i.getEmbarrassed ().begin ()), e (i.getEmbarrassed ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "embarrassed: " << *b;
        }

        for (Mood::ExcitedConstIterator
             b (i.getExcited ().begin ()), e (i.getExcited ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "excited: " << *b;
        }

        for (Mood::FlirtatiousConstIterator
             b (i.getFlirtatious ().begin ()), e (i.getFlirtatious ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "flirtatious: " << *b;
        }

        for (Mood::FrustratedConstIterator
             b (i.getFrustrated ().begin ()), e (i.getFrustrated ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "frustrated: " << *b;
        }

        for (Mood::GrumpyConstIterator
             b (i.getGrumpy ().begin ()), e (i.getGrumpy ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "grumpy: " << *b;
        }

        for (Mood::GuiltyConstIterator
             b (i.getGuilty ().begin ()), e (i.getGuilty ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "guilty: " << *b;
        }

        for (Mood::HappyConstIterator
             b (i.getHappy ().begin ()), e (i.getHappy ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "happy: " << *b;
        }

        for (Mood::HotConstIterator
             b (i.getHot ().begin ()), e (i.getHot ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "hot: " << *b;
        }

        for (Mood::HumbledConstIterator
             b (i.getHumbled ().begin ()), e (i.getHumbled ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "humbled: " << *b;
        }

        for (Mood::HumiliatedConstIterator
             b (i.getHumiliated ().begin ()), e (i.getHumiliated ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "humiliated: " << *b;
        }

        for (Mood::HungryConstIterator
             b (i.getHungry ().begin ()), e (i.getHungry ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "hungry: " << *b;
        }

        for (Mood::HurtConstIterator
             b (i.getHurt ().begin ()), e (i.getHurt ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "hurt: " << *b;
        }

        for (Mood::ImpressedConstIterator
             b (i.getImpressed ().begin ()), e (i.getImpressed ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "impressed: " << *b;
        }

        for (Mood::In_aweConstIterator
             b (i.getIn_awe ().begin ()), e (i.getIn_awe ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "in_awe: " << *b;
        }

        for (Mood::In_loveConstIterator
             b (i.getIn_love ().begin ()), e (i.getIn_love ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "in_love: " << *b;
        }

        for (Mood::IndignantConstIterator
             b (i.getIndignant ().begin ()), e (i.getIndignant ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "indignant: " << *b;
        }

        for (Mood::InterestedConstIterator
             b (i.getInterested ().begin ()), e (i.getInterested ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "interested: " << *b;
        }

        for (Mood::InvincibleConstIterator
             b (i.getInvincible ().begin ()), e (i.getInvincible ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "invincible: " << *b;
        }

        for (Mood::JealousConstIterator
             b (i.getJealous ().begin ()), e (i.getJealous ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "jealous: " << *b;
        }

        for (Mood::LonelyConstIterator
             b (i.getLonely ().begin ()), e (i.getLonely ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "lonely: " << *b;
        }

        for (Mood::MeanConstIterator
             b (i.getMean ().begin ()), e (i.getMean ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "mean: " << *b;
        }

        for (Mood::MoodyConstIterator
             b (i.getMoody ().begin ()), e (i.getMoody ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "moody: " << *b;
        }

        for (Mood::NervousConstIterator
             b (i.getNervous ().begin ()), e (i.getNervous ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "nervous: " << *b;
        }

        for (Mood::NeutralConstIterator
             b (i.getNeutral ().begin ()), e (i.getNeutral ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "neutral: " << *b;
        }

        for (Mood::OffendedConstIterator
             b (i.getOffended ().begin ()), e (i.getOffended ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "offended: " << *b;
        }

        for (Mood::PlayfulConstIterator
             b (i.getPlayful ().begin ()), e (i.getPlayful ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "playful: " << *b;
        }

        for (Mood::ProudConstIterator
             b (i.getProud ().begin ()), e (i.getProud ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "proud: " << *b;
        }

        for (Mood::RelievedConstIterator
             b (i.getRelieved ().begin ()), e (i.getRelieved ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "relieved: " << *b;
        }

        for (Mood::RemorsefulConstIterator
             b (i.getRemorseful ().begin ()), e (i.getRemorseful ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "remorseful: " << *b;
        }

        for (Mood::RestlessConstIterator
             b (i.getRestless ().begin ()), e (i.getRestless ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "restless: " << *b;
        }

        for (Mood::SadConstIterator
             b (i.getSad ().begin ()), e (i.getSad ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "sad: " << *b;
        }

        for (Mood::SarcasticConstIterator
             b (i.getSarcastic ().begin ()), e (i.getSarcastic ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "sarcastic: " << *b;
        }

        for (Mood::SeriousConstIterator
             b (i.getSerious ().begin ()), e (i.getSerious ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "serious: " << *b;
        }

        for (Mood::ShockedConstIterator
             b (i.getShocked ().begin ()), e (i.getShocked ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "shocked: " << *b;
        }

        for (Mood::ShyConstIterator
             b (i.getShy ().begin ()), e (i.getShy ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "shy: " << *b;
        }

        for (Mood::SickConstIterator
             b (i.getSick ().begin ()), e (i.getSick ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "sick: " << *b;
        }

        for (Mood::SleepyConstIterator
             b (i.getSleepy ().begin ()), e (i.getSleepy ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "sleepy: " << *b;
        }

        for (Mood::StressedConstIterator
             b (i.getStressed ().begin ()), e (i.getStressed ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "stressed: " << *b;
        }

        for (Mood::SurprisedConstIterator
             b (i.getSurprised ().begin ()), e (i.getSurprised ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "surprised: " << *b;
        }

        for (Mood::ThirstyConstIterator
             b (i.getThirsty ().begin ()), e (i.getThirsty ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "thirsty: " << *b;
        }

        for (Mood::WorriedConstIterator
             b (i.getWorried ().begin ()), e (i.getWorried ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "worried: " << *b;
        }

        for (Mood::OtherConstIterator
             b (i.getOther ().begin ()), e (i.getOther ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "other: " << *b;
        }

        if (i.getFrom ())
        {
          o << ::std::endl << "from: " << *i.getFrom ();
        }

        if (i.getUntil ())
        {
          o << ::std::endl << "until: " << *i.getUntil ();
        }

        if (i.getId ())
        {
          o << ::std::endl << "id: " << *i.getId ();
        }

        return o;
      }

      ::std::ostream&
      operator<< (::std::ostream& o, const PlaceIs& i)
      {
        for (PlaceIs::NoteConstIterator
             b (i.getNote ().begin ()), e (i.getNote ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "note: " << *b;
        }

        if (i.getAudio ())
        {
          o << ::std::endl << "audio: " << *i.getAudio ();
        }

        if (i.getVideo ())
        {
          o << ::std::endl << "video: " << *i.getVideo ();
        }

        if (i.getText ())
        {
          o << ::std::endl << "text: " << *i.getText ();
        }

        if (i.getFrom ())
        {
          o << ::std::endl << "from: " << *i.getFrom ();
        }

        if (i.getUntil ())
        {
          o << ::std::endl << "until: " << *i.getUntil ();
        }

        if (i.getId ())
        {
          o << ::std::endl << "id: " << *i.getId ();
        }

        return o;
      }

      ::std::ostream&
      operator<< (::std::ostream& o, const PlaceType& i)
      {
        for (PlaceType::NoteConstIterator
             b (i.getNote ().begin ()), e (i.getNote ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "note: " << *b;
        }

        if (i.getOther ())
        {
          o << ::std::endl << "other: " << *i.getOther ();
        }

        if (i.getFrom ())
        {
          o << ::std::endl << "from: " << *i.getFrom ();
        }

        if (i.getUntil ())
        {
          o << ::std::endl << "until: " << *i.getUntil ();
        }

        if (i.getId ())
        {
          o << ::std::endl << "id: " << *i.getId ();
        }

        return o;
      }

      ::std::ostream&
      operator<< (::std::ostream& o, const Privacy& i)
      {
        for (Privacy::NoteConstIterator
             b (i.getNote ().begin ()), e (i.getNote ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "note: " << *b;
        }

        if (i.getUnknown ())
        {
          o << ::std::endl << "unknown: " << *i.getUnknown ();
        }

        if (i.getAudio ())
        {
          o << ::std::endl << "audio: " << *i.getAudio ();
        }

        if (i.getText ())
        {
          o << ::std::endl << "text: " << *i.getText ();
        }

        if (i.getVideo ())
        {
          o << ::std::endl << "video: " << *i.getVideo ();
        }

        if (i.getFrom ())
        {
          o << ::std::endl << "from: " << *i.getFrom ();
        }

        if (i.getUntil ())
        {
          o << ::std::endl << "until: " << *i.getUntil ();
        }

        if (i.getId ())
        {
          o << ::std::endl << "id: " << *i.getId ();
        }

        return o;
      }

      ::std::ostream&
      operator<< (::std::ostream& o, const Relationship& i)
      {
        for (Relationship::NoteConstIterator
             b (i.getNote ().begin ()), e (i.getNote ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "note: " << *b;
        }

        if (i.getAssistant ())
        {
          o << ::std::endl << "assistant: " << *i.getAssistant ();
        }

        if (i.getAssociate ())
        {
          o << ::std::endl << "associate: " << *i.getAssociate ();
        }

        if (i.getFamily ())
        {
          o << ::std::endl << "family: " << *i.getFamily ();
        }

        if (i.getFriend ())
        {
          o << ::std::endl << "friend: " << *i.getFriend ();
        }

        if (i.getOther ())
        {
          o << ::std::endl << "other: " << *i.getOther ();
        }

        if (i.getSelf ())
        {
          o << ::std::endl << "self: " << *i.getSelf ();
        }

        if (i.getSupervisor ())
        {
          o << ::std::endl << "supervisor: " << *i.getSupervisor ();
        }

        if (i.getUnknown ())
        {
          o << ::std::endl << "unknown: " << *i.getUnknown ();
        }

        return o;
      }

      ::std::ostream&
      operator<< (::std::ostream& o, const ServiceClass& i)
      {
        for (ServiceClass::NoteConstIterator
             b (i.getNote ().begin ()), e (i.getNote ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "note: " << *b;
        }

        if (i.getCourier ())
        {
          o << ::std::endl << "courier: " << *i.getCourier ();
        }

        if (i.getElectronic ())
        {
          o << ::std::endl << "electronic: " << *i.getElectronic ();
        }

        if (i.getFreight ())
        {
          o << ::std::endl << "freight: " << *i.getFreight ();
        }

        if (i.getInPerson ())
        {
          o << ::std::endl << "in-person: " << *i.getInPerson ();
        }

        if (i.getPostal ())
        {
          o << ::std::endl << "postal: " << *i.getPostal ();
        }

        if (i.getUnknown ())
        {
          o << ::std::endl << "unknown: " << *i.getUnknown ();
        }

        return o;
      }

      ::std::ostream&
      operator<< (::std::ostream& o, const Sphere& i)
      {
        if (i.getHome ())
        {
          o << ::std::endl << "home: " << *i.getHome ();
        }

        if (i.getWork ())
        {
          o << ::std::endl << "work: " << *i.getWork ();
        }

        if (i.getUnknown ())
        {
          o << ::std::endl << "unknown: " << *i.getUnknown ();
        }

        if (i.getFrom ())
        {
          o << ::std::endl << "from: " << *i.getFrom ();
        }

        if (i.getUntil ())
        {
          o << ::std::endl << "until: " << *i.getUntil ();
        }

        if (i.getId ())
        {
          o << ::std::endl << "id: " << *i.getId ();
        }

        return o;
      }

      ::std::ostream&
      operator<< (::std::ostream& o, const StatusIcon& i)
      {
        o << static_cast< const ::flexisip::Xsd::XmlSchema::Uri& > (i);

        if (i.getFrom ())
        {
          o << ::std::endl << "from: " << *i.getFrom ();
        }

        if (i.getUntil ())
        {
          o << ::std::endl << "until: " << *i.getUntil ();
        }

        if (i.getId ())
        {
          o << ::std::endl << "id: " << *i.getId ();
        }

        return o;
      }

      ::std::ostream&
      operator<< (::std::ostream& o, const TimeOffset& i)
      {
        o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::flexisip::Xsd::XmlSchema::Integer, char, ::flexisip::Xsd::XmlSchema::SimpleType >& > (i);

        if (i.getFrom ())
        {
          o << ::std::endl << "from: " << *i.getFrom ();
        }

        if (i.getUntil ())
        {
          o << ::std::endl << "until: " << *i.getUntil ();
        }

        if (i.getDescription ())
        {
          o << ::std::endl << "description: " << *i.getDescription ();
        }

        if (i.getId ())
        {
          o << ::std::endl << "id: " << *i.getId ();
        }

        return o;
      }

      ::std::ostream&
      operator<< (::std::ostream& o, const UserInput& i)
      {
        o << static_cast< const ::flexisip::Xsd::Rpid::ActiveIdle& > (i);

        if (i.getIdleThreshold ())
        {
          o << ::std::endl << "idle-threshold: " << *i.getIdleThreshold ();
        }

        if (i.getLastInput ())
        {
          o << ::std::endl << "last-input: " << *i.getLastInput ();
        }

        if (i.getId ())
        {
          o << ::std::endl << "id: " << *i.getId ();
        }

        return o;
      }

      ::std::ostream&
      operator<< (::std::ostream& o, const Audio& i)
      {
        if (i.getNoisy ())
        {
          o << ::std::endl << "noisy: " << *i.getNoisy ();
        }

        if (i.getOk ())
        {
          o << ::std::endl << "ok: " << *i.getOk ();
        }

        if (i.getQuiet ())
        {
          o << ::std::endl << "quiet: " << *i.getQuiet ();
        }

        if (i.getUnknown ())
        {
          o << ::std::endl << "unknown: " << *i.getUnknown ();
        }

        return o;
      }

      ::std::ostream&
      operator<< (::std::ostream& o, const Video& i)
      {
        if (i.getToobright ())
        {
          o << ::std::endl << "toobright: " << *i.getToobright ();
        }

        if (i.getOk ())
        {
          o << ::std::endl << "ok: " << *i.getOk ();
        }

        if (i.getDark ())
        {
          o << ::std::endl << "dark: " << *i.getDark ();
        }

        if (i.getUnknown ())
        {
          o << ::std::endl << "unknown: " << *i.getUnknown ();
        }

        return o;
      }

      ::std::ostream&
      operator<< (::std::ostream& o, const Text& i)
      {
        if (i.getUncomfortable ())
        {
          o << ::std::endl << "uncomfortable: " << *i.getUncomfortable ();
        }

        if (i.getInappropriate ())
        {
          o << ::std::endl << "inappropriate: " << *i.getInappropriate ();
        }

        if (i.getOk ())
        {
          o << ::std::endl << "ok: " << *i.getOk ();
        }

        if (i.getUnknown ())
        {
          o << ::std::endl << "unknown: " << *i.getUnknown ();
        }

        return o;
      }
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace flexisip
{
  namespace Xsd
  {
    namespace Rpid
    {
    }
  }
}

namespace flexisip
{
  namespace Xsd
  {
    namespace Rpid
    {
      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Activities >
      parseActivities (const ::std::string& u,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::tree::error_handler< char > h;

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Activities > (
          ::flexisip::Xsd::Rpid::parseActivities (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Activities >
      parseActivities (const ::std::string& u,
                       ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Activities > (
          ::flexisip::Xsd::Rpid::parseActivities (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Activities >
      parseActivities (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Activities > (
          ::flexisip::Xsd::Rpid::parseActivities (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Activities >
      parseActivities (::std::istream& is,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseActivities (isrc, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Activities >
      parseActivities (::std::istream& is,
                       ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseActivities (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Activities >
      parseActivities (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseActivities (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Activities >
      parseActivities (::std::istream& is,
                       const ::std::string& sid,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseActivities (isrc, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Activities >
      parseActivities (::std::istream& is,
                       const ::std::string& sid,
                       ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseActivities (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Activities >
      parseActivities (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseActivities (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Activities >
      parseActivities (::xercesc::InputSource& i,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::tree::error_handler< char > h;

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Activities > (
          ::flexisip::Xsd::Rpid::parseActivities (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Activities >
      parseActivities (::xercesc::InputSource& i,
                       ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Activities > (
          ::flexisip::Xsd::Rpid::parseActivities (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Activities >
      parseActivities (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Activities > (
          ::flexisip::Xsd::Rpid::parseActivities (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Activities >
      parseActivities (const ::xercesc::DOMDocument& doc,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        if (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom)
        {
          ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

          return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Activities > (
            ::flexisip::Xsd::Rpid::parseActivities (
              std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
        }

        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "activities" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ::flexisip::Xsd::Rpid::Activities > r (
            ::xsd::cxx::tree::traits< ::flexisip::Xsd::Rpid::Activities, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "activities",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Activities >
      parseActivities (::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties&)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
          ((f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) &&
           !(f & ::flexisip::Xsd::XmlSchema::Flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
          : 0);

        ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom)
          doc.setUserData (::flexisip::Xsd::XmlSchema::dom::treeNodeKey,
                           (c.get () ? &c : &d),
                           0);

        if (n.name () == "activities" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ::flexisip::Xsd::Rpid::Activities > r (
            ::xsd::cxx::tree::traits< ::flexisip::Xsd::Rpid::Activities, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "activities",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }

      ::std::unique_ptr< ::flexisip::Xsd::XmlSchema::Token >
      parseClass (const ::std::string& u,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::tree::error_handler< char > h;

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::flexisip::Xsd::XmlSchema::Token > (
          ::flexisip::Xsd::Rpid::parseClass (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::XmlSchema::Token >
      parseClass (const ::std::string& u,
                  ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::XmlSchema::Token > (
          ::flexisip::Xsd::Rpid::parseClass (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::XmlSchema::Token >
      parseClass (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::XmlSchema::Token > (
          ::flexisip::Xsd::Rpid::parseClass (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::XmlSchema::Token >
      parseClass (::std::istream& is,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseClass (isrc, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::XmlSchema::Token >
      parseClass (::std::istream& is,
                  ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseClass (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::XmlSchema::Token >
      parseClass (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseClass (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::XmlSchema::Token >
      parseClass (::std::istream& is,
                  const ::std::string& sid,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseClass (isrc, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::XmlSchema::Token >
      parseClass (::std::istream& is,
                  const ::std::string& sid,
                  ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseClass (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::XmlSchema::Token >
      parseClass (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseClass (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::XmlSchema::Token >
      parseClass (::xercesc::InputSource& i,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::tree::error_handler< char > h;

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::flexisip::Xsd::XmlSchema::Token > (
          ::flexisip::Xsd::Rpid::parseClass (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::XmlSchema::Token >
      parseClass (::xercesc::InputSource& i,
                  ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::XmlSchema::Token > (
          ::flexisip::Xsd::Rpid::parseClass (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::XmlSchema::Token >
      parseClass (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::XmlSchema::Token > (
          ::flexisip::Xsd::Rpid::parseClass (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::XmlSchema::Token >
      parseClass (const ::xercesc::DOMDocument& doc,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        if (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom)
        {
          ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

          return ::std::unique_ptr< ::flexisip::Xsd::XmlSchema::Token > (
            ::flexisip::Xsd::Rpid::parseClass (
              std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
        }

        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "class" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ::flexisip::Xsd::XmlSchema::Token > r (
            ::xsd::cxx::tree::traits< ::flexisip::Xsd::XmlSchema::Token, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "class",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }

      ::std::unique_ptr< ::flexisip::Xsd::XmlSchema::Token >
      parseClass (::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                  ::flexisip::Xsd::XmlSchema::Flags f,
                  const ::flexisip::Xsd::XmlSchema::Properties&)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
          ((f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) &&
           !(f & ::flexisip::Xsd::XmlSchema::Flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
          : 0);

        ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom)
          doc.setUserData (::flexisip::Xsd::XmlSchema::dom::treeNodeKey,
                           (c.get () ? &c : &d),
                           0);

        if (n.name () == "class" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ::flexisip::Xsd::XmlSchema::Token > r (
            ::xsd::cxx::tree::traits< ::flexisip::Xsd::XmlSchema::Token, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "class",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Mood >
      parseMood (const ::std::string& u,
                 ::flexisip::Xsd::XmlSchema::Flags f,
                 const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::tree::error_handler< char > h;

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Mood > (
          ::flexisip::Xsd::Rpid::parseMood (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Mood >
      parseMood (const ::std::string& u,
                 ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                 ::flexisip::Xsd::XmlSchema::Flags f,
                 const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Mood > (
          ::flexisip::Xsd::Rpid::parseMood (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Mood >
      parseMood (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::flexisip::Xsd::XmlSchema::Flags f,
                 const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Mood > (
          ::flexisip::Xsd::Rpid::parseMood (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Mood >
      parseMood (::std::istream& is,
                 ::flexisip::Xsd::XmlSchema::Flags f,
                 const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseMood (isrc, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Mood >
      parseMood (::std::istream& is,
                 ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                 ::flexisip::Xsd::XmlSchema::Flags f,
                 const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseMood (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Mood >
      parseMood (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::flexisip::Xsd::XmlSchema::Flags f,
                 const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseMood (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Mood >
      parseMood (::std::istream& is,
                 const ::std::string& sid,
                 ::flexisip::Xsd::XmlSchema::Flags f,
                 const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseMood (isrc, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Mood >
      parseMood (::std::istream& is,
                 const ::std::string& sid,
                 ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                 ::flexisip::Xsd::XmlSchema::Flags f,
                 const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseMood (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Mood >
      parseMood (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::flexisip::Xsd::XmlSchema::Flags f,
                 const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseMood (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Mood >
      parseMood (::xercesc::InputSource& i,
                 ::flexisip::Xsd::XmlSchema::Flags f,
                 const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::tree::error_handler< char > h;

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Mood > (
          ::flexisip::Xsd::Rpid::parseMood (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Mood >
      parseMood (::xercesc::InputSource& i,
                 ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                 ::flexisip::Xsd::XmlSchema::Flags f,
                 const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Mood > (
          ::flexisip::Xsd::Rpid::parseMood (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Mood >
      parseMood (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::flexisip::Xsd::XmlSchema::Flags f,
                 const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Mood > (
          ::flexisip::Xsd::Rpid::parseMood (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Mood >
      parseMood (const ::xercesc::DOMDocument& doc,
                 ::flexisip::Xsd::XmlSchema::Flags f,
                 const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        if (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom)
        {
          ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

          return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Mood > (
            ::flexisip::Xsd::Rpid::parseMood (
              std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
        }

        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "mood" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ::flexisip::Xsd::Rpid::Mood > r (
            ::xsd::cxx::tree::traits< ::flexisip::Xsd::Rpid::Mood, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "mood",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Mood >
      parseMood (::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                 ::flexisip::Xsd::XmlSchema::Flags f,
                 const ::flexisip::Xsd::XmlSchema::Properties&)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
          ((f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) &&
           !(f & ::flexisip::Xsd::XmlSchema::Flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
          : 0);

        ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom)
          doc.setUserData (::flexisip::Xsd::XmlSchema::dom::treeNodeKey,
                           (c.get () ? &c : &d),
                           0);

        if (n.name () == "mood" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ::flexisip::Xsd::Rpid::Mood > r (
            ::xsd::cxx::tree::traits< ::flexisip::Xsd::Rpid::Mood, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "mood",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceIs >
      parsePlaceIs (const ::std::string& u,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::tree::error_handler< char > h;

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceIs > (
          ::flexisip::Xsd::Rpid::parsePlaceIs (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceIs >
      parsePlaceIs (const ::std::string& u,
                    ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceIs > (
          ::flexisip::Xsd::Rpid::parsePlaceIs (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceIs >
      parsePlaceIs (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceIs > (
          ::flexisip::Xsd::Rpid::parsePlaceIs (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceIs >
      parsePlaceIs (::std::istream& is,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parsePlaceIs (isrc, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceIs >
      parsePlaceIs (::std::istream& is,
                    ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parsePlaceIs (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceIs >
      parsePlaceIs (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parsePlaceIs (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceIs >
      parsePlaceIs (::std::istream& is,
                    const ::std::string& sid,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parsePlaceIs (isrc, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceIs >
      parsePlaceIs (::std::istream& is,
                    const ::std::string& sid,
                    ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parsePlaceIs (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceIs >
      parsePlaceIs (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parsePlaceIs (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceIs >
      parsePlaceIs (::xercesc::InputSource& i,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::tree::error_handler< char > h;

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceIs > (
          ::flexisip::Xsd::Rpid::parsePlaceIs (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceIs >
      parsePlaceIs (::xercesc::InputSource& i,
                    ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceIs > (
          ::flexisip::Xsd::Rpid::parsePlaceIs (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceIs >
      parsePlaceIs (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceIs > (
          ::flexisip::Xsd::Rpid::parsePlaceIs (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceIs >
      parsePlaceIs (const ::xercesc::DOMDocument& doc,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        if (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom)
        {
          ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

          return ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceIs > (
            ::flexisip::Xsd::Rpid::parsePlaceIs (
              std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
        }

        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "place-is" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceIs > r (
            ::xsd::cxx::tree::traits< ::flexisip::Xsd::Rpid::PlaceIs, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "place-is",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceIs >
      parsePlaceIs (::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties&)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
          ((f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) &&
           !(f & ::flexisip::Xsd::XmlSchema::Flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
          : 0);

        ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom)
          doc.setUserData (::flexisip::Xsd::XmlSchema::dom::treeNodeKey,
                           (c.get () ? &c : &d),
                           0);

        if (n.name () == "place-is" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceIs > r (
            ::xsd::cxx::tree::traits< ::flexisip::Xsd::Rpid::PlaceIs, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "place-is",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceType >
      parsePlaceType (const ::std::string& u,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::tree::error_handler< char > h;

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceType > (
          ::flexisip::Xsd::Rpid::parsePlaceType (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceType >
      parsePlaceType (const ::std::string& u,
                      ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceType > (
          ::flexisip::Xsd::Rpid::parsePlaceType (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceType >
      parsePlaceType (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceType > (
          ::flexisip::Xsd::Rpid::parsePlaceType (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceType >
      parsePlaceType (::std::istream& is,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parsePlaceType (isrc, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceType >
      parsePlaceType (::std::istream& is,
                      ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parsePlaceType (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceType >
      parsePlaceType (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parsePlaceType (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceType >
      parsePlaceType (::std::istream& is,
                      const ::std::string& sid,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parsePlaceType (isrc, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceType >
      parsePlaceType (::std::istream& is,
                      const ::std::string& sid,
                      ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parsePlaceType (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceType >
      parsePlaceType (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parsePlaceType (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceType >
      parsePlaceType (::xercesc::InputSource& i,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::tree::error_handler< char > h;

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceType > (
          ::flexisip::Xsd::Rpid::parsePlaceType (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceType >
      parsePlaceType (::xercesc::InputSource& i,
                      ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceType > (
          ::flexisip::Xsd::Rpid::parsePlaceType (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceType >
      parsePlaceType (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceType > (
          ::flexisip::Xsd::Rpid::parsePlaceType (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceType >
      parsePlaceType (const ::xercesc::DOMDocument& doc,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        if (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom)
        {
          ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

          return ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceType > (
            ::flexisip::Xsd::Rpid::parsePlaceType (
              std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
        }

        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "place-type" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceType > r (
            ::xsd::cxx::tree::traits< ::flexisip::Xsd::Rpid::PlaceType, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "place-type",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceType >
      parsePlaceType (::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties&)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
          ((f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) &&
           !(f & ::flexisip::Xsd::XmlSchema::Flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
          : 0);

        ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom)
          doc.setUserData (::flexisip::Xsd::XmlSchema::dom::treeNodeKey,
                           (c.get () ? &c : &d),
                           0);

        if (n.name () == "place-type" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ::flexisip::Xsd::Rpid::PlaceType > r (
            ::xsd::cxx::tree::traits< ::flexisip::Xsd::Rpid::PlaceType, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "place-type",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Privacy >
      parsePrivacy (const ::std::string& u,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::tree::error_handler< char > h;

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Privacy > (
          ::flexisip::Xsd::Rpid::parsePrivacy (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Privacy >
      parsePrivacy (const ::std::string& u,
                    ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Privacy > (
          ::flexisip::Xsd::Rpid::parsePrivacy (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Privacy >
      parsePrivacy (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Privacy > (
          ::flexisip::Xsd::Rpid::parsePrivacy (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Privacy >
      parsePrivacy (::std::istream& is,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parsePrivacy (isrc, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Privacy >
      parsePrivacy (::std::istream& is,
                    ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parsePrivacy (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Privacy >
      parsePrivacy (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parsePrivacy (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Privacy >
      parsePrivacy (::std::istream& is,
                    const ::std::string& sid,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parsePrivacy (isrc, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Privacy >
      parsePrivacy (::std::istream& is,
                    const ::std::string& sid,
                    ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parsePrivacy (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Privacy >
      parsePrivacy (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parsePrivacy (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Privacy >
      parsePrivacy (::xercesc::InputSource& i,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::tree::error_handler< char > h;

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Privacy > (
          ::flexisip::Xsd::Rpid::parsePrivacy (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Privacy >
      parsePrivacy (::xercesc::InputSource& i,
                    ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Privacy > (
          ::flexisip::Xsd::Rpid::parsePrivacy (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Privacy >
      parsePrivacy (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Privacy > (
          ::flexisip::Xsd::Rpid::parsePrivacy (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Privacy >
      parsePrivacy (const ::xercesc::DOMDocument& doc,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        if (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom)
        {
          ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

          return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Privacy > (
            ::flexisip::Xsd::Rpid::parsePrivacy (
              std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
        }

        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "privacy" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ::flexisip::Xsd::Rpid::Privacy > r (
            ::xsd::cxx::tree::traits< ::flexisip::Xsd::Rpid::Privacy, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "privacy",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Privacy >
      parsePrivacy (::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                    ::flexisip::Xsd::XmlSchema::Flags f,
                    const ::flexisip::Xsd::XmlSchema::Properties&)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
          ((f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) &&
           !(f & ::flexisip::Xsd::XmlSchema::Flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
          : 0);

        ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom)
          doc.setUserData (::flexisip::Xsd::XmlSchema::dom::treeNodeKey,
                           (c.get () ? &c : &d),
                           0);

        if (n.name () == "privacy" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ::flexisip::Xsd::Rpid::Privacy > r (
            ::xsd::cxx::tree::traits< ::flexisip::Xsd::Rpid::Privacy, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "privacy",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Relationship >
      parseRelationship (const ::std::string& u,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::tree::error_handler< char > h;

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Relationship > (
          ::flexisip::Xsd::Rpid::parseRelationship (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Relationship >
      parseRelationship (const ::std::string& u,
                         ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Relationship > (
          ::flexisip::Xsd::Rpid::parseRelationship (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Relationship >
      parseRelationship (const ::std::string& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Relationship > (
          ::flexisip::Xsd::Rpid::parseRelationship (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Relationship >
      parseRelationship (::std::istream& is,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseRelationship (isrc, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Relationship >
      parseRelationship (::std::istream& is,
                         ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseRelationship (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Relationship >
      parseRelationship (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseRelationship (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Relationship >
      parseRelationship (::std::istream& is,
                         const ::std::string& sid,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseRelationship (isrc, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Relationship >
      parseRelationship (::std::istream& is,
                         const ::std::string& sid,
                         ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseRelationship (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Relationship >
      parseRelationship (::std::istream& is,
                         const ::std::string& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseRelationship (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Relationship >
      parseRelationship (::xercesc::InputSource& i,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::tree::error_handler< char > h;

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Relationship > (
          ::flexisip::Xsd::Rpid::parseRelationship (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Relationship >
      parseRelationship (::xercesc::InputSource& i,
                         ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Relationship > (
          ::flexisip::Xsd::Rpid::parseRelationship (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Relationship >
      parseRelationship (::xercesc::InputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Relationship > (
          ::flexisip::Xsd::Rpid::parseRelationship (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Relationship >
      parseRelationship (const ::xercesc::DOMDocument& doc,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        if (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom)
        {
          ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

          return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Relationship > (
            ::flexisip::Xsd::Rpid::parseRelationship (
              std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
        }

        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "relationship" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ::flexisip::Xsd::Rpid::Relationship > r (
            ::xsd::cxx::tree::traits< ::flexisip::Xsd::Rpid::Relationship, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "relationship",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Relationship >
      parseRelationship (::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties&)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
          ((f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) &&
           !(f & ::flexisip::Xsd::XmlSchema::Flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
          : 0);

        ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom)
          doc.setUserData (::flexisip::Xsd::XmlSchema::dom::treeNodeKey,
                           (c.get () ? &c : &d),
                           0);

        if (n.name () == "relationship" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ::flexisip::Xsd::Rpid::Relationship > r (
            ::xsd::cxx::tree::traits< ::flexisip::Xsd::Rpid::Relationship, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "relationship",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::ServiceClass >
      parseServiceClass (const ::std::string& u,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::tree::error_handler< char > h;

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::ServiceClass > (
          ::flexisip::Xsd::Rpid::parseServiceClass (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::ServiceClass >
      parseServiceClass (const ::std::string& u,
                         ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::ServiceClass > (
          ::flexisip::Xsd::Rpid::parseServiceClass (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::ServiceClass >
      parseServiceClass (const ::std::string& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::ServiceClass > (
          ::flexisip::Xsd::Rpid::parseServiceClass (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::ServiceClass >
      parseServiceClass (::std::istream& is,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseServiceClass (isrc, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::ServiceClass >
      parseServiceClass (::std::istream& is,
                         ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseServiceClass (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::ServiceClass >
      parseServiceClass (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseServiceClass (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::ServiceClass >
      parseServiceClass (::std::istream& is,
                         const ::std::string& sid,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseServiceClass (isrc, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::ServiceClass >
      parseServiceClass (::std::istream& is,
                         const ::std::string& sid,
                         ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseServiceClass (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::ServiceClass >
      parseServiceClass (::std::istream& is,
                         const ::std::string& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseServiceClass (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::ServiceClass >
      parseServiceClass (::xercesc::InputSource& i,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::tree::error_handler< char > h;

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::ServiceClass > (
          ::flexisip::Xsd::Rpid::parseServiceClass (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::ServiceClass >
      parseServiceClass (::xercesc::InputSource& i,
                         ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::ServiceClass > (
          ::flexisip::Xsd::Rpid::parseServiceClass (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::ServiceClass >
      parseServiceClass (::xercesc::InputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::ServiceClass > (
          ::flexisip::Xsd::Rpid::parseServiceClass (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::ServiceClass >
      parseServiceClass (const ::xercesc::DOMDocument& doc,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        if (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom)
        {
          ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

          return ::std::unique_ptr< ::flexisip::Xsd::Rpid::ServiceClass > (
            ::flexisip::Xsd::Rpid::parseServiceClass (
              std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
        }

        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "service-class" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ::flexisip::Xsd::Rpid::ServiceClass > r (
            ::xsd::cxx::tree::traits< ::flexisip::Xsd::Rpid::ServiceClass, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "service-class",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::ServiceClass >
      parseServiceClass (::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                         ::flexisip::Xsd::XmlSchema::Flags f,
                         const ::flexisip::Xsd::XmlSchema::Properties&)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
          ((f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) &&
           !(f & ::flexisip::Xsd::XmlSchema::Flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
          : 0);

        ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom)
          doc.setUserData (::flexisip::Xsd::XmlSchema::dom::treeNodeKey,
                           (c.get () ? &c : &d),
                           0);

        if (n.name () == "service-class" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ::flexisip::Xsd::Rpid::ServiceClass > r (
            ::xsd::cxx::tree::traits< ::flexisip::Xsd::Rpid::ServiceClass, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "service-class",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Sphere >
      parseSphere (const ::std::string& u,
                   ::flexisip::Xsd::XmlSchema::Flags f,
                   const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::tree::error_handler< char > h;

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Sphere > (
          ::flexisip::Xsd::Rpid::parseSphere (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Sphere >
      parseSphere (const ::std::string& u,
                   ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                   ::flexisip::Xsd::XmlSchema::Flags f,
                   const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Sphere > (
          ::flexisip::Xsd::Rpid::parseSphere (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Sphere >
      parseSphere (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::flexisip::Xsd::XmlSchema::Flags f,
                   const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Sphere > (
          ::flexisip::Xsd::Rpid::parseSphere (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Sphere >
      parseSphere (::std::istream& is,
                   ::flexisip::Xsd::XmlSchema::Flags f,
                   const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseSphere (isrc, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Sphere >
      parseSphere (::std::istream& is,
                   ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                   ::flexisip::Xsd::XmlSchema::Flags f,
                   const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseSphere (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Sphere >
      parseSphere (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::flexisip::Xsd::XmlSchema::Flags f,
                   const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseSphere (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Sphere >
      parseSphere (::std::istream& is,
                   const ::std::string& sid,
                   ::flexisip::Xsd::XmlSchema::Flags f,
                   const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseSphere (isrc, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Sphere >
      parseSphere (::std::istream& is,
                   const ::std::string& sid,
                   ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                   ::flexisip::Xsd::XmlSchema::Flags f,
                   const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseSphere (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Sphere >
      parseSphere (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::flexisip::Xsd::XmlSchema::Flags f,
                   const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseSphere (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Sphere >
      parseSphere (::xercesc::InputSource& i,
                   ::flexisip::Xsd::XmlSchema::Flags f,
                   const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::tree::error_handler< char > h;

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Sphere > (
          ::flexisip::Xsd::Rpid::parseSphere (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Sphere >
      parseSphere (::xercesc::InputSource& i,
                   ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                   ::flexisip::Xsd::XmlSchema::Flags f,
                   const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Sphere > (
          ::flexisip::Xsd::Rpid::parseSphere (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Sphere >
      parseSphere (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::flexisip::Xsd::XmlSchema::Flags f,
                   const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Sphere > (
          ::flexisip::Xsd::Rpid::parseSphere (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Sphere >
      parseSphere (const ::xercesc::DOMDocument& doc,
                   ::flexisip::Xsd::XmlSchema::Flags f,
                   const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        if (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom)
        {
          ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

          return ::std::unique_ptr< ::flexisip::Xsd::Rpid::Sphere > (
            ::flexisip::Xsd::Rpid::parseSphere (
              std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
        }

        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "sphere" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ::flexisip::Xsd::Rpid::Sphere > r (
            ::xsd::cxx::tree::traits< ::flexisip::Xsd::Rpid::Sphere, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "sphere",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::Sphere >
      parseSphere (::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                   ::flexisip::Xsd::XmlSchema::Flags f,
                   const ::flexisip::Xsd::XmlSchema::Properties&)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
          ((f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) &&
           !(f & ::flexisip::Xsd::XmlSchema::Flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
          : 0);

        ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom)
          doc.setUserData (::flexisip::Xsd::XmlSchema::dom::treeNodeKey,
                           (c.get () ? &c : &d),
                           0);

        if (n.name () == "sphere" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ::flexisip::Xsd::Rpid::Sphere > r (
            ::xsd::cxx::tree::traits< ::flexisip::Xsd::Rpid::Sphere, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "sphere",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::StatusIcon >
      parseStatusIcon (const ::std::string& u,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::tree::error_handler< char > h;

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::StatusIcon > (
          ::flexisip::Xsd::Rpid::parseStatusIcon (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::StatusIcon >
      parseStatusIcon (const ::std::string& u,
                       ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::StatusIcon > (
          ::flexisip::Xsd::Rpid::parseStatusIcon (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::StatusIcon >
      parseStatusIcon (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::StatusIcon > (
          ::flexisip::Xsd::Rpid::parseStatusIcon (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::StatusIcon >
      parseStatusIcon (::std::istream& is,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseStatusIcon (isrc, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::StatusIcon >
      parseStatusIcon (::std::istream& is,
                       ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseStatusIcon (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::StatusIcon >
      parseStatusIcon (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseStatusIcon (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::StatusIcon >
      parseStatusIcon (::std::istream& is,
                       const ::std::string& sid,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseStatusIcon (isrc, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::StatusIcon >
      parseStatusIcon (::std::istream& is,
                       const ::std::string& sid,
                       ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseStatusIcon (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::StatusIcon >
      parseStatusIcon (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseStatusIcon (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::StatusIcon >
      parseStatusIcon (::xercesc::InputSource& i,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::tree::error_handler< char > h;

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::StatusIcon > (
          ::flexisip::Xsd::Rpid::parseStatusIcon (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::StatusIcon >
      parseStatusIcon (::xercesc::InputSource& i,
                       ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::StatusIcon > (
          ::flexisip::Xsd::Rpid::parseStatusIcon (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::StatusIcon >
      parseStatusIcon (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::StatusIcon > (
          ::flexisip::Xsd::Rpid::parseStatusIcon (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::StatusIcon >
      parseStatusIcon (const ::xercesc::DOMDocument& doc,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        if (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom)
        {
          ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

          return ::std::unique_ptr< ::flexisip::Xsd::Rpid::StatusIcon > (
            ::flexisip::Xsd::Rpid::parseStatusIcon (
              std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
        }

        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "status-icon" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ::flexisip::Xsd::Rpid::StatusIcon > r (
            ::xsd::cxx::tree::traits< ::flexisip::Xsd::Rpid::StatusIcon, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "status-icon",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::StatusIcon >
      parseStatusIcon (::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties&)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
          ((f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) &&
           !(f & ::flexisip::Xsd::XmlSchema::Flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
          : 0);

        ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom)
          doc.setUserData (::flexisip::Xsd::XmlSchema::dom::treeNodeKey,
                           (c.get () ? &c : &d),
                           0);

        if (n.name () == "status-icon" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ::flexisip::Xsd::Rpid::StatusIcon > r (
            ::xsd::cxx::tree::traits< ::flexisip::Xsd::Rpid::StatusIcon, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "status-icon",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::TimeOffset >
      parseTimeOffset (const ::std::string& u,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::tree::error_handler< char > h;

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::TimeOffset > (
          ::flexisip::Xsd::Rpid::parseTimeOffset (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::TimeOffset >
      parseTimeOffset (const ::std::string& u,
                       ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::TimeOffset > (
          ::flexisip::Xsd::Rpid::parseTimeOffset (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::TimeOffset >
      parseTimeOffset (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::TimeOffset > (
          ::flexisip::Xsd::Rpid::parseTimeOffset (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::TimeOffset >
      parseTimeOffset (::std::istream& is,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseTimeOffset (isrc, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::TimeOffset >
      parseTimeOffset (::std::istream& is,
                       ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseTimeOffset (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::TimeOffset >
      parseTimeOffset (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseTimeOffset (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::TimeOffset >
      parseTimeOffset (::std::istream& is,
                       const ::std::string& sid,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseTimeOffset (isrc, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::TimeOffset >
      parseTimeOffset (::std::istream& is,
                       const ::std::string& sid,
                       ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseTimeOffset (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::TimeOffset >
      parseTimeOffset (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseTimeOffset (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::TimeOffset >
      parseTimeOffset (::xercesc::InputSource& i,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::tree::error_handler< char > h;

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::TimeOffset > (
          ::flexisip::Xsd::Rpid::parseTimeOffset (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::TimeOffset >
      parseTimeOffset (::xercesc::InputSource& i,
                       ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::TimeOffset > (
          ::flexisip::Xsd::Rpid::parseTimeOffset (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::TimeOffset >
      parseTimeOffset (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::TimeOffset > (
          ::flexisip::Xsd::Rpid::parseTimeOffset (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::TimeOffset >
      parseTimeOffset (const ::xercesc::DOMDocument& doc,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        if (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom)
        {
          ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

          return ::std::unique_ptr< ::flexisip::Xsd::Rpid::TimeOffset > (
            ::flexisip::Xsd::Rpid::parseTimeOffset (
              std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
        }

        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "time-offset" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ::flexisip::Xsd::Rpid::TimeOffset > r (
            ::xsd::cxx::tree::traits< ::flexisip::Xsd::Rpid::TimeOffset, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "time-offset",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::TimeOffset >
      parseTimeOffset (::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                       ::flexisip::Xsd::XmlSchema::Flags f,
                       const ::flexisip::Xsd::XmlSchema::Properties&)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
          ((f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) &&
           !(f & ::flexisip::Xsd::XmlSchema::Flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
          : 0);

        ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom)
          doc.setUserData (::flexisip::Xsd::XmlSchema::dom::treeNodeKey,
                           (c.get () ? &c : &d),
                           0);

        if (n.name () == "time-offset" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ::flexisip::Xsd::Rpid::TimeOffset > r (
            ::xsd::cxx::tree::traits< ::flexisip::Xsd::Rpid::TimeOffset, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "time-offset",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::UserInput >
      parseUserInput (const ::std::string& u,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::tree::error_handler< char > h;

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::UserInput > (
          ::flexisip::Xsd::Rpid::parseUserInput (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::UserInput >
      parseUserInput (const ::std::string& u,
                      ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::UserInput > (
          ::flexisip::Xsd::Rpid::parseUserInput (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::UserInput >
      parseUserInput (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::UserInput > (
          ::flexisip::Xsd::Rpid::parseUserInput (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::UserInput >
      parseUserInput (::std::istream& is,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseUserInput (isrc, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::UserInput >
      parseUserInput (::std::istream& is,
                      ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseUserInput (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::UserInput >
      parseUserInput (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::flexisip::Xsd::Rpid::parseUserInput (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::UserInput >
      parseUserInput (::std::istream& is,
                      const ::std::string& sid,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseUserInput (isrc, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::UserInput >
      parseUserInput (::std::istream& is,
                      const ::std::string& sid,
                      ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0,
          (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseUserInput (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::UserInput >
      parseUserInput (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::flexisip::Xsd::Rpid::parseUserInput (isrc, h, f, p);
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::UserInput >
      parseUserInput (::xercesc::InputSource& i,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::xsd::cxx::tree::error_handler< char > h;

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::UserInput > (
          ::flexisip::Xsd::Rpid::parseUserInput (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::UserInput >
      parseUserInput (::xercesc::InputSource& i,
                      ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::UserInput > (
          ::flexisip::Xsd::Rpid::parseUserInput (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::UserInput >
      parseUserInput (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::flexisip::Xsd::Rpid::UserInput > (
          ::flexisip::Xsd::Rpid::parseUserInput (
            std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::UserInput >
      parseUserInput (const ::xercesc::DOMDocument& doc,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties& p)
      {
        if (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom)
        {
          ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

          return ::std::unique_ptr< ::flexisip::Xsd::Rpid::UserInput > (
            ::flexisip::Xsd::Rpid::parseUserInput (
              std::move (d), f | ::flexisip::Xsd::XmlSchema::Flags::own_dom, p));
        }

        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "user-input" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ::flexisip::Xsd::Rpid::UserInput > r (
            ::xsd::cxx::tree::traits< ::flexisip::Xsd::Rpid::UserInput, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "user-input",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }

      ::std::unique_ptr< ::flexisip::Xsd::Rpid::UserInput >
      parseUserInput (::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                      ::flexisip::Xsd::XmlSchema::Flags f,
                      const ::flexisip::Xsd::XmlSchema::Properties&)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > c (
          ((f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom) &&
           !(f & ::flexisip::Xsd::XmlSchema::Flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
          : 0);

        ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (f & ::flexisip::Xsd::XmlSchema::Flags::keep_dom)
          doc.setUserData (::flexisip::Xsd::XmlSchema::dom::treeNodeKey,
                           (c.get () ? &c : &d),
                           0);

        if (n.name () == "user-input" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          ::std::unique_ptr< ::flexisip::Xsd::Rpid::UserInput > r (
            ::xsd::cxx::tree::traits< ::flexisip::Xsd::Rpid::UserInput, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "user-input",
          "urn:ietf:params:xml:ns:pidf:rpid");
      }
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace flexisip
{
  namespace Xsd
  {
    namespace Rpid
    {
      void
      operator<< (::xercesc::DOMElement& e, const Timestamp_t& i)
      {
        e << static_cast< const ::flexisip::Xsd::XmlSchema::DateTime& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const Timestamp_t& i)
      {
        a << static_cast< const ::flexisip::Xsd::XmlSchema::DateTime& > (i);
      }

      void
      operator<< (::flexisip::Xsd::XmlSchema::ListStream& l,
                  const Timestamp_t& i)
      {
        l << static_cast< const ::flexisip::Xsd::XmlSchema::DateTime& > (i);
      }

      void
      operator<< (::xercesc::DOMElement& e, const DeviceID_t& i)
      {
        e << static_cast< const ::flexisip::Xsd::XmlSchema::Uri& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const DeviceID_t& i)
      {
        a << static_cast< const ::flexisip::Xsd::XmlSchema::Uri& > (i);
      }

      void
      operator<< (::flexisip::Xsd::XmlSchema::ListStream& l,
                  const DeviceID_t& i)
      {
        l << static_cast< const ::flexisip::Xsd::XmlSchema::Uri& > (i);
      }

      void
      operator<< (::xercesc::DOMElement& e, const Note_t& i)
      {
        e << static_cast< const ::flexisip::Xsd::XmlSchema::String& > (i);

        // lang
        //
        if (i.getLang ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "lang",
              "http://www.w3.org/XML/1998/namespace",
              e));

          a << *i.getLang ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Empty& i)
      {
        e << static_cast< const ::flexisip::Xsd::XmlSchema::Type& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr&, const Empty&)
      {
      }

      void
      operator<< (::flexisip::Xsd::XmlSchema::ListStream&,
                  const Empty&)
      {
      }
    }
  }
}

namespace flexisip
{
  namespace Xsd
  {
    namespace Rpid
    {
      void
      operator<< (::xercesc::DOMElement& e, const ActiveIdle& i)
      {
        e << static_cast< const ::flexisip::Xsd::XmlSchema::String& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const ActiveIdle& i)
      {
        a << static_cast< const ::flexisip::Xsd::XmlSchema::String& > (i);
      }

      void
      operator<< (::flexisip::Xsd::XmlSchema::ListStream& l,
                  const ActiveIdle& i)
      {
        l << static_cast< const ::flexisip::Xsd::XmlSchema::String& > (i);
      }

      void
      serializeActivities (::std::ostream& o,
                           const ::flexisip::Xsd::Rpid::Activities& s,
                           const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeActivities (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      serializeActivities (::std::ostream& o,
                           const ::flexisip::Xsd::Rpid::Activities& s,
                           ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                           const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeActivities (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeActivities (::std::ostream& o,
                           const ::flexisip::Xsd::Rpid::Activities& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeActivities (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeActivities (::xercesc::XMLFormatTarget& t,
                           const ::flexisip::Xsd::Rpid::Activities& s,
                           const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeActivities (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      serializeActivities (::xercesc::XMLFormatTarget& t,
                           const ::flexisip::Xsd::Rpid::Activities& s,
                           ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                           const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeActivities (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeActivities (::xercesc::XMLFormatTarget& t,
                           const ::flexisip::Xsd::Rpid::Activities& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeActivities (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeActivities (::xercesc::DOMDocument& d,
                           const ::flexisip::Xsd::Rpid::Activities& s,
                           ::flexisip::Xsd::XmlSchema::Flags)
      {
        ::xercesc::DOMElement& e (*d.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "activities" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "activities",
            "urn:ietf:params:xml:ns:pidf:rpid");
        }
      }

      ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
      serializeActivities (const ::flexisip::Xsd::Rpid::Activities& s,
                           const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                           ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::serialize< char > (
            "activities",
            "urn:ietf:params:xml:ns:pidf:rpid",
            m, f));

        ::flexisip::Xsd::Rpid::serializeActivities (*d, s, f);
        return d;
      }

      void
      serializeClass (::std::ostream& o,
                      const ::flexisip::Xsd::XmlSchema::Token& s,
                      const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeClass (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      serializeClass (::std::ostream& o,
                      const ::flexisip::Xsd::XmlSchema::Token& s,
                      ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                      const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeClass (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeClass (::std::ostream& o,
                      const ::flexisip::Xsd::XmlSchema::Token& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeClass (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeClass (::xercesc::XMLFormatTarget& t,
                      const ::flexisip::Xsd::XmlSchema::Token& s,
                      const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeClass (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      serializeClass (::xercesc::XMLFormatTarget& t,
                      const ::flexisip::Xsd::XmlSchema::Token& s,
                      ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                      const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeClass (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeClass (::xercesc::XMLFormatTarget& t,
                      const ::flexisip::Xsd::XmlSchema::Token& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeClass (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeClass (::xercesc::DOMDocument& d,
                      const ::flexisip::Xsd::XmlSchema::Token& s,
                      ::flexisip::Xsd::XmlSchema::Flags)
      {
        ::xercesc::DOMElement& e (*d.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "class" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "class",
            "urn:ietf:params:xml:ns:pidf:rpid");
        }
      }

      ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
      serializeClass (const ::flexisip::Xsd::XmlSchema::Token& s,
                      const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                      ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::serialize< char > (
            "class",
            "urn:ietf:params:xml:ns:pidf:rpid",
            m, f));

        ::flexisip::Xsd::Rpid::serializeClass (*d, s, f);
        return d;
      }

      void
      serializeMood (::std::ostream& o,
                     const ::flexisip::Xsd::Rpid::Mood& s,
                     const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeMood (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      serializeMood (::std::ostream& o,
                     const ::flexisip::Xsd::Rpid::Mood& s,
                     ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                     const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeMood (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeMood (::std::ostream& o,
                     const ::flexisip::Xsd::Rpid::Mood& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeMood (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeMood (::xercesc::XMLFormatTarget& t,
                     const ::flexisip::Xsd::Rpid::Mood& s,
                     const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeMood (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      serializeMood (::xercesc::XMLFormatTarget& t,
                     const ::flexisip::Xsd::Rpid::Mood& s,
                     ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                     const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeMood (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeMood (::xercesc::XMLFormatTarget& t,
                     const ::flexisip::Xsd::Rpid::Mood& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeMood (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeMood (::xercesc::DOMDocument& d,
                     const ::flexisip::Xsd::Rpid::Mood& s,
                     ::flexisip::Xsd::XmlSchema::Flags)
      {
        ::xercesc::DOMElement& e (*d.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "mood" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "mood",
            "urn:ietf:params:xml:ns:pidf:rpid");
        }
      }

      ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
      serializeMood (const ::flexisip::Xsd::Rpid::Mood& s,
                     const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                     ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::serialize< char > (
            "mood",
            "urn:ietf:params:xml:ns:pidf:rpid",
            m, f));

        ::flexisip::Xsd::Rpid::serializeMood (*d, s, f);
        return d;
      }

      void
      serializePlaceIs (::std::ostream& o,
                        const ::flexisip::Xsd::Rpid::PlaceIs& s,
                        const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializePlaceIs (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      serializePlaceIs (::std::ostream& o,
                        const ::flexisip::Xsd::Rpid::PlaceIs& s,
                        ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                        const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializePlaceIs (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializePlaceIs (::std::ostream& o,
                        const ::flexisip::Xsd::Rpid::PlaceIs& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializePlaceIs (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializePlaceIs (::xercesc::XMLFormatTarget& t,
                        const ::flexisip::Xsd::Rpid::PlaceIs& s,
                        const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializePlaceIs (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      serializePlaceIs (::xercesc::XMLFormatTarget& t,
                        const ::flexisip::Xsd::Rpid::PlaceIs& s,
                        ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                        const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializePlaceIs (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializePlaceIs (::xercesc::XMLFormatTarget& t,
                        const ::flexisip::Xsd::Rpid::PlaceIs& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializePlaceIs (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializePlaceIs (::xercesc::DOMDocument& d,
                        const ::flexisip::Xsd::Rpid::PlaceIs& s,
                        ::flexisip::Xsd::XmlSchema::Flags)
      {
        ::xercesc::DOMElement& e (*d.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "place-is" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "place-is",
            "urn:ietf:params:xml:ns:pidf:rpid");
        }
      }

      ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
      serializePlaceIs (const ::flexisip::Xsd::Rpid::PlaceIs& s,
                        const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                        ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::serialize< char > (
            "place-is",
            "urn:ietf:params:xml:ns:pidf:rpid",
            m, f));

        ::flexisip::Xsd::Rpid::serializePlaceIs (*d, s, f);
        return d;
      }

      void
      serializePlaceType (::std::ostream& o,
                          const ::flexisip::Xsd::Rpid::PlaceType& s,
                          const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializePlaceType (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      serializePlaceType (::std::ostream& o,
                          const ::flexisip::Xsd::Rpid::PlaceType& s,
                          ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                          const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializePlaceType (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializePlaceType (::std::ostream& o,
                          const ::flexisip::Xsd::Rpid::PlaceType& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializePlaceType (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializePlaceType (::xercesc::XMLFormatTarget& t,
                          const ::flexisip::Xsd::Rpid::PlaceType& s,
                          const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializePlaceType (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      serializePlaceType (::xercesc::XMLFormatTarget& t,
                          const ::flexisip::Xsd::Rpid::PlaceType& s,
                          ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                          const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializePlaceType (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializePlaceType (::xercesc::XMLFormatTarget& t,
                          const ::flexisip::Xsd::Rpid::PlaceType& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializePlaceType (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializePlaceType (::xercesc::DOMDocument& d,
                          const ::flexisip::Xsd::Rpid::PlaceType& s,
                          ::flexisip::Xsd::XmlSchema::Flags)
      {
        ::xercesc::DOMElement& e (*d.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "place-type" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "place-type",
            "urn:ietf:params:xml:ns:pidf:rpid");
        }
      }

      ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
      serializePlaceType (const ::flexisip::Xsd::Rpid::PlaceType& s,
                          const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                          ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::serialize< char > (
            "place-type",
            "urn:ietf:params:xml:ns:pidf:rpid",
            m, f));

        ::flexisip::Xsd::Rpid::serializePlaceType (*d, s, f);
        return d;
      }

      void
      serializePrivacy (::std::ostream& o,
                        const ::flexisip::Xsd::Rpid::Privacy& s,
                        const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializePrivacy (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      serializePrivacy (::std::ostream& o,
                        const ::flexisip::Xsd::Rpid::Privacy& s,
                        ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                        const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializePrivacy (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializePrivacy (::std::ostream& o,
                        const ::flexisip::Xsd::Rpid::Privacy& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializePrivacy (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializePrivacy (::xercesc::XMLFormatTarget& t,
                        const ::flexisip::Xsd::Rpid::Privacy& s,
                        const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializePrivacy (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      serializePrivacy (::xercesc::XMLFormatTarget& t,
                        const ::flexisip::Xsd::Rpid::Privacy& s,
                        ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                        const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializePrivacy (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializePrivacy (::xercesc::XMLFormatTarget& t,
                        const ::flexisip::Xsd::Rpid::Privacy& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializePrivacy (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializePrivacy (::xercesc::DOMDocument& d,
                        const ::flexisip::Xsd::Rpid::Privacy& s,
                        ::flexisip::Xsd::XmlSchema::Flags)
      {
        ::xercesc::DOMElement& e (*d.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "privacy" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "privacy",
            "urn:ietf:params:xml:ns:pidf:rpid");
        }
      }

      ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
      serializePrivacy (const ::flexisip::Xsd::Rpid::Privacy& s,
                        const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                        ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::serialize< char > (
            "privacy",
            "urn:ietf:params:xml:ns:pidf:rpid",
            m, f));

        ::flexisip::Xsd::Rpid::serializePrivacy (*d, s, f);
        return d;
      }

      void
      serializeRelationship (::std::ostream& o,
                             const ::flexisip::Xsd::Rpid::Relationship& s,
                             const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeRelationship (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      serializeRelationship (::std::ostream& o,
                             const ::flexisip::Xsd::Rpid::Relationship& s,
                             ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                             const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeRelationship (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeRelationship (::std::ostream& o,
                             const ::flexisip::Xsd::Rpid::Relationship& s,
                             ::xercesc::DOMErrorHandler& h,
                             const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeRelationship (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeRelationship (::xercesc::XMLFormatTarget& t,
                             const ::flexisip::Xsd::Rpid::Relationship& s,
                             const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeRelationship (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      serializeRelationship (::xercesc::XMLFormatTarget& t,
                             const ::flexisip::Xsd::Rpid::Relationship& s,
                             ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                             const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeRelationship (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeRelationship (::xercesc::XMLFormatTarget& t,
                             const ::flexisip::Xsd::Rpid::Relationship& s,
                             ::xercesc::DOMErrorHandler& h,
                             const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeRelationship (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeRelationship (::xercesc::DOMDocument& d,
                             const ::flexisip::Xsd::Rpid::Relationship& s,
                             ::flexisip::Xsd::XmlSchema::Flags)
      {
        ::xercesc::DOMElement& e (*d.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "relationship" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "relationship",
            "urn:ietf:params:xml:ns:pidf:rpid");
        }
      }

      ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
      serializeRelationship (const ::flexisip::Xsd::Rpid::Relationship& s,
                             const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::serialize< char > (
            "relationship",
            "urn:ietf:params:xml:ns:pidf:rpid",
            m, f));

        ::flexisip::Xsd::Rpid::serializeRelationship (*d, s, f);
        return d;
      }

      void
      serializeServiceClass (::std::ostream& o,
                             const ::flexisip::Xsd::Rpid::ServiceClass& s,
                             const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeServiceClass (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      serializeServiceClass (::std::ostream& o,
                             const ::flexisip::Xsd::Rpid::ServiceClass& s,
                             ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                             const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeServiceClass (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeServiceClass (::std::ostream& o,
                             const ::flexisip::Xsd::Rpid::ServiceClass& s,
                             ::xercesc::DOMErrorHandler& h,
                             const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeServiceClass (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeServiceClass (::xercesc::XMLFormatTarget& t,
                             const ::flexisip::Xsd::Rpid::ServiceClass& s,
                             const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeServiceClass (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      serializeServiceClass (::xercesc::XMLFormatTarget& t,
                             const ::flexisip::Xsd::Rpid::ServiceClass& s,
                             ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                             const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeServiceClass (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeServiceClass (::xercesc::XMLFormatTarget& t,
                             const ::flexisip::Xsd::Rpid::ServiceClass& s,
                             ::xercesc::DOMErrorHandler& h,
                             const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeServiceClass (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeServiceClass (::xercesc::DOMDocument& d,
                             const ::flexisip::Xsd::Rpid::ServiceClass& s,
                             ::flexisip::Xsd::XmlSchema::Flags)
      {
        ::xercesc::DOMElement& e (*d.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "service-class" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "service-class",
            "urn:ietf:params:xml:ns:pidf:rpid");
        }
      }

      ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
      serializeServiceClass (const ::flexisip::Xsd::Rpid::ServiceClass& s,
                             const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                             ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::serialize< char > (
            "service-class",
            "urn:ietf:params:xml:ns:pidf:rpid",
            m, f));

        ::flexisip::Xsd::Rpid::serializeServiceClass (*d, s, f);
        return d;
      }

      void
      serializeSphere (::std::ostream& o,
                       const ::flexisip::Xsd::Rpid::Sphere& s,
                       const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeSphere (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      serializeSphere (::std::ostream& o,
                       const ::flexisip::Xsd::Rpid::Sphere& s,
                       ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                       const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeSphere (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeSphere (::std::ostream& o,
                       const ::flexisip::Xsd::Rpid::Sphere& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeSphere (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeSphere (::xercesc::XMLFormatTarget& t,
                       const ::flexisip::Xsd::Rpid::Sphere& s,
                       const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeSphere (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      serializeSphere (::xercesc::XMLFormatTarget& t,
                       const ::flexisip::Xsd::Rpid::Sphere& s,
                       ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                       const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeSphere (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeSphere (::xercesc::XMLFormatTarget& t,
                       const ::flexisip::Xsd::Rpid::Sphere& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeSphere (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeSphere (::xercesc::DOMDocument& d,
                       const ::flexisip::Xsd::Rpid::Sphere& s,
                       ::flexisip::Xsd::XmlSchema::Flags)
      {
        ::xercesc::DOMElement& e (*d.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "sphere" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "sphere",
            "urn:ietf:params:xml:ns:pidf:rpid");
        }
      }

      ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
      serializeSphere (const ::flexisip::Xsd::Rpid::Sphere& s,
                       const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                       ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::serialize< char > (
            "sphere",
            "urn:ietf:params:xml:ns:pidf:rpid",
            m, f));

        ::flexisip::Xsd::Rpid::serializeSphere (*d, s, f);
        return d;
      }

      void
      serializeStatusIcon (::std::ostream& o,
                           const ::flexisip::Xsd::Rpid::StatusIcon& s,
                           const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeStatusIcon (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      serializeStatusIcon (::std::ostream& o,
                           const ::flexisip::Xsd::Rpid::StatusIcon& s,
                           ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                           const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeStatusIcon (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeStatusIcon (::std::ostream& o,
                           const ::flexisip::Xsd::Rpid::StatusIcon& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeStatusIcon (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeStatusIcon (::xercesc::XMLFormatTarget& t,
                           const ::flexisip::Xsd::Rpid::StatusIcon& s,
                           const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeStatusIcon (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      serializeStatusIcon (::xercesc::XMLFormatTarget& t,
                           const ::flexisip::Xsd::Rpid::StatusIcon& s,
                           ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                           const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeStatusIcon (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeStatusIcon (::xercesc::XMLFormatTarget& t,
                           const ::flexisip::Xsd::Rpid::StatusIcon& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeStatusIcon (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeStatusIcon (::xercesc::DOMDocument& d,
                           const ::flexisip::Xsd::Rpid::StatusIcon& s,
                           ::flexisip::Xsd::XmlSchema::Flags)
      {
        ::xercesc::DOMElement& e (*d.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "status-icon" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "status-icon",
            "urn:ietf:params:xml:ns:pidf:rpid");
        }
      }

      ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
      serializeStatusIcon (const ::flexisip::Xsd::Rpid::StatusIcon& s,
                           const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                           ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::serialize< char > (
            "status-icon",
            "urn:ietf:params:xml:ns:pidf:rpid",
            m, f));

        ::flexisip::Xsd::Rpid::serializeStatusIcon (*d, s, f);
        return d;
      }

      void
      serializeTimeOffset (::std::ostream& o,
                           const ::flexisip::Xsd::Rpid::TimeOffset& s,
                           const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeTimeOffset (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      serializeTimeOffset (::std::ostream& o,
                           const ::flexisip::Xsd::Rpid::TimeOffset& s,
                           ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                           const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeTimeOffset (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeTimeOffset (::std::ostream& o,
                           const ::flexisip::Xsd::Rpid::TimeOffset& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeTimeOffset (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeTimeOffset (::xercesc::XMLFormatTarget& t,
                           const ::flexisip::Xsd::Rpid::TimeOffset& s,
                           const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeTimeOffset (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      serializeTimeOffset (::xercesc::XMLFormatTarget& t,
                           const ::flexisip::Xsd::Rpid::TimeOffset& s,
                           ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                           const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeTimeOffset (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeTimeOffset (::xercesc::XMLFormatTarget& t,
                           const ::flexisip::Xsd::Rpid::TimeOffset& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeTimeOffset (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeTimeOffset (::xercesc::DOMDocument& d,
                           const ::flexisip::Xsd::Rpid::TimeOffset& s,
                           ::flexisip::Xsd::XmlSchema::Flags)
      {
        ::xercesc::DOMElement& e (*d.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "time-offset" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "time-offset",
            "urn:ietf:params:xml:ns:pidf:rpid");
        }
      }

      ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
      serializeTimeOffset (const ::flexisip::Xsd::Rpid::TimeOffset& s,
                           const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                           ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::serialize< char > (
            "time-offset",
            "urn:ietf:params:xml:ns:pidf:rpid",
            m, f));

        ::flexisip::Xsd::Rpid::serializeTimeOffset (*d, s, f);
        return d;
      }

      void
      serializeUserInput (::std::ostream& o,
                          const ::flexisip::Xsd::Rpid::UserInput& s,
                          const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeUserInput (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      serializeUserInput (::std::ostream& o,
                          const ::flexisip::Xsd::Rpid::UserInput& s,
                          ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                          const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::flexisip::Xsd::XmlSchema::Flags::dont_initialize) == 0);

        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeUserInput (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeUserInput (::std::ostream& o,
                          const ::flexisip::Xsd::Rpid::UserInput& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeUserInput (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeUserInput (::xercesc::XMLFormatTarget& t,
                          const ::flexisip::Xsd::Rpid::UserInput& s,
                          const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeUserInput (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      serializeUserInput (::xercesc::XMLFormatTarget& t,
                          const ::flexisip::Xsd::Rpid::UserInput& s,
                          ::flexisip::Xsd::XmlSchema::ErrorHandler& h,
                          const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeUserInput (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeUserInput (::xercesc::XMLFormatTarget& t,
                          const ::flexisip::Xsd::Rpid::UserInput& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::flexisip::Xsd::Rpid::serializeUserInput (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      serializeUserInput (::xercesc::DOMDocument& d,
                          const ::flexisip::Xsd::Rpid::UserInput& s,
                          ::flexisip::Xsd::XmlSchema::Flags)
      {
        ::xercesc::DOMElement& e (*d.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "user-input" &&
            n.namespace_ () == "urn:ietf:params:xml:ns:pidf:rpid")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "user-input",
            "urn:ietf:params:xml:ns:pidf:rpid");
        }
      }

      ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument >
      serializeUserInput (const ::flexisip::Xsd::Rpid::UserInput& s,
                          const ::flexisip::Xsd::XmlSchema::NamespaceInfomap& m,
                          ::flexisip::Xsd::XmlSchema::Flags f)
      {
        ::flexisip::Xsd::XmlSchema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::serialize< char > (
            "user-input",
            "urn:ietf:params:xml:ns:pidf:rpid",
            m, f));

        ::flexisip::Xsd::Rpid::serializeUserInput (*d, s, f);
        return d;
      }

      void
      operator<< (::xercesc::DOMElement& e, const Activities& i)
      {
        e << static_cast< const ::flexisip::Xsd::XmlSchema::Type& > (i);

        // any_attribute
        //
        for (Activities::AnyAttributeConstIterator
             b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMAttr* a (
            static_cast< ::xercesc::DOMAttr* > (
              e.getOwnerDocument ()->importNode (
                const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

          if (a->getLocalName () == 0)
            e.setAttributeNode (a);
          else
            e.setAttributeNodeNS (a);
        }

        // note
        //
        for (Activities::NoteConstIterator
             b (i.getNote ().begin ()), n (i.getNote ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "note",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // unknown
        //
        if (i.getUnknown ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "unknown",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getUnknown ();
        }

        // appointment
        //
        for (Activities::AppointmentConstIterator
             b (i.getAppointment ().begin ()), n (i.getAppointment ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "appointment",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // away
        //
        for (Activities::AwayConstIterator
             b (i.getAway ().begin ()), n (i.getAway ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "away",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // breakfast
        //
        for (Activities::BreakfastConstIterator
             b (i.getBreakfast ().begin ()), n (i.getBreakfast ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "breakfast",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // busy
        //
        for (Activities::BusyConstIterator
             b (i.getBusy ().begin ()), n (i.getBusy ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "busy",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // dinner
        //
        for (Activities::DinnerConstIterator
             b (i.getDinner ().begin ()), n (i.getDinner ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "dinner",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // holiday
        //
        for (Activities::HolidayConstIterator
             b (i.getHoliday ().begin ()), n (i.getHoliday ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "holiday",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // in-transit
        //
        for (Activities::InTransitConstIterator
             b (i.getInTransit ().begin ()), n (i.getInTransit ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "in-transit",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // looking-for-work
        //
        for (Activities::LookingForWorkConstIterator
             b (i.getLookingForWork ().begin ()), n (i.getLookingForWork ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "looking-for-work",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // meal
        //
        for (Activities::MealConstIterator
             b (i.getMeal ().begin ()), n (i.getMeal ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "meal",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // meeting
        //
        for (Activities::MeetingConstIterator
             b (i.getMeeting ().begin ()), n (i.getMeeting ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "meeting",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // on-the-phone
        //
        for (Activities::OnThePhoneConstIterator
             b (i.getOnThePhone ().begin ()), n (i.getOnThePhone ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "on-the-phone",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // performance
        //
        for (Activities::PerformanceConstIterator
             b (i.getPerformance ().begin ()), n (i.getPerformance ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "performance",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // permanent-absence
        //
        for (Activities::PermanentAbsenceConstIterator
             b (i.getPermanentAbsence ().begin ()), n (i.getPermanentAbsence ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "permanent-absence",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // playing
        //
        for (Activities::PlayingConstIterator
             b (i.getPlaying ().begin ()), n (i.getPlaying ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "playing",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // presentation
        //
        for (Activities::PresentationConstIterator
             b (i.getPresentation ().begin ()), n (i.getPresentation ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "presentation",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // shopping
        //
        for (Activities::ShoppingConstIterator
             b (i.getShopping ().begin ()), n (i.getShopping ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "shopping",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // sleeping
        //
        for (Activities::SleepingConstIterator
             b (i.getSleeping ().begin ()), n (i.getSleeping ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "sleeping",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // spectator
        //
        for (Activities::SpectatorConstIterator
             b (i.getSpectator ().begin ()), n (i.getSpectator ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "spectator",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // steering
        //
        for (Activities::SteeringConstIterator
             b (i.getSteering ().begin ()), n (i.getSteering ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "steering",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // travel
        //
        for (Activities::TravelConstIterator
             b (i.getTravel ().begin ()), n (i.getTravel ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "travel",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // tv
        //
        for (Activities::TvConstIterator
             b (i.getTv ().begin ()), n (i.getTv ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "tv",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // vacation
        //
        for (Activities::VacationConstIterator
             b (i.getVacation ().begin ()), n (i.getVacation ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "vacation",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // working
        //
        for (Activities::WorkingConstIterator
             b (i.getWorking ().begin ()), n (i.getWorking ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "working",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // worship
        //
        for (Activities::WorshipConstIterator
             b (i.getWorship ().begin ()), n (i.getWorship ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "worship",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // other
        //
        for (Activities::OtherConstIterator
             b (i.getOther ().begin ()), n (i.getOther ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "other",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // any
        //
        for (Activities::AnyConstIterator
             b (i.getAny ().begin ()), n (i.getAny ().end ());
             b != n; ++b)
        {
          e.appendChild (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMElement* > (&(*b)), true));
        }

        // from
        //
        if (i.getFrom ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "from",
              e));

          a << *i.getFrom ();
        }

        // until
        //
        if (i.getUntil ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "until",
              e));

          a << *i.getUntil ();
        }

        // id
        //
        if (i.getId ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "id",
              e));

          a << *i.getId ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Mood& i)
      {
        e << static_cast< const ::flexisip::Xsd::XmlSchema::Type& > (i);

        // any_attribute
        //
        for (Mood::AnyAttributeConstIterator
             b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMAttr* a (
            static_cast< ::xercesc::DOMAttr* > (
              e.getOwnerDocument ()->importNode (
                const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

          if (a->getLocalName () == 0)
            e.setAttributeNode (a);
          else
            e.setAttributeNodeNS (a);
        }

        // note
        //
        for (Mood::NoteConstIterator
             b (i.getNote ().begin ()), n (i.getNote ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "note",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // unknown
        //
        if (i.getUnknown ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "unknown",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getUnknown ();
        }

        // afraid
        //
        for (Mood::AfraidConstIterator
             b (i.getAfraid ().begin ()), n (i.getAfraid ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "afraid",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // amazed
        //
        for (Mood::AmazedConstIterator
             b (i.getAmazed ().begin ()), n (i.getAmazed ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "amazed",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // angry
        //
        for (Mood::AngryConstIterator
             b (i.getAngry ().begin ()), n (i.getAngry ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "angry",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // annoyed
        //
        for (Mood::AnnoyedConstIterator
             b (i.getAnnoyed ().begin ()), n (i.getAnnoyed ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "annoyed",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // anxious
        //
        for (Mood::AnxiousConstIterator
             b (i.getAnxious ().begin ()), n (i.getAnxious ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "anxious",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // ashamed
        //
        for (Mood::AshamedConstIterator
             b (i.getAshamed ().begin ()), n (i.getAshamed ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ashamed",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // bored
        //
        for (Mood::BoredConstIterator
             b (i.getBored ().begin ()), n (i.getBored ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "bored",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // brave
        //
        for (Mood::BraveConstIterator
             b (i.getBrave ().begin ()), n (i.getBrave ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "brave",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // calm
        //
        for (Mood::CalmConstIterator
             b (i.getCalm ().begin ()), n (i.getCalm ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "calm",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // cold
        //
        for (Mood::ColdConstIterator
             b (i.getCold ().begin ()), n (i.getCold ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "cold",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // confused
        //
        for (Mood::ConfusedConstIterator
             b (i.getConfused ().begin ()), n (i.getConfused ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "confused",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // contented
        //
        for (Mood::ContentedConstIterator
             b (i.getContented ().begin ()), n (i.getContented ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "contented",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // cranky
        //
        for (Mood::CrankyConstIterator
             b (i.getCranky ().begin ()), n (i.getCranky ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "cranky",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // curious
        //
        for (Mood::CuriousConstIterator
             b (i.getCurious ().begin ()), n (i.getCurious ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "curious",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // depressed
        //
        for (Mood::DepressedConstIterator
             b (i.getDepressed ().begin ()), n (i.getDepressed ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "depressed",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // disappointed
        //
        for (Mood::DisappointedConstIterator
             b (i.getDisappointed ().begin ()), n (i.getDisappointed ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "disappointed",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // disgusted
        //
        for (Mood::DisgustedConstIterator
             b (i.getDisgusted ().begin ()), n (i.getDisgusted ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "disgusted",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // distracted
        //
        for (Mood::DistractedConstIterator
             b (i.getDistracted ().begin ()), n (i.getDistracted ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "distracted",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // embarrassed
        //
        for (Mood::EmbarrassedConstIterator
             b (i.getEmbarrassed ().begin ()), n (i.getEmbarrassed ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "embarrassed",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // excited
        //
        for (Mood::ExcitedConstIterator
             b (i.getExcited ().begin ()), n (i.getExcited ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "excited",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // flirtatious
        //
        for (Mood::FlirtatiousConstIterator
             b (i.getFlirtatious ().begin ()), n (i.getFlirtatious ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "flirtatious",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // frustrated
        //
        for (Mood::FrustratedConstIterator
             b (i.getFrustrated ().begin ()), n (i.getFrustrated ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "frustrated",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // grumpy
        //
        for (Mood::GrumpyConstIterator
             b (i.getGrumpy ().begin ()), n (i.getGrumpy ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "grumpy",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // guilty
        //
        for (Mood::GuiltyConstIterator
             b (i.getGuilty ().begin ()), n (i.getGuilty ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "guilty",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // happy
        //
        for (Mood::HappyConstIterator
             b (i.getHappy ().begin ()), n (i.getHappy ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "happy",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // hot
        //
        for (Mood::HotConstIterator
             b (i.getHot ().begin ()), n (i.getHot ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "hot",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // humbled
        //
        for (Mood::HumbledConstIterator
             b (i.getHumbled ().begin ()), n (i.getHumbled ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "humbled",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // humiliated
        //
        for (Mood::HumiliatedConstIterator
             b (i.getHumiliated ().begin ()), n (i.getHumiliated ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "humiliated",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // hungry
        //
        for (Mood::HungryConstIterator
             b (i.getHungry ().begin ()), n (i.getHungry ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "hungry",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // hurt
        //
        for (Mood::HurtConstIterator
             b (i.getHurt ().begin ()), n (i.getHurt ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "hurt",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // impressed
        //
        for (Mood::ImpressedConstIterator
             b (i.getImpressed ().begin ()), n (i.getImpressed ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "impressed",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // in_awe
        //
        for (Mood::In_aweConstIterator
             b (i.getIn_awe ().begin ()), n (i.getIn_awe ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "in_awe",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // in_love
        //
        for (Mood::In_loveConstIterator
             b (i.getIn_love ().begin ()), n (i.getIn_love ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "in_love",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // indignant
        //
        for (Mood::IndignantConstIterator
             b (i.getIndignant ().begin ()), n (i.getIndignant ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "indignant",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // interested
        //
        for (Mood::InterestedConstIterator
             b (i.getInterested ().begin ()), n (i.getInterested ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "interested",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // invincible
        //
        for (Mood::InvincibleConstIterator
             b (i.getInvincible ().begin ()), n (i.getInvincible ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "invincible",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // jealous
        //
        for (Mood::JealousConstIterator
             b (i.getJealous ().begin ()), n (i.getJealous ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "jealous",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // lonely
        //
        for (Mood::LonelyConstIterator
             b (i.getLonely ().begin ()), n (i.getLonely ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "lonely",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // mean
        //
        for (Mood::MeanConstIterator
             b (i.getMean ().begin ()), n (i.getMean ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "mean",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // moody
        //
        for (Mood::MoodyConstIterator
             b (i.getMoody ().begin ()), n (i.getMoody ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "moody",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // nervous
        //
        for (Mood::NervousConstIterator
             b (i.getNervous ().begin ()), n (i.getNervous ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "nervous",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // neutral
        //
        for (Mood::NeutralConstIterator
             b (i.getNeutral ().begin ()), n (i.getNeutral ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "neutral",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // offended
        //
        for (Mood::OffendedConstIterator
             b (i.getOffended ().begin ()), n (i.getOffended ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "offended",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // playful
        //
        for (Mood::PlayfulConstIterator
             b (i.getPlayful ().begin ()), n (i.getPlayful ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "playful",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // proud
        //
        for (Mood::ProudConstIterator
             b (i.getProud ().begin ()), n (i.getProud ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "proud",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // relieved
        //
        for (Mood::RelievedConstIterator
             b (i.getRelieved ().begin ()), n (i.getRelieved ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "relieved",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // remorseful
        //
        for (Mood::RemorsefulConstIterator
             b (i.getRemorseful ().begin ()), n (i.getRemorseful ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "remorseful",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // restless
        //
        for (Mood::RestlessConstIterator
             b (i.getRestless ().begin ()), n (i.getRestless ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "restless",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // sad
        //
        for (Mood::SadConstIterator
             b (i.getSad ().begin ()), n (i.getSad ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "sad",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // sarcastic
        //
        for (Mood::SarcasticConstIterator
             b (i.getSarcastic ().begin ()), n (i.getSarcastic ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "sarcastic",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // serious
        //
        for (Mood::SeriousConstIterator
             b (i.getSerious ().begin ()), n (i.getSerious ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "serious",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // shocked
        //
        for (Mood::ShockedConstIterator
             b (i.getShocked ().begin ()), n (i.getShocked ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "shocked",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // shy
        //
        for (Mood::ShyConstIterator
             b (i.getShy ().begin ()), n (i.getShy ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "shy",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // sick
        //
        for (Mood::SickConstIterator
             b (i.getSick ().begin ()), n (i.getSick ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "sick",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // sleepy
        //
        for (Mood::SleepyConstIterator
             b (i.getSleepy ().begin ()), n (i.getSleepy ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "sleepy",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // stressed
        //
        for (Mood::StressedConstIterator
             b (i.getStressed ().begin ()), n (i.getStressed ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "stressed",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // surprised
        //
        for (Mood::SurprisedConstIterator
             b (i.getSurprised ().begin ()), n (i.getSurprised ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "surprised",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // thirsty
        //
        for (Mood::ThirstyConstIterator
             b (i.getThirsty ().begin ()), n (i.getThirsty ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "thirsty",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // worried
        //
        for (Mood::WorriedConstIterator
             b (i.getWorried ().begin ()), n (i.getWorried ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "worried",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // other
        //
        for (Mood::OtherConstIterator
             b (i.getOther ().begin ()), n (i.getOther ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "other",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // any
        //
        for (Mood::AnyConstIterator
             b (i.getAny ().begin ()), n (i.getAny ().end ());
             b != n; ++b)
        {
          e.appendChild (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMElement* > (&(*b)), true));
        }

        // from
        //
        if (i.getFrom ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "from",
              e));

          a << *i.getFrom ();
        }

        // until
        //
        if (i.getUntil ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "until",
              e));

          a << *i.getUntil ();
        }

        // id
        //
        if (i.getId ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "id",
              e));

          a << *i.getId ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const PlaceIs& i)
      {
        e << static_cast< const ::flexisip::Xsd::XmlSchema::Type& > (i);

        // any_attribute
        //
        for (PlaceIs::AnyAttributeConstIterator
             b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMAttr* a (
            static_cast< ::xercesc::DOMAttr* > (
              e.getOwnerDocument ()->importNode (
                const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

          if (a->getLocalName () == 0)
            e.setAttributeNode (a);
          else
            e.setAttributeNodeNS (a);
        }

        // note
        //
        for (PlaceIs::NoteConstIterator
             b (i.getNote ().begin ()), n (i.getNote ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "note",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // audio
        //
        if (i.getAudio ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "audio",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getAudio ();
        }

        // video
        //
        if (i.getVideo ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "video",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getVideo ();
        }

        // text
        //
        if (i.getText ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "text",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getText ();
        }

        // from
        //
        if (i.getFrom ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "from",
              e));

          a << *i.getFrom ();
        }

        // until
        //
        if (i.getUntil ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "until",
              e));

          a << *i.getUntil ();
        }

        // id
        //
        if (i.getId ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "id",
              e));

          a << *i.getId ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const PlaceType& i)
      {
        e << static_cast< const ::flexisip::Xsd::XmlSchema::Type& > (i);

        // any_attribute
        //
        for (PlaceType::AnyAttributeConstIterator
             b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMAttr* a (
            static_cast< ::xercesc::DOMAttr* > (
              e.getOwnerDocument ()->importNode (
                const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

          if (a->getLocalName () == 0)
            e.setAttributeNode (a);
          else
            e.setAttributeNodeNS (a);
        }

        // note
        //
        for (PlaceType::NoteConstIterator
             b (i.getNote ().begin ()), n (i.getNote ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "note",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // other
        //
        if (i.getOther ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "other",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getOther ();
        }

        // any
        //
        for (PlaceType::AnyConstIterator
             b (i.getAny ().begin ()), n (i.getAny ().end ());
             b != n; ++b)
        {
          e.appendChild (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMElement* > (&(*b)), true));
        }

        // from
        //
        if (i.getFrom ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "from",
              e));

          a << *i.getFrom ();
        }

        // until
        //
        if (i.getUntil ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "until",
              e));

          a << *i.getUntil ();
        }

        // id
        //
        if (i.getId ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "id",
              e));

          a << *i.getId ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Privacy& i)
      {
        e << static_cast< const ::flexisip::Xsd::XmlSchema::Type& > (i);

        // any_attribute
        //
        for (Privacy::AnyAttributeConstIterator
             b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMAttr* a (
            static_cast< ::xercesc::DOMAttr* > (
              e.getOwnerDocument ()->importNode (
                const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

          if (a->getLocalName () == 0)
            e.setAttributeNode (a);
          else
            e.setAttributeNodeNS (a);
        }

        // note
        //
        for (Privacy::NoteConstIterator
             b (i.getNote ().begin ()), n (i.getNote ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "note",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // unknown
        //
        if (i.getUnknown ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "unknown",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getUnknown ();
        }

        // audio
        //
        if (i.getAudio ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "audio",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getAudio ();
        }

        // text
        //
        if (i.getText ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "text",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getText ();
        }

        // video
        //
        if (i.getVideo ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "video",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getVideo ();
        }

        // any
        //
        for (Privacy::AnyConstIterator
             b (i.getAny ().begin ()), n (i.getAny ().end ());
             b != n; ++b)
        {
          e.appendChild (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMElement* > (&(*b)), true));
        }

        // from
        //
        if (i.getFrom ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "from",
              e));

          a << *i.getFrom ();
        }

        // until
        //
        if (i.getUntil ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "until",
              e));

          a << *i.getUntil ();
        }

        // id
        //
        if (i.getId ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "id",
              e));

          a << *i.getId ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Relationship& i)
      {
        e << static_cast< const ::flexisip::Xsd::XmlSchema::Type& > (i);

        // note
        //
        for (Relationship::NoteConstIterator
             b (i.getNote ().begin ()), n (i.getNote ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "note",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // assistant
        //
        if (i.getAssistant ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "assistant",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getAssistant ();
        }

        // associate
        //
        if (i.getAssociate ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "associate",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getAssociate ();
        }

        // family
        //
        if (i.getFamily ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "family",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getFamily ();
        }

        // friend
        //
        if (i.getFriend ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "friend",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getFriend ();
        }

        // other
        //
        if (i.getOther ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "other",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getOther ();
        }

        // self
        //
        if (i.getSelf ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "self",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getSelf ();
        }

        // supervisor
        //
        if (i.getSupervisor ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "supervisor",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getSupervisor ();
        }

        // unknown
        //
        if (i.getUnknown ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "unknown",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getUnknown ();
        }

        // any
        //
        for (Relationship::AnyConstIterator
             b (i.getAny ().begin ()), n (i.getAny ().end ());
             b != n; ++b)
        {
          e.appendChild (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMElement* > (&(*b)), true));
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const ServiceClass& i)
      {
        e << static_cast< const ::flexisip::Xsd::XmlSchema::Type& > (i);

        // note
        //
        for (ServiceClass::NoteConstIterator
             b (i.getNote ().begin ()), n (i.getNote ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "note",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *b;
        }

        // courier
        //
        if (i.getCourier ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "courier",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getCourier ();
        }

        // electronic
        //
        if (i.getElectronic ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "electronic",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getElectronic ();
        }

        // freight
        //
        if (i.getFreight ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "freight",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getFreight ();
        }

        // in-person
        //
        if (i.getInPerson ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "in-person",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getInPerson ();
        }

        // postal
        //
        if (i.getPostal ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "postal",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getPostal ();
        }

        // unknown
        //
        if (i.getUnknown ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "unknown",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getUnknown ();
        }

        // any
        //
        for (ServiceClass::AnyConstIterator
             b (i.getAny ().begin ()), n (i.getAny ().end ());
             b != n; ++b)
        {
          e.appendChild (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMElement* > (&(*b)), true));
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Sphere& i)
      {
        e << static_cast< const ::flexisip::Xsd::XmlSchema::Type& > (i);

        // any_attribute
        //
        for (Sphere::AnyAttributeConstIterator
             b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMAttr* a (
            static_cast< ::xercesc::DOMAttr* > (
              e.getOwnerDocument ()->importNode (
                const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

          if (a->getLocalName () == 0)
            e.setAttributeNode (a);
          else
            e.setAttributeNodeNS (a);
        }

        // home
        //
        if (i.getHome ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "home",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getHome ();
        }

        // work
        //
        if (i.getWork ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "work",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getWork ();
        }

        // unknown
        //
        if (i.getUnknown ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "unknown",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getUnknown ();
        }

        // any
        //
        for (Sphere::AnyConstIterator
             b (i.getAny ().begin ()), n (i.getAny ().end ());
             b != n; ++b)
        {
          e.appendChild (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMElement* > (&(*b)), true));
        }

        // from
        //
        if (i.getFrom ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "from",
              e));

          a << *i.getFrom ();
        }

        // until
        //
        if (i.getUntil ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "until",
              e));

          a << *i.getUntil ();
        }

        // id
        //
        if (i.getId ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "id",
              e));

          a << *i.getId ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const StatusIcon& i)
      {
        e << static_cast< const ::flexisip::Xsd::XmlSchema::Uri& > (i);

        // any_attribute
        //
        for (StatusIcon::AnyAttributeConstIterator
             b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMAttr* a (
            static_cast< ::xercesc::DOMAttr* > (
              e.getOwnerDocument ()->importNode (
                const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

          if (a->getLocalName () == 0)
            e.setAttributeNode (a);
          else
            e.setAttributeNodeNS (a);
        }

        // from
        //
        if (i.getFrom ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "from",
              e));

          a << *i.getFrom ();
        }

        // until
        //
        if (i.getUntil ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "until",
              e));

          a << *i.getUntil ();
        }

        // id
        //
        if (i.getId ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "id",
              e));

          a << *i.getId ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const TimeOffset& i)
      {
        e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::flexisip::Xsd::XmlSchema::Integer, char, ::flexisip::Xsd::XmlSchema::SimpleType >& > (i);

        // any_attribute
        //
        for (TimeOffset::AnyAttributeConstIterator
             b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMAttr* a (
            static_cast< ::xercesc::DOMAttr* > (
              e.getOwnerDocument ()->importNode (
                const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

          if (a->getLocalName () == 0)
            e.setAttributeNode (a);
          else
            e.setAttributeNodeNS (a);
        }

        // from
        //
        if (i.getFrom ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "from",
              e));

          a << *i.getFrom ();
        }

        // until
        //
        if (i.getUntil ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "until",
              e));

          a << *i.getUntil ();
        }

        // description
        //
        if (i.getDescription ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "description",
              e));

          a << *i.getDescription ();
        }

        // id
        //
        if (i.getId ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "id",
              e));

          a << *i.getId ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const UserInput& i)
      {
        e << static_cast< const ::flexisip::Xsd::Rpid::ActiveIdle& > (i);

        // any_attribute
        //
        for (UserInput::AnyAttributeConstIterator
             b (i.getAnyAttribute ().begin ()), n (i.getAnyAttribute ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMAttr* a (
            static_cast< ::xercesc::DOMAttr* > (
              e.getOwnerDocument ()->importNode (
                const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

          if (a->getLocalName () == 0)
            e.setAttributeNode (a);
          else
            e.setAttributeNodeNS (a);
        }

        // idle-threshold
        //
        if (i.getIdleThreshold ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "idle-threshold",
              e));

          a << *i.getIdleThreshold ();
        }

        // last-input
        //
        if (i.getLastInput ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "last-input",
              e));

          a << *i.getLastInput ();
        }

        // id
        //
        if (i.getId ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "id",
              e));

          a << *i.getId ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Audio& i)
      {
        e << static_cast< const ::flexisip::Xsd::XmlSchema::Type& > (i);

        // noisy
        //
        if (i.getNoisy ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "noisy",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getNoisy ();
        }

        // ok
        //
        if (i.getOk ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ok",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getOk ();
        }

        // quiet
        //
        if (i.getQuiet ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "quiet",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getQuiet ();
        }

        // unknown
        //
        if (i.getUnknown ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "unknown",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getUnknown ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Video& i)
      {
        e << static_cast< const ::flexisip::Xsd::XmlSchema::Type& > (i);

        // toobright
        //
        if (i.getToobright ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "toobright",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getToobright ();
        }

        // ok
        //
        if (i.getOk ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ok",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getOk ();
        }

        // dark
        //
        if (i.getDark ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "dark",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getDark ();
        }

        // unknown
        //
        if (i.getUnknown ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "unknown",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getUnknown ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Text& i)
      {
        e << static_cast< const ::flexisip::Xsd::XmlSchema::Type& > (i);

        // uncomfortable
        //
        if (i.getUncomfortable ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "uncomfortable",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getUncomfortable ();
        }

        // inappropriate
        //
        if (i.getInappropriate ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "inappropriate",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getInappropriate ();
        }

        // ok
        //
        if (i.getOk ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ok",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getOk ();
        }

        // unknown
        //
        if (i.getUnknown ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "unknown",
              "urn:ietf:params:xml:ns:pidf:rpid",
              e));

          s << *i.getUnknown ();
        }
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
#if __clang__ || __GNUC__ >= 4
	#pragma GCC diagnostic pop
#endif
//
// End epilogue.

